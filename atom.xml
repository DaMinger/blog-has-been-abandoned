<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[DaMinger's blog]]></title>
  <subtitle><![CDATA[信春哥，系统稳，闭眼上线不回滚]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://github.com/DaMinger/DaMinger.github.io.git/"/>
  <updated>2014-05-29T03:43:22.324Z</updated>
  <id>https://github.com/DaMinger/DaMinger.github.io.git/</id>
  
  <author>
    <name><![CDATA[DaMinger]]></name>
    <email><![CDATA[564400632@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[LeetCode:Longest Palindromic Substring]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/longestpalindromicstring/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/29/数据结构与算法/LeetCode/longestpalindromicstring/</id>
    <published>2014-05-29T03:03:23.000Z</published>
    <updated>2014-05-29T03:41:07.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> <span class="keyword">string</span> S, find <span class="operator">the</span> longest palindromic substring <span class="operator">in</span> S. 
You may assume that <span class="operator">the</span> maximum <span class="built_in">length</span> <span class="operator">of</span> S is <span class="number">1000</span>, 
<span class="operator">and</span> there exists <span class="constant">one</span> unique longest palindromic substring.
</code></pre><p>思路：求最长回文子串，本题解法较多，我是参考这个网址，用的动态规划<br><a href="https://github.com/xiangzhai/leetcode/blob/master/question/longest-palindromic-substring-part-i.md" target="_blank">https://github.com/xiangzhai/leetcode/blob/master/question/longest-palindromic-substring-part-i.md</a></p>
<h4 id="解法">解法</h4>
<pre><code><span class="built_in">String</span> longestPalindromeDP(<span class="built_in">string</span> s) {
    <span class="built_in">int</span> n = s.length();
    <span class="built_in">int</span> longestBegin = <span class="number">0</span>;
    <span class="built_in">int</span> maxLen = <span class="number">1</span>;
    boolean table[<span class="number">1000</span>][<span class="number">1000</span>] = {<span class="literal">false</span>};
    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)
        table[i][i] = <span class="literal">true</span>;
    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++) {
        <span class="keyword">if</span> (s[i] == s[i+<span class="number">1</span>]) {
            table[i][i+<span class="number">1</span>] = <span class="literal">true</span>;
            longestBegin = i;
            maxLen = <span class="number">2</span>;
        }
    }
    <span class="keyword">for</span> (<span class="built_in">int</span> <span class="built_in">len</span> = <span class="number">3</span>; <span class="built_in">len</span> &lt;= n; <span class="built_in">len</span>++) {
        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n-<span class="built_in">len</span>+<span class="number">1</span>; i++) {
            <span class="built_in">int</span> j = i + <span class="built_in">len</span> - <span class="number">1</span>;
            <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; table[i+<span class="number">1</span>][j-<span class="number">1</span>]) {
                table[i][j] = <span class="literal">true</span>;
                longestBegin = i;
                maxLen = <span class="built_in">len</span>;
            }
        }
    }
    return s.substr(longestBegin, maxLen);
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Add Two Numbers]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/addtownumber/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/29/数据结构与算法/LeetCode/addtownumber/</id>
    <published>2014-05-29T03:03:02.000Z</published>
    <updated>2014-05-29T03:16:33.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>You are given <span class="constant">two</span> linked lists representing <span class="constant">two</span> non-negative numbers. 
The digits are stored <span class="operator">in</span> reverse order <span class="operator">and</span> <span class="keyword">each</span> <span class="operator">of</span> their nodes contain <span class="operator">a</span> single digit. 
Add <span class="operator">the</span> <span class="constant">two</span> numbers <span class="operator">and</span> <span class="constant">return</span> <span class="keyword">it</span> <span class="keyword">as</span> <span class="operator">a</span> linked list.

Input: (<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)
Output: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span>
</code></pre><p>思路：处理好进位问题就行了，注意末尾进位。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> ListNode {
      <span class="keyword">int</span> val;
      ListNode next;
      ListNode(<span class="keyword">int</span> x) {
          val = x;
          next = <span class="keyword">null</span>;
      }
}
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span>(ListNode l1, ListNode l2) {
        <span class="keyword">int</span> carry=<span class="number">0</span>;
        ListNode newHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);
        ListNode p1=l1,p2=l2,p3=newHead;
        <span class="keyword">while</span>(p1!=<span class="keyword">null</span> ||p2!=<span class="keyword">null</span>){
            <span class="keyword">if</span>(p1!=<span class="keyword">null</span>){
                carry +=p1.val;
                p1=p1.next;
            }
            <span class="keyword">if</span>(p2!=<span class="keyword">null</span>){
                carry +=p2.val;
                p2=p2.next;
            }

            p3.next=<span class="keyword">new</span> ListNode(carry%<span class="number">10</span>);
            p3=p3.next;
            <span class="comment">//进位处理</span>
            carry /=<span class="number">10</span>;
        }
        <span class="comment">//最后末尾产生进位</span>
        <span class="keyword">if</span>(carry==<span class="number">1</span>)
            p3.next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);
        <span class="keyword">return</span> newHead.next;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Two Sum]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/twosum/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/数据结构与算法/LeetCode/twosum/</id>
    <published>2014-05-27T09:15:45.000Z</published>
    <updated>2014-05-27T09:20:22.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given an array <span class="keyword">of</span> integers, find two numbers such <span class="keyword">that</span> they add up <span class="keyword">to</span> a specific target <span class="type">number</span>.

The function twoSum should <span class="constant">return</span> indices <span class="keyword">of</span> <span class="keyword">the</span> two numbers such <span class="keyword">that</span> they add up <span class="keyword">to</span> <span class="keyword">the</span> target, <span class="keyword">where</span> index1 must be <span class="keyword">less than</span> index2. Please note <span class="keyword">that</span> your returned answers (both index1 <span class="keyword">and</span> index2) are <span class="keyword">not</span> zero-based.

You may assume <span class="keyword">that</span> each input would have exactly one solution.

Input: numbers={<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>}, target=<span class="number">9</span>
Output: index1=<span class="number">1</span>, index2=<span class="number">2</span>
</code></pre><p>思路：hashmap 存另外一个数及其index</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">twoSum</span>(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) {
        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();
        <span class="keyword">int</span> [] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++){
            <span class="keyword">if</span>(map.containsKey(numbers[i])){
                <span class="keyword">int</span> index=map.<span class="keyword">get</span>(numbers[i]);
                result[<span class="number">0</span>]=index+<span class="number">1</span>;
                result[<span class="number">1</span>]=i+<span class="number">1</span>;
                <span class="keyword">break</span>;
            }<span class="keyword">else</span>{
                map.put(target-numbers[i],i);
            }
        }
        <span class="keyword">return</span> result;
    }
    <span class="comment">//超时写法</span>
    <span class="comment">//    public int[]twoSum(int[]numbers,int target){</span>
    <span class="comment">//        int[]ret=new int[2];</span>
    <span class="comment">//        for(int i=0;i&lt;numbers.length;i++){</span>
    <span class="comment">//            for(int j=i+1;j&lt;numbers.length;j++){</span>
    <span class="comment">//                if(numbers[i]+numbers[j]==target){</span>
    <span class="comment">//                    ret[0]=i+1;</span>
    <span class="comment">//                    ret[1]=j+1;</span>
    <span class="comment">//                }        </span>
    <span class="comment">//            }</span>
    <span class="comment">//        }</span>
    <span class="comment">//        return ret;</span>
    <span class="comment">//    }</span>
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Reorder List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/reorderlist/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/数据结构与算法/LeetCode/reorderlist/</id>
    <published>2014-05-27T06:18:26.000Z</published>
    <updated>2014-05-27T06:23:39.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a singly linked <span class="type">list</span> L: L0→L1→…→Ln-<span class="number">1</span>→Ln,
reorder <span class="keyword">it</span> <span class="keyword">to</span>: L0→Ln→L1→Ln-<span class="number">1</span>→L2→Ln-<span class="number">2</span>→…

You must do this <span class="keyword">in</span>-place <span class="keyword">without</span> altering <span class="keyword">the</span> nodes' values.

For example,
Given {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}, reorder <span class="keyword">it</span> <span class="keyword">to</span> {<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>}.
</code></pre><p>思路：第一把整个链表划分成2个等长的子链表，如果原链表长度为奇数，那么第一个子链表的长度多1；第二翻转第二个子链表；第三将两个子链表合并。</p>
<h4 id="解法">解法</h4>
<pre><code>class ListNode {
      <span class="keyword">int</span> val;
      ListNode next;
      ListNode(<span class="keyword">int</span> x) {
         val = x;
          next = <span class="keyword">null</span>;
      }
}

<span class="keyword">public</span> <span class="keyword">class</span> Reorderlist {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span>(ListNode head) {
        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)
            <span class="keyword">return</span>;
        ListNode slowNode=head,fastNode=head;
        <span class="keyword">while</span>(fastNode.next!=<span class="keyword">null</span>){
            fastNode=fastNode.next;
            <span class="keyword">if</span>(fastNode.next!=<span class="keyword">null</span>)
                fastNode=fastNode.next;
            <span class="keyword">else</span>
                <span class="keyword">break</span>;
            slowNode=slowNode.next;
        }
        <span class="comment">//快慢指针确定链表中点</span>
        ListNode head1=head,head2=slowNode.next;
        slowNode.next=<span class="keyword">null</span>;
        <span class="comment">//对后半部分就行进行逆序</span>
        ListNode cur=head2,post=cur.next;
        cur.next=<span class="keyword">null</span>;
        <span class="keyword">while</span>(post!=<span class="keyword">null</span>){
            ListNode temp=post.next;
            post.next=cur;
            cur=post;
            post=temp;
        }
        head2 =cur;
        <span class="comment">//合并链表</span>
        ListNode p=head1,q=head2;
        <span class="keyword">while</span>(q!=<span class="keyword">null</span>){
            ListNode temp1=p.next;
            ListNode temp2=q.next;
            p.next=q;
            q.next=temp1;
            p=temp1;
            q=temp2;
        }
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Pow(x, n)]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/power_x_n/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/数据结构与算法/LeetCode/power_x_n/</id>
    <published>2014-05-25T11:13:08.000Z</published>
    <updated>2014-05-25T11:46:44.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Implement <span class="built_in">pow</span>(x, n).
</code></pre><p>思路：最简单的方法是循环，循环n-1遍，每次乘以x。时间复杂度：O(N)。很显然，最后超时了。并且如果用递归的话，函数好写简洁，但是碰见大数，栈空间不够用会导致运行时错误（stack overflow）。<br>二分法解决问题：x^n = x^n/2 <em> x^n/2 </em> x^n%2  n考虑奇数偶数 时间复杂度：O(logN)<br><img src="/img/数据结构与算法/2.png" alt=" "></p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span>(<span class="keyword">double</span> x, <span class="keyword">int</span> n) {
        <span class="keyword">if</span> (n == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">1.0</span>;
        <span class="keyword">double</span> half = pow(x, n/<span class="number">2</span>);
        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)
            <span class="keyword">return</span> half * half;
        <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)
            <span class="keyword">return</span> half * half * x;
        <span class="keyword">else</span> 
            <span class="keyword">return</span> half * half / x;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Single Number I and  II]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/singlenumber/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/数据结构与算法/LeetCode/singlenumber/</id>
    <published>2014-05-25T11:12:39.000Z</published>
    <updated>2014-05-25T11:31:08.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>I:
Given <span class="operator">an</span> array <span class="operator">of</span> integers, every <span class="keyword">element</span> appears twice except <span class="keyword">for</span> <span class="constant">one</span>. Find that single <span class="constant">one</span>.
II:
Given <span class="operator">an</span> array <span class="operator">of</span> integers, every <span class="keyword">element</span> appears <span class="constant">three</span> times except <span class="keyword">for</span> <span class="constant">one</span>. Find that single <span class="constant">one</span>.

Note:
Your algorithm should have <span class="operator">a</span> linear runtime complexity. Could you implement <span class="keyword">it</span> <span class="keyword">without</span> <span class="keyword">using</span> extra memory?
</code></pre><p>思路：hashmap去存数组及对应的次数即可。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="keyword">int</span>[] A) {
        <span class="keyword">if</span>(A.length==<span class="number">0</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }
        HashMap&lt;Integer,Integer&gt; hash= <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();
        <span class="keyword">for</span>(<span class="keyword">int</span> a:A){
            <span class="keyword">if</span>(hash.containsKey(a)){
                hash.put(a,hash.<span class="keyword">get</span>(a)+<span class="number">1</span>);
            }
            <span class="keyword">else</span>{
                hash.put(a,<span class="number">1</span>);
            }
        }
        <span class="keyword">for</span>(<span class="keyword">int</span> key:hash.keySet()){
            <span class="keyword">if</span>(hash.<span class="keyword">get</span>(key)==<span class="number">1</span>)
                <span class="keyword">return</span> key;
        }
        <span class="keyword">return</span> <span class="number">0</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Copy List with Random Pointer]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/copylistwithrandompointer/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/数据结构与算法/LeetCode/copylistwithrandompointer/</id>
    <published>2014-05-25T11:10:30.000Z</published>
    <updated>2014-05-25T11:47:03.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>A linked <span class="type">list</span> <span class="keyword">is</span> <span class="keyword">given</span> such <span class="keyword">that</span> each node <span class="keyword">contains</span> an additional random pointer which could point <span class="keyword">to</span> any node <span class="keyword">in</span> <span class="keyword">the</span> <span class="type">list</span> <span class="keyword">or</span> null.

Return a deep <span class="keyword">copy</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="type">list</span>.
</code></pre><p>思路：因为每个链表都有随机指针，遍历一遍肯定是不行的，遍历2遍，第一遍去记下next，第二遍去记下random，但是时间复杂度o(n^2),参考下面帖子想法不错，<br><a href="http://blog.csdn.net/zhaojinjia/article/details/9313275" target="_blank">http://blog.csdn.net/zhaojinjia/article/details/9313275</a>  <a href="http://blog.csdn.net/ljphhj/article/details/21832129" target="_blank">http://blog.csdn.net/ljphhj/article/details/21832129</a> <a href="http://blog.csdn.net/linhuanmars/article/details/22463599" target="_blank">http://blog.csdn.net/linhuanmars/article/details/22463599</a></p>
<p>第一步对每个节点进行扫描，复制每个节点，将新节点接在旧节点后面；第二步扫描每个旧节点，把旧结点的随机指针赋给新节点的随机指针；第三步扫描所有节点，把链表拆成两个，第一个还原原链表，而第二个就是我们要求的复制链表。因为现在链表是旧新更替，只要把每隔两个结点分别相连，对链表进行分割即可。这个方法总共进行三次线性扫描，所以时间复杂度是O(n)。而这里并不需要额外空间，所以空间复杂度是O(1)。</p>
<h4 id="解法">解法</h4>
<pre><code>class RandomListNode {
        <span class="keyword">int</span> label;
        RandomListNode next, random;
        RandomListNode(<span class="keyword">int</span> x) { <span class="keyword">this</span>.label = x; }
     };
<span class="keyword">public</span> <span class="keyword">class</span> copyListWithRandom {
    <span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span>(RandomListNode head) {
        <span class="keyword">if</span>(head ==<span class="keyword">null</span>){
            <span class="keyword">return</span> head;
        }
        RandomListNode nowNode=head;
        <span class="keyword">while</span>(nowNode !=<span class="keyword">null</span>){
            RandomListNode copyNode=<span class="keyword">new</span> RandomListNode(nowNode.label);
            copyNode.next=nowNode.next;
            nowNode.next=copyNode;
            nowNode =nowNode.next.next;
        }
        <span class="comment">//把随机节点接好</span>
        nowNode=head;
        <span class="keyword">while</span>(nowNode !=<span class="keyword">null</span>){
            <span class="keyword">if</span>(nowNode.random!=<span class="keyword">null</span>){
                nowNode.next.random=nowNode.random.next;
            }
            nowNode=nowNode.next.next;
        }
        <span class="comment">//分成两个链表，第一个链表还原，第二链表就是我们想要的</span>
        RandomListNode newHead =head.next;
        nowNode=head;
        <span class="keyword">while</span>(nowNode!=<span class="keyword">null</span>){
            <span class="comment">//还原第一个链表</span>
            RandomListNode newNode =nowNode.next;
            nowNode.next=newNode.next;
            <span class="keyword">if</span>(newNode.next!=<span class="keyword">null</span>)
                newNode.next=newNode.next.next;
            nowNode=nowNode.next;
        }
        <span class="keyword">return</span> newHead;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:String to Integer(atoi)]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/stringtointeger/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/stringtointeger/</id>
    <published>2014-05-23T12:27:57.000Z</published>
    <updated>2014-05-23T13:07:58.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>String <span class="built_in">to</span> Integer (atoi) 
Implement atoi <span class="built_in">to</span> <span class="built_in">convert</span> <span class="operator">a</span> <span class="keyword">string</span> <span class="built_in">to</span> <span class="operator">an</span> <span class="keyword">integer</span>.
</code></pre><p>思路：输入的情况比较多，空串，一串空格，空，正负数，数组越界</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringtoInteger</span> {</span>
     <span class="keyword">public</span> <span class="keyword">int</span> atoi(String <span class="keyword">str</span>) {
            <span class="comment">//空串</span>
            <span class="keyword">if</span>(<span class="keyword">str</span>==<span class="keyword">null</span>){
                <span class="keyword">return</span> <span class="number">0</span>;
            }
            <span class="comment">//一堆空格</span>
            <span class="keyword">str</span>=<span class="keyword">str</span>.trim();
            <span class="keyword">if</span>(<span class="keyword">str</span>.length()==<span class="number">0</span>){
                <span class="keyword">return</span> <span class="number">0</span>;
            }
            <span class="comment">//正负数</span>
            <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;
            <span class="keyword">int</span> i=<span class="number">0</span>;
            <span class="keyword">if</span>(<span class="keyword">str</span>.charAt(<span class="number">0</span>)==<span class="string">'-'</span>){
                flag=<span class="keyword">false</span>;
                i++;
            }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">str</span>.charAt(<span class="number">0</span>)==<span class="string">'+'</span>){
                i++;
            }
            <span class="comment">//这里一定要用比INT大的数据类型，用INT，数组刚刚越界时（自动转型），过不去</span>
            <span class="keyword">long</span>  result =<span class="number">0</span>;
            <span class="keyword">while</span>(<span class="keyword">str</span>.length()&gt;i&amp;&amp;<span class="keyword">str</span>.charAt(i)&gt;=<span class="string">'0'</span>&amp;&amp;<span class="keyword">str</span>.charAt(i)&lt;=<span class="string">'9'</span>){
                result=result*<span class="number">10</span>+<span class="keyword">str</span>.charAt(i)-<span class="string">'0'</span>;
                i++;
            }
            <span class="keyword">if</span>(!flag){
                result=-result;
            }
            <span class="keyword">if</span> (result &gt; Integer.MAX_VALUE)
                <span class="keyword">return</span> Integer.MAX_VALUE;

            <span class="keyword">if</span> (result &lt; Integer.MIN_VALUE)
                <span class="keyword">return</span> Integer.MIN_VALUE;
            <span class="keyword">return</span> (<span class="keyword">int</span>) result;
        }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Reverse Integer]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/reverinteger/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/reverinteger/</id>
    <published>2014-05-23T12:27:35.000Z</published>
    <updated>2014-05-23T13:05:17.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Reverse Integer 
Reverse digits <span class="operator">of</span> <span class="operator">an</span> <span class="keyword">integer</span>.

Example1: x = <span class="number">123</span>, <span class="constant">return</span> <span class="number">321</span>
Example2: x = -<span class="number">123</span>, <span class="constant">return</span> -<span class="number">321</span>
</code></pre><p>思路：整数各位取余</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span>(<span class="keyword">int</span> x) {
    <span class="keyword">int</span> nReverse = <span class="number">0</span>;
            <span class="keyword">while</span> (x != <span class="number">0</span>) {
                nReverse = nReverse * <span class="number">10</span> + x % <span class="number">10</span>;
                x = x / <span class="number">10</span>;
            }
            <span class="keyword">return</span> nReverse;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Linked List Cycle II]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/linkedlistcycle2/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/linkedlistcycle2/</id>
    <published>2014-05-23T12:26:02.000Z</published>
    <updated>2014-05-23T13:09:17.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Linked List Cycle II 
Given <span class="operator">a</span> linked list, <span class="constant">return</span> <span class="operator">the</span> node where <span class="operator">the</span> cycle <span class="operator">begins</span>. If there is no cycle, <span class="constant">return</span> <span class="constant">null</span>.

Follow up:
Can you solve <span class="keyword">it</span> <span class="keyword">without</span> <span class="keyword">using</span> extra <span class="constant">space</span>?
</code></pre><p>思路：此题除判断回路外还需要判断闭环的位置。依旧设置快慢指针p1,p2.假设链表长度为n，环开始的节点Y为到头节点X有a步，p1和p2在距离环开始的节点b步的Z地方相遇（按顺时针），假设相遇节点Z到环开始的节点c步（按顺时针），那么p1走的路程为a+b，p2走的路程为a+b+c+b，显然p2走的路程为p1的2倍，于是2(a+b)=a+2b+c，于是我们推出a=c。</p>
<p>知道这个结论后面的解答就很简单了，p1和p2相遇后，把p1指向头节点，然后p1,p2都一次走一步，走了c步后p1 p2相遇，该节点Y就是环开始的节点。<br><img src="/img/数据结构与算法/2.jpg" alt=""></p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">class</span> ListNode {
      <span class="built_in">int</span> val;
      ListNode <span class="keyword">next</span>;
      ListNode(<span class="built_in">int</span> x) {
         val = x;
          <span class="keyword">next</span> = <span class="literal">null</span>;
      }
}
<span class="keyword">public</span> <span class="keyword">class</span> detectCycle222 {
    <span class="keyword">public</span> ListNode detectCycle(ListNode head) {
        ListNode slow=head,fast=head;
        <span class="keyword">while</span>(<span class="literal">true</span>){
            <span class="keyword">if</span>(fast ==<span class="literal">null</span>||fast.<span class="keyword">next</span>==<span class="literal">null</span>){
                return <span class="literal">null</span>;
            }
            slow =slow.<span class="keyword">next</span>;
            fast =fast.<span class="keyword">next</span>.<span class="keyword">next</span>;
            <span class="keyword">if</span>(slow ==fast){
                break;
            }
        }
        slow=head;
        <span class="keyword">while</span>(slow!=fast){
            slow=slow.<span class="keyword">next</span>;
            fast=fast.<span class="keyword">next</span>;
        }
        return slow;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Linked List Cycle]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/linkedlistcycle/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/linkedlistcycle/</id>
    <published>2014-05-23T12:25:51.000Z</published>
    <updated>2014-05-23T13:04:27.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Linked List Cycle
Given <span class="operator">a</span> linked list, determine <span class="keyword">if</span> <span class="keyword">it</span> has <span class="operator">a</span> cycle <span class="operator">in</span> <span class="keyword">it</span>.

Follow up:
Can you solve <span class="keyword">it</span> <span class="keyword">without</span> <span class="keyword">using</span> extra <span class="constant">space</span>?
</code></pre><p>思路：设计两个快慢指针，慢节点每次移动一个节点，快节点每次移动两个节点，当快慢指针相等时，则存在闭环</p>
<h4 id="解法">解法</h4>
<pre><code>class ListNode {
      <span class="keyword">int</span> val;
      ListNode next;
      ListNode(<span class="keyword">int</span> x) {
         val = x;
          next = <span class="keyword">null</span>;
      }
}

<span class="keyword">public</span> <span class="keyword">class</span> Reorderlist {
    <span class="keyword">public</span> boolean <span class="title">hasCycle</span>(ListNode head){
        ListNode slow=head,fast=head;
        <span class="keyword">while</span>(<span class="keyword">true</span>){
            <span class="keyword">if</span>(fast ==<span class="keyword">null</span>||fast.next==<span class="keyword">null</span>){
                <span class="keyword">return</span> <span class="keyword">false</span>;
            }
            slow =slow.next;
            fast =fast.next.next;
            <span class="keyword">if</span>(slow ==fast){
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:LRU Cache]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/lrucache/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/lrucache/</id>
    <published>2014-05-23T12:24:58.000Z</published>
    <updated>2014-05-23T13:03:41.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>LRU Cache
Design <span class="operator">and</span> implement <span class="operator">a</span> data structure <span class="keyword">for</span> Least Recently Used (LRU) cache. It should support <span class="operator">the</span> following operations: <span class="built_in">get</span> <span class="operator">and</span> <span class="built_in">set</span>.

<span class="built_in">get</span>(key) - Get <span class="operator">the</span> <span class="built_in">value</span> (will always be positive) <span class="operator">of</span> <span class="operator">the</span> key <span class="keyword">if</span> <span class="operator">the</span> key exists <span class="operator">in</span> <span class="operator">the</span> cache, otherwise <span class="constant">return</span> -<span class="number">1.</span>
<span class="built_in">set</span>(key, <span class="built_in">value</span>) - Set <span class="operator">or</span> insert <span class="operator">the</span> <span class="built_in">value</span> <span class="keyword">if</span> <span class="operator">the</span> key is <span class="operator">not</span> already present. When <span class="operator">the</span> cache reached its capacity, 
                  <span class="keyword">it</span> should invalidate <span class="operator">the</span> least recently used <span class="keyword">item</span> <span class="keyword">before</span> inserting <span class="operator">a</span> <span class="built_in">new</span> <span class="keyword">item</span>.
</code></pre><p>思路：双向链表+hashmap 没有超出容量之前，新节点放在头部，有重复的话，把该节点移到头结点，超出容量的话，移除尾节点<br><img src="/img/数据结构与算法/1.png" alt="双向链表"></p>
<h4 id="解法">解法</h4>
<pre><code>import java.util.HashMap;

<span class="comment">//双链表＋HashMap</span>
class Node{
    Node prev;
    Node next;
    <span class="keyword">int</span> <span class="keyword">value</span>;
    <span class="keyword">int</span> key;
    Node(<span class="keyword">int</span> key,<span class="keyword">int</span> <span class="keyword">value</span>){
        <span class="keyword">this</span>.<span class="keyword">value</span>=<span class="keyword">value</span>;
        <span class="keyword">this</span>.key=key;
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> LRUCache {
    <span class="keyword">private</span> <span class="keyword">int</span>  capacity;
    <span class="keyword">private</span> <span class="keyword">int</span> len;
    <span class="keyword">private</span> Node head;
    <span class="keyword">private</span> Node end;
    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map =<span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();
    <span class="keyword">public</span> <span class="title">LRUCache</span>(<span class="keyword">int</span> capacity) {
        <span class="keyword">this</span>.capacity=capacity;
        len=<span class="number">0</span>;
    }
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span>(<span class="keyword">int</span> key) {
        <span class="keyword">if</span>(map.containsKey(key)){
            Node last=map.<span class="keyword">get</span>(key);
            removeNode(last);
            setHead(last);
            <span class="keyword">return</span> last.<span class="keyword">value</span>;
        }<span class="keyword">else</span>{
            <span class="keyword">return</span> -<span class="number">1</span>;
        }
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span>(Node node){
        Node cur=node;
        Node pre=cur.prev;
        Node post = cur.next;
        <span class="keyword">if</span>(pre !=<span class="keyword">null</span>){
            pre.next=post;
        }<span class="keyword">else</span>{
            <span class="comment">//前驱节点为空</span>
            head =post;
        }
        <span class="keyword">if</span>(post !=<span class="keyword">null</span>){
            post.prev=pre;
        }<span class="keyword">else</span>{
            <span class="comment">//后驱节点为空</span>
            end =pre;
        }
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHead</span>(Node node){
        node.next=head;
        node.prev=<span class="keyword">null</span>;
        <span class="keyword">if</span>(head!=<span class="keyword">null</span>){
            head.prev=node;
        }
        head=node;
        <span class="keyword">if</span>(end==<span class="keyword">null</span>){
            end=node;
        }
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> <span class="keyword">value</span>) {
        <span class="keyword">if</span>(map.containsKey(key)){
            Node oldNode=map.<span class="keyword">get</span>(key);
            oldNode.<span class="keyword">value</span>=<span class="keyword">value</span>;
            removeNode(oldNode);
            setHead(oldNode);
        }<span class="keyword">else</span>{
            Node newNode =<span class="keyword">new</span> Node(key, <span class="keyword">value</span>);
            <span class="keyword">if</span>(len&lt;capacity){
                <span class="comment">//把LRU里面的新节点放在头部</span>
                setHead(newNode);
                map.put(key, newNode);
                len++;
            }<span class="keyword">else</span>{
                <span class="comment">//超出容量，则移除尾节点</span>
                map.remove(end.key);
                end=end.prev;
                <span class="keyword">if</span>(end!=<span class="keyword">null</span>){
                    end.next=<span class="keyword">null</span>;
                }
                setHead(newNode);
                map.put(key, newNode);
            }
        }
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基础的数据结构总结]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/basicadt/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/数据结构与算法/basicadt/</id>
    <published>2014-05-22T06:22:03.000Z</published>
    <updated>2014-05-22T07:19:05.000Z</updated>
    <content type="html"><![CDATA[<h4 id="数组">数组</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> test {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        <span class="keyword">int</span> <span class="keyword">value</span>[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {  
             <span class="keyword">value</span>[i] = i;  
        }  

       traverse(<span class="keyword">value</span>);  
       insert(<span class="keyword">value</span>,<span class="number">666</span>,<span class="number">5</span>);  
       delete(<span class="keyword">value</span>,<span class="number">3</span>);
       traverse(<span class="keyword">value</span>);  
   }
    <span class="comment">//插入</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] <span class="title">insert</span>(<span class="keyword">int</span>[]old,<span class="keyword">int</span> <span class="keyword">value</span>,<span class="keyword">int</span> index){
        <span class="keyword">for</span>(<span class="keyword">int</span> k=old.length-<span class="number">1</span>;k&gt;index;k--){
            old[k]=old[k-<span class="number">1</span>];
        }
        old[index]=<span class="keyword">value</span>;
        <span class="keyword">return</span> old;
    }
    <span class="comment">//遍历</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverse</span>(<span class="keyword">int</span> data[]){
        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;data.length;j++)
            System.<span class="keyword">out</span>.print(data[j]+<span class="string">" "</span>);
        System.<span class="keyword">out</span>.println(<span class="string">" "</span>);
    }
    <span class="comment">//删除</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] <span class="title">delete</span>(<span class="keyword">int</span>[]old,<span class="keyword">int</span> index){
        <span class="keyword">for</span>(<span class="keyword">int</span> h=index;h&lt;old.length -<span class="number">1</span>;h++){
            old[h] = old[h+<span class="number">1</span>];
        }
        old[old.length-<span class="number">1</span>]=<span class="number">0</span>;
        <span class="keyword">return</span> old;
    }
}
</code></pre><h4 id="String">String</h4>
<pre><code>    这些方法应该熟记
    toCharArray() //get char <span class="keyword">array</span> <span class="keyword">of</span> a <span class="typename">String</span>
    Arrays.sort()  //sort an <span class="keyword">array</span>
    Arrays.toString(char[] a) //convert <span class="keyword">to</span> <span class="typename">string</span>
    charAt(int x) //get a char at the specific index
    length() //<span class="typename">string</span> length
    length //<span class="keyword">array</span> size 
    substring(int beginIndex) 
    substring(int beginIndex, int endIndex)
    <span class="typename">Integer</span>.valueOf()//<span class="typename">string</span> <span class="keyword">to</span> <span class="typename">integer</span>
    <span class="typename">String</span>.valueOf()/<span class="typename">integer</span> <span class="keyword">to</span> <span class="typename">string</span>
</code></pre><h4 id="链表">链表</h4>
<pre><code><span class="keyword">class</span> Node {
    <span class="built_in">int</span> val;
    Node <span class="keyword">next</span>;

    Node(<span class="built_in">int</span> x) {
        val = x;
        <span class="keyword">next</span> = <span class="literal">null</span>;
    }
}
</code></pre><h4 id="栈">栈</h4>
<pre><code>class Stack{
    Node top; 

    <span class="comment">//取栈顶</span>
    <span class="keyword">public</span> Node <span class="title">peek</span>(){
        <span class="keyword">if</span>(top != <span class="keyword">null</span>){
            <span class="keyword">return</span> top;
        }

        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    <span class="comment">//出栈</span>
    <span class="keyword">public</span> Node <span class="title">pop</span>(){
        <span class="keyword">if</span>(top == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }<span class="keyword">else</span>{
            Node temp = <span class="keyword">new</span> Node(top.val);
            top = top.next;
            <span class="keyword">return</span> temp;    
        }
    }

    <span class="comment">//入栈</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(Node n){
        <span class="keyword">if</span>(n != <span class="keyword">null</span>){
            n.next = top;
            top = n;
        }
    }
}
</code></pre><h4 id="队列">队列</h4>
<pre><code>class Queue{
    Node first, last;

    <span class="comment">//入队</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span>(Node n){
        <span class="keyword">if</span>(first == <span class="keyword">null</span>){
            first = n;
            last = first;
        }<span class="keyword">else</span>{
            last.next = n;
            last = n;
        }
    }

    <span class="comment">//出队</span>
    <span class="keyword">public</span> Node <span class="title">dequeue</span>(){
        <span class="keyword">if</span>(first == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }<span class="keyword">else</span>{
            Node temp = <span class="keyword">new</span> Node(first.val);
            first = first.next;
            <span class="keyword">return</span> temp;
        }    
    }
}
</code></pre><h4 id="树（二叉树）">树（二叉树）</h4>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">T</span>&gt; {</span>
    <span class="javadoc">/**
     * 结点类。  
     */</span>
    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> {</span>
        int value; <span class="comment">// 该节点存储的值。</span>
        Node leftChild; <span class="comment">// 指向左子节点的引用。</span>
        Node rightChild; <span class="comment">// 指向右子节点的引用。</span>
        Node(int value) {
            <span class="keyword">this</span>.value = value;
            leftChild = <span class="keyword">null</span>;
            rightChild = <span class="keyword">null</span>;
        }
    }
    <span class="keyword">private</span> Node root; <span class="comment">// 根节点。</span>
    <span class="javadoc">/**
     * 无参构造方法。
     */</span>
    BinaryTree() {
        root = <span class="keyword">null</span>;
    }
    <span class="javadoc">/**
     * 使用一个数组来构造二叉树。
     */</span>
    BinaryTree(int[] arr) {
        <span class="keyword">for</span> (int i : arr) {
            insert(i);
        }
    }
    <span class="keyword">private</span> void insert(int value) {
        root = insert(root, value);
    }
    <span class="javadoc">/**
     * 将数值插入到二叉树中，比当前结点小或等于当前结点的插在当前结点的左侧，
     * 比当前结点大的数插在当前结点的右侧，每次从根结点开始递归比较。。
     */</span>
    <span class="keyword">private</span> Node insert(Node node, int value) {
        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {
            node = <span class="keyword">new</span> Node(value);
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> (value &lt;= node.value) {
                node.leftChild = insert(node.leftChild, value);
            } <span class="keyword">else</span> {
                node.rightChild = insert(node.rightChild, value);
            }
        }
        <span class="keyword">return</span> node;
    }
    <span class="javadoc">/**
     * 访问节点：将节点的值取出来并打印。
     */</span>
    <span class="keyword">private</span> void visit(Node node) {
        <span class="javadoc">/**
         * 当节点为空时返回。
         */</span>
        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {
            <span class="keyword">return</span>;
        }
        int value = node.value;
        System.out.println(value);
    }
    <span class="javadoc">/**
     * 从指定节点作为根节点开始递归对树进行先序遍历。
     */</span>
    <span class="keyword">private</span> void preOrderTravels(Node node) {
        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {
            <span class="keyword">return</span>;
        } <span class="keyword">else</span> {   
            <span class="comment">//这里调整visit顺序 即可实现先序后序中序            </span>
            visit(node);                       
            preOrderTravels(node.leftChild);
            preOrderTravels(node.rightChild);
        }
    }
    <span class="javadoc">/**
     * 从根节点开始对整个树进行先序遍历。
     * 这里是递归做法，非递归做法，需要用到栈
     */</span>
    public void preOrderTravels() {
        preOrderTravels(root);
    }
}
</code></pre><h4 id="图">图</h4>
<pre><code>class GraphNode{ 
    <span class="keyword">int</span> val;
    GraphNode next;
    GraphNode[] neighbors;
    boolean visited;

    GraphNode(<span class="keyword">int</span> x) {
        val = x;
    }

    GraphNode(<span class="keyword">int</span> x, GraphNode[] n){
        val = x;
        neighbors = n;
    }

    <span class="keyword">public</span> String <span class="title">toString</span>(){
        <span class="keyword">return</span> <span class="string">"value: "</span>+ <span class="keyword">this</span>.val; 
    }
}

<span class="comment">//使用队列辅助广度搜索</span>
class Queue{
    GraphNode first, last;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span>(GraphNode n){
        <span class="keyword">if</span>(first == <span class="keyword">null</span>){
            first = n;
            last = first;
        }<span class="keyword">else</span>{
            last.next = n;
            last = n;
        }
    }

<span class="keyword">public</span> GraphNode <span class="title">dequeue</span>(){
        <span class="keyword">if</span>(first == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }<span class="keyword">else</span>{
            GraphNode temp = <span class="keyword">new</span> GraphNode(first.val, first.neighbors);
            first = first.next;
            <span class="keyword">return</span> temp;
        }    
    }
}
<span class="keyword">public</span> <span class="keyword">class</span> test {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]){
        GraphNode n1 = <span class="keyword">new</span> GraphNode(<span class="number">1</span>); 
        GraphNode n2 = <span class="keyword">new</span> GraphNode(<span class="number">2</span>); 
        GraphNode n3 = <span class="keyword">new</span> GraphNode(<span class="number">3</span>); 
        GraphNode n4 = <span class="keyword">new</span> GraphNode(<span class="number">4</span>); 
        GraphNode n5 = <span class="keyword">new</span> GraphNode(<span class="number">5</span>); 

        n1.neighbors = <span class="keyword">new</span> GraphNode[]{n2,n3,n5};
        n2.neighbors = <span class="keyword">new</span> GraphNode[]{n1,n4};
        n3.neighbors = <span class="keyword">new</span> GraphNode[]{n1,n4,n5};
        n4.neighbors = <span class="keyword">new</span> GraphNode[]{n2,n3,n5};
        n5.neighbors = <span class="keyword">new</span> GraphNode[]{n1,n3,n4};

    <span class="comment">//  breathFirstSearch(n1, 4);</span>
        deepFirstSearch(n1, <span class="number">4</span>);
    }
    <span class="comment">//深度搜索，递归，非递归得使用到栈</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deepFirstSearch</span>(GraphNode root,<span class="keyword">int</span> x){
    <span class="comment">//    if(root.val==x)</span>
    <span class="comment">//        System.out.println("find in root");</span>
        root.visited=<span class="keyword">true</span>;
        <span class="keyword">for</span>(GraphNode n :root.neighbors ){
            <span class="keyword">if</span>(!n.visited){
                System.<span class="keyword">out</span>.print(n+<span class="string">" "</span>);
                n.visited =<span class="keyword">true</span>;
                <span class="keyword">if</span>(n.val == x){
                    System.<span class="keyword">out</span>.print(<span class="string">"Find "</span>+n);
                }
                deepFirstSearch(n, x);
            }
        }
    }
    <span class="comment">//广度搜索</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">breathFirstSearch</span>(GraphNode root,<span class="keyword">int</span> x){
        <span class="comment">//如果搜索的值正好是根节点的值</span>
        <span class="keyword">if</span>(root.val == x)
            System.<span class="keyword">out</span>.println(<span class="string">"find in root"</span>);
        Queue queue =<span class="keyword">new</span> Queue();
        root.visited=<span class="keyword">true</span>;
        queue.enqueue(root);
        <span class="keyword">while</span>(queue.first !=<span class="keyword">null</span>){
            <span class="comment">//将节点出队</span>
            GraphNode c =queue.dequeue();
            <span class="comment">//遍历邻居节点</span>
            <span class="keyword">for</span>(GraphNode n:c.neighbors){
                <span class="comment">//访问没访问过的节点</span>
                <span class="keyword">if</span>(!n.visited){
                    System.<span class="keyword">out</span>.print(n+ <span class="string">" "</span>);
                    n.visited =<span class="keyword">true</span>;
                    <span class="keyword">if</span>(n.val == x){
                        System.<span class="keyword">out</span>.print(<span class="string">"Find "</span>+n);
                    }
                    <span class="comment">//将访问过的节点从新入队</span>
                    queue.enqueue(n);
                }
            }
        }
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Insertion Sort List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/insertsortlist/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/数据结构与算法/LeetCode/insertsortlist/</id>
    <published>2014-05-22T05:48:59.000Z</published>
    <updated>2014-05-22T06:20:21.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Sort <span class="operator">a</span> linked list <span class="keyword">using</span> insertion <span class="built_in">sort</span>.
</code></pre><h6 id="插入排序大致思路">插入排序大致思路</h6>
<ul>
<li>设数组为a[0…n-1]。</li>
<li>初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1</li>
<li>将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。</li>
<li>i++并重复第二步直到i==n-1。排序完成。 </li>
</ul>
<h4 id="解法">解法</h4>
<pre><code>该题是在链表中使用插入排序，其思路都是一样的
<span class="keyword">class</span> ListNode {
     int <span class="keyword">val</span>;
     ListNode next;
     ListNode(int x) {
         <span class="keyword">val</span> = x;
         next = <span class="keyword">null</span>;
    }
 }
<span class="keyword">public</span> <span class="keyword">class</span> insertSortList {
    <span class="keyword">public</span> ListNode insertionSortList(ListNode head){
        <span class="keyword">if</span>(head ==<span class="keyword">null</span> ||head.next==<span class="keyword">null</span>)
            <span class="keyword">return</span> head;
        ListNode cur =head.next;
        <span class="keyword">while</span>(cur !=<span class="keyword">null</span>){
            ListNode tmp=head;
            <span class="comment">//用tmp节点代表有序区的最后一个节点</span>
            <span class="keyword">while</span>(tmp.<span class="keyword">val</span>&lt;cur.<span class="keyword">val</span> &amp;&amp; tmp!=cur)
                tmp=tmp.next;
            <span class="keyword">if</span>(tmp !=cur){
                <span class="keyword">while</span>(tmp !=cur){
                    int tmpvalue=tmp.<span class="keyword">val</span>;
                    tmp.<span class="keyword">val</span>=cur.<span class="keyword">val</span>;
                    cur.<span class="keyword">val</span>=tmpvalue;
                    tmp=tmp.next;
                }
            }
            cur =cur.next;
        }
        <span class="keyword">return</span> head;
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Sort List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/sortlist/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/数据结构与算法/LeetCode/sortlist/</id>
    <published>2014-05-22T05:48:29.000Z</published>
    <updated>2014-05-22T06:16:19.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Sort <span class="operator">a</span> linked list <span class="operator">in</span> O(n <span class="built_in">log</span> n) <span class="built_in">time</span> <span class="keyword">using</span> <span class="built_in">constant</span> <span class="constant">space</span> complexity.
</code></pre><p>题目要求时间复杂度是O(n log n) ,想到了快排和归并，但是链表对于快排来说，交换次数太多，可以采用归并排序，但需要额外空间O(n)</p>
<p>归并排序：其的基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？</p>
<p>可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。</p>
<p>解法参考 <a href="http://www.programcreek.com/2012/11/leetcode-solution-merge-sort-linkedlist-in-java/" target="_blank">http://www.programcreek.com/2012/11/leetcode-solution-merge-sort-linkedlist-in-java/</a></p>
<h4 id="解法">解法</h4>
<pre><code>class ListNode{
    <span class="keyword">int</span> val;
    ListNode next;
    ListNode(<span class="keyword">int</span> x){
        val=x;
        next=<span class="keyword">null</span>;
    }
}
<span class="keyword">public</span> <span class="keyword">class</span> SortLinkedList {
    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeSortList</span>(ListNode head){
            <span class="keyword">if</span>(head ==<span class="keyword">null</span> ||head.next ==<span class="keyword">null</span>)
                <span class="keyword">return</span> head;
            <span class="comment">//计算链表节点数</span>
            <span class="keyword">int</span> count=<span class="number">0</span>;
            ListNode p=head;
            <span class="keyword">while</span>(p!=<span class="keyword">null</span>){
                count++;
                p=p.next;
            }
            <span class="comment">//将链表一分为2</span>
            <span class="keyword">int</span> middle =count/<span class="number">2</span>;
            ListNode l=head,r=<span class="keyword">null</span>;
            ListNode p2=head;
            <span class="keyword">int</span> countHalf =<span class="number">0</span>;
            <span class="keyword">while</span>(p2 !=<span class="keyword">null</span>){
                countHalf++;
                ListNode next=p2.next;
                <span class="keyword">if</span>(countHalf ==middle){
                    p2.next=<span class="keyword">null</span>;<span class="comment">//左区尾节点为空</span>
                    r = next;
                }
                p2=next;
            }
            <span class="comment">//part l and part r ,循环排序</span>
            ListNode h1 = mergeSortList(l);
            ListNode h2 = mergeSortList(r);
            <span class="comment">//归并</span>
            ListNode merged = merge(h1,h2);
            <span class="keyword">return</span> merged;
    }

    <span class="keyword">public</span>  <span class="keyword">static</span> ListNode <span class="title">merge</span>(ListNode h1, ListNode h2) {
        ListNode p1=h1;
        ListNode p2=h2;
        ListNode fakeHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);
        ListNode pNew =fakeHead;
        <span class="keyword">while</span>(p1!=<span class="keyword">null</span>||p2!=<span class="keyword">null</span>){
            <span class="keyword">if</span>(p1 ==<span class="keyword">null</span>){
                pNew.next =<span class="keyword">new</span> ListNode(p2.val);
                p2=p2.next;
                pNew = pNew.next;
            }<span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="keyword">null</span>) {
                pNew.next = <span class="keyword">new</span> ListNode(p1.val);
                p1 = p1.next;
                pNew = pNew.next;
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (p1.val &lt; p2.val) {
                    pNew.next = <span class="keyword">new</span> ListNode(p1.val);
                    p1 = p1.next;
                    pNew = pNew.next;    
                } <span class="keyword">else</span> <span class="keyword">if</span> (p1.val == p2.val) {
                    pNew.next = <span class="keyword">new</span> ListNode(p1.val);
                    pNew.next.next = <span class="keyword">new</span> ListNode(p1.val);
                    pNew = pNew.next.next;
                    p1 = p1.next;
                    p2 = p2.next;

                } <span class="keyword">else</span> {
                    pNew.next = <span class="keyword">new</span> ListNode(p2.val);
                    p2 = p2.next;
                    pNew = pNew.next;
                }
            }
        }

        <span class="comment">// printList(fakeHead.next);</span>
        <span class="keyword">return</span> fakeHead.next;
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        ListNode n1 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);
        ListNode n2 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);
        ListNode n3 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);

        ListNode n4 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);
        ListNode n5 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);
        ListNode n6 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);

        n1.next = n2;
        n2.next = n3;
        n3.next = n4;
        n4.next = n5;
        n5.next = n6;

        n1 = mergeSortList(n1);

        printList(n1);
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span>(ListNode x) {
        <span class="keyword">if</span>(x != <span class="keyword">null</span>){
            System.<span class="keyword">out</span>.print(x.val + <span class="string">" "</span>);
            <span class="keyword">while</span> (x.next != <span class="keyword">null</span>) {
                System.<span class="keyword">out</span>.print(x.next.val + <span class="string">" "</span>);
                x = x.next;
            }
            System.<span class="keyword">out</span>.println();
        }

    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Max Points on a Line]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/maxpoints/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/数据结构与算法/LeetCode/maxpoints/</id>
    <published>2014-05-21T12:56:43.000Z</published>
    <updated>2014-05-22T05:49:56.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Max Points <span class="function_start"><span class="keyword">on</span></span> a Line Total 

Given n points <span class="function_start"><span class="keyword">on</span></span> a <span class="number">2</span>D plane, find <span class="keyword">the</span> maximum <span class="type">number</span> <span class="keyword">of</span> points <span class="keyword">that</span> lie <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> same straight line.
</code></pre><p>计算同一直线上最多的点数，思路：枚举+计算斜率，map存(斜率，点数)</p>
<h4 id="解法">解法</h4>
<pre><code>import java.util.HashMap;
import java.util.Map;

class Point {
     <span class="keyword">int</span> x;
     <span class="keyword">int</span> y;
     Point() { x = <span class="number">0</span>; y = <span class="number">0</span>; }
     Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b) { x = a; y = b; }
 }
<span class="comment">//枚举，计算斜率，注意重复的点</span>
<span class="keyword">public</span> <span class="keyword">class</span> test {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoints</span>(Point[] points){
        <span class="keyword">int</span> maxPoints = <span class="number">0</span>;
        <span class="keyword">int</span> curPoints = <span class="number">0</span>;
        <span class="keyword">int</span> samePoint = <span class="number">0</span>;
        <span class="keyword">double</span> slope = <span class="number">0</span>;
        <span class="comment">//map&lt;slope,curPoints&gt;</span>
        Map&lt;Double ,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Double,Integer&gt;();
        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;points.length;++i){
            curPoints = <span class="number">1</span>;
            samePoint = <span class="number">0</span>;
            map.clear();
            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;points.length;++j){
                <span class="comment">//same point</span>
                <span class="keyword">if</span>(points[j].x==points[i].x&amp;&amp;points[j].y==points[i].y){
                    ++samePoint;
                }<span class="keyword">else</span>{
                    <span class="comment">//如果两点X坐标相同，斜率无穷大</span>
                    <span class="keyword">if</span>(points[j].x != points[i].x){
                        <span class="comment">//注意0除以负数，得-0.0  计算器补码运算，所以为保持斜率一致，</span>
                        <span class="comment">//后面加上0.0，防止出现-0.0</span>
                        slope = <span class="number">1.0</span>*(points[j].y-points[i].y)/(points[j].x-points[i].x)+<span class="number">0.0</span>;
                    }<span class="keyword">else</span>{
                        slope = Double.MAX_VALUE;
                    }
                    <span class="keyword">if</span>(map.containsKey(slope)){
                        map.put(slope, map.<span class="keyword">get</span>(slope)+<span class="number">1</span>);
                    }<span class="keyword">else</span> {
                        map.put(slope, <span class="number">2</span>);
                    }
                    <span class="comment">//暂时计算当前在一条线的最多的点的个数</span>
                    <span class="keyword">if</span>(map.<span class="keyword">get</span>(slope)&gt;curPoints){
                        curPoints =map.<span class="keyword">get</span>(slope);
                    }
                }
            }
            curPoints +=samePoint;
            <span class="keyword">if</span>(curPoints &gt;maxPoints){
                maxPoints = curPoints;
            }
        }
        <span class="keyword">return</span> maxPoints;
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        Point[] points =<span class="keyword">new</span> Point[]{<span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>),<span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">3</span>),<span class="keyword">new</span> Point(-<span class="number">5</span>,<span class="number">3</span>)};
        System.<span class="keyword">out</span>.println(maxPoints(points));
    <span class="comment">//    System.out.println(1.0*(3-3)/(-3-3)+0.0);</span>
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Evaluate Reverse Polish Notation]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/polishnotation/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/数据结构与算法/LeetCode/polishnotation/</id>
    <published>2014-05-21T12:55:41.000Z</published>
    <updated>2014-05-22T05:49:58.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Evaluate the value <span class="keyword">of</span> an arithmetic expression <span class="keyword">in</span> Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer <span class="keyword">or</span> another expression.

Some <span class="attribute">examples</span>:
  [<span class="string">"2"</span>, <span class="string">"1"</span>, <span class="string">"+"</span>, <span class="string">"3"</span>, <span class="string">"*"</span>]<span class="function"> -&gt;</span> <span class="function"><span class="params">((<span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span>)</span> -&gt;</span> <span class="number">9</span>
  [<span class="string">"4"</span>, <span class="string">"13"</span>, <span class="string">"5"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>]<span class="function"> -&gt;</span> <span class="function"><span class="params">(<span class="number">4</span> + (<span class="number">13</span> / <span class="number">5</span>))</span> -&gt;</span> <span class="number">6</span>
</code></pre><p>波兰表达式，用栈就OK了</p>
<h4 id="解法">解法</h4>
<pre><code>import java.util.Stack;
<span class="comment">//波兰表达式 用栈不解释</span>
<span class="keyword">public</span> <span class="keyword">class</span> test {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]){
        String[] tokens =<span class="keyword">new</span> String[]{<span class="string">"4"</span>, <span class="string">"13"</span>, <span class="string">"5"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>};
        System.<span class="keyword">out</span>.println(evalRPN(tokens));
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span>(String[] tokens){
        String operators =<span class="string">"+-*/"</span>;
        Stack&lt;String&gt; s = <span class="keyword">new</span> Stack&lt;String&gt;();
        <span class="keyword">for</span>(String str : tokens){
            <span class="keyword">if</span>(operators.contains(str)){
                <span class="keyword">int</span> num2 = Integer.valueOf(s.pop());
                <span class="keyword">int</span> num1 = Integer.valueOf(s.pop());
                <span class="keyword">int</span> index = operators.indexOf(str);
                <span class="keyword">switch</span>(index){
                <span class="keyword">case</span> <span class="number">0</span>:
                    s.push(String.valueOf(num1+num2));
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> <span class="number">1</span>:
                    s.push(String.valueOf(num1-num2));
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> <span class="number">2</span>:
                    s.push(String.valueOf(num1*num2));
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> <span class="number">3</span>:
                    s.push(String.valueOf(num1/num2));
                    <span class="keyword">break</span>;
                }
            }<span class="keyword">else</span>{
                s.push(str);
            }
        }
        <span class="keyword">return</span> Integer.valueOf(s.pop());
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Reverse Words in a String]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/reversewords/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/数据结构与算法/LeetCode/reversewords/</id>
    <published>2014-05-21T10:01:31.000Z</published>
    <updated>2014-05-22T05:50:00.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">an</span> input <span class="keyword">string</span>, reverse <span class="operator">the</span> <span class="keyword">string</span> <span class="built_in">word</span> <span class="keyword">by</span> <span class="built_in">word</span>.
For example,
Given s = <span class="string">"the sky is blue"</span>,
<span class="constant">return</span> <span class="string">"blue is sky the"</span>.
</code></pre><p>一道反转字符串的题，可以用栈实现，也可以利用字符串的split方法进行分割字符串后处理</p>
<p>输入情况较多 ： 易遗漏” “ </p>
<h4 id="解法">解法</h4>
<pre><code>    <span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseWords</span>(String s){
        <span class="comment">//判断字符串是否为空</span>
        <span class="keyword">if</span>(s == <span class="keyword">null</span> ||s.length()==<span class="number">0</span>){
            <span class="keyword">return</span> <span class="string">""</span>;
        }
        <span class="comment">//以空格分割单词</span>
        String[] list=s.split(<span class="string">" "</span>);
        StringBuffer sb =<span class="keyword">new</span> StringBuffer();
        <span class="keyword">for</span>(<span class="keyword">int</span> i=list.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i){
            <span class="keyword">if</span>(!list[i].equals(<span class="string">""</span>)){
                sb.append(list[i]).append(<span class="string">" "</span>);
            }
        }
        <span class="comment">//考虑到" "的输入</span>
        <span class="keyword">return</span> sb.length() == <span class="number">0</span>? <span class="string">""</span>:sb.substring(<span class="number">0</span>, sb.length()-<span class="number">1</span>);
    }
    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        String s=<span class="string">"the sky   is blue"</span>;
        String d=reverseWords(s);
    }
}
</code></pre><p>注：split(“ “)单词之间有多个空格时，则认为空格之间为空,即list的元素为空””</p>
<p>str＝str.substring(int beginIndex);截取掉str从首字母起长度为beginIndex的字符串，将剩余字符串赋值给str；</p>
<p>str＝str.substring(int beginIndex，int endIndex);截取str中从beginIndex开始至endIndex结束时的字符串，并将其赋值给str;</p>
]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java的IO总结]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/Java/java_io/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/Java/java_io/</id>
    <published>2014-05-21T05:20:59.000Z</published>
    <updated>2014-05-21T06:12:36.000Z</updated>
    <content type="html"><![CDATA[<h4 id="Java流有关的类或借口">Java流有关的类或借口</h4>
<p><img src="/img/Java/io/1.png" alt=" "></p>
<h4 id="Java流类图结构">Java流类图结构</h4>
<p><img src="/img/Java/io/2.jpg" alt=" "></p>
<h4 id="流的概念和作用">流的概念和作用</h4>
<p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p>
<h5 id="IO流的分类">IO流的分类</h5>
<ul>
<li>根据处理数据类型的不同分为：字符流和字节流</li>
<li>根据数据流向不同分为：输入流和输出流</li>
</ul>
<h6 id="字符流和字节流">字符流和字节流</h6>
<p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。<br>字节流和字符流的区别：</p>
<ul>
<li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>
<li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li>
<li>缓冲区的使用：字节流在操作的时候本身是不会用到缓冲区的，是文件本身的直接操作的，但是字符流在操作的时候下后是会用到缓冲区的，是通过缓冲区来操作文件的。</li>
</ul>
<p>使用字节流好还是字符流好呢？</p>
<p>答案是字节流。首先因为硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符只是在内存中才会形成的，所以在开发中，字节流使用广泛。</p>
<h6 id="输入流和输出流">输入流和输出流</h6>
<p>对输入流只能进行读操作，对输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。 </p>
<h4 id="案例（写了很少，慢慢补充）">案例（写了很少，慢慢补充）</h4>
<h6 id="File类的两个常量">File类的两个常量</h6>
<pre><code><span class="keyword">File</span>.separator 代表 \
<span class="keyword">File</span>.pathSeparator 代表 ，
多使用它们俩，方便跨平台写路径名
</code></pre><h6 id="创建一个新文件">创建一个新文件</h6>
<pre><code><span class="keyword">package</span> com.liu.io;

<span class="keyword">import</span> java.io.File;
<span class="comment">//创建一个新文件</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> {</span>
<span class="comment">/*    public static void main(String[] args){
        File f =new File("D:\\hello.txt");
        try{
            f.createNewFile();
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
*/</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;
        File f =<span class="keyword">new</span> File(fileName);
        <span class="keyword">try</span>{
            f.createNewFile();
        }<span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h6 id="删除一个文件">删除一个文件</h6>
<pre><code>package com.liu.io;

import java.io.File;

<span class="comment">//删除一个文件</span>
<span class="keyword">public</span> <span class="keyword">class</span> test03 {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;
        File f=<span class="keyword">new</span> File(fileName);
        <span class="keyword">if</span>(f.exists()){
            f.delete();
        }<span class="keyword">else</span>{
            System.<span class="keyword">out</span>.println(<span class="string">"文件不存在"</span>);
        }
    }

}
</code></pre><h6 id="创建一个文件夹及遍历目录">创建一个文件夹及遍历目录</h6>
<pre><code>package com.liu.io;

import java.io.File;


<span class="keyword">public</span> <span class="keyword">class</span> test04 {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
    <span class="comment">//创建一个文件夹         </span>
    /*        String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello"</span>;
            File f=<span class="keyword">new</span> File(fileName);
            f.mkdir();
    */
    <span class="comment">//列出指定目录的全部文件（包括隐藏文件）</span>
    /*    String fileName=<span class="string">"D:"</span>+File.separator;
        File f=<span class="keyword">new</span> File(fileName);
        String[] str=f.list();
        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; str.length; i++) {
            System.out.println(str[i]);
        }
    */
    <span class="comment">//列出指定目录的全部文件（包括隐藏文件） 完整路径    </span>
    /*     String fileName=<span class="string">"D:"</span>+File.separator;
            File f=<span class="keyword">new</span> File(fileName);
            File[] str=f.listFiles();
            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; str.length; i++) {
                System.out.println(str[i]);
            }
    */    
    <span class="comment">//    判断一个指定的路径是否为目录</span>
    /*    String fileName=<span class="string">"D:"</span>+File.separator;
        File f=<span class="keyword">new</span> File(fileName);
        <span class="keyword">if</span>(f.isDirectory()){
            System.out.println(<span class="string">"YES"</span>);
        }<span class="keyword">else</span>{
            System.out.println(<span class="string">"NO"</span>);
        }
    */
    <span class="comment">//搜索指定目录的全部内容</span>
        String fileName=<span class="string">"D:"</span>+File.separator;
        File f=<span class="keyword">new</span> File(fileName);
        print(f);
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> print(File f){
        <span class="keyword">if</span>(f!=<span class="keyword">null</span>){
            <span class="keyword">if</span>(f.isDirectory()){
                File[] fileArray=f.listFiles();
                <span class="keyword">if</span>(fileArray!=<span class="keyword">null</span>){
                    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; fileArray.length; i++) {
                        <span class="comment">//递归调用</span>
                        print(fileArray[i]);
                    }
                }
            }
            <span class="keyword">else</span>{
                System.out.println(f);
            }
        }
    }
}
</code></pre><h6 id="使用RandomAccessFile写入文件">使用RandomAccessFile写入文件</h6>
<pre><code><span class="keyword">package</span> com.liu.io;

<span class="keyword">import</span> java.io.*;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test05</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> IOException {
        <span class="comment">//使用RandomAccessFile写入文件</span>
        String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;
        File f=<span class="keyword">new</span> File(fileName);
        RandomAccessFile demo = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
            demo = <span class="keyword">new</span> RandomAccessFile(f,<span class="string">"rw"</span>);
        } <span class="keyword">catch</span> (FileNotFoundException e) {
            e.printStackTrace();
        }
        demo.writeBytes(<span class="string">"asdsad"</span>);
        <span class="comment">//demo.writeInt(12);</span>
        <span class="comment">//demo.writeBoolean(true);</span>
        <span class="comment">//demo.writeChar('A');</span>
        <span class="comment">//demo.writeFloat(1.21f);</span>
        <span class="comment">//demo.writeDouble(12.123);</span>
        <span class="comment">//demo.close();</span>

    }

}
</code></pre><h6 id="字节流">字节流</h6>
<pre><code>package com.liu.io;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

<span class="comment">//字节流</span>
<span class="keyword">public</span> <span class="keyword">class</span> test06 {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)throws IOException {
           String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;
           File f=<span class="keyword">new</span> File(fileName);
           <span class="comment">// 向文件中写入字符串</span>
      /*    OutputStream out =<span class="keyword">new</span> FileOutputStream(f);
           String str=<span class="string">"你好"</span>;
           byte[] b=str.getBytes();
           out.write(b);
           out.close();
       */    

           <span class="comment">//向文件中追加新内容</span>
       /*   OutputStream out =<span class="keyword">new</span> FileOutputStream(f,<span class="keyword">true</span>);
           String str=<span class="string">"haha"</span>;
           byte[]b =str.getBytes();
           <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;b.length;i++){
               out.write(b[i]);
           }
           out.close();
         */

           <span class="comment">//读文件内容</span>
     /*      InputStream <span class="keyword">in</span> =<span class="keyword">new</span> FileInputStream(f);
           <span class="comment">//byte[] b=new byte[1024];</span>
           byte[] b=<span class="keyword">new</span> byte[(int)f.length()];
           <span class="comment">//如果直接用 in.read(b) 会读取大量空格</span>
            int len=<span class="keyword">in</span>.read(b);
            <span class="keyword">in</span>.close();
            System.out.println(<span class="string">"读入长度为："</span>+len);
            System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,len));
       */

           <span class="comment">//一个一个字节读</span>
    /*       InputStream <span class="keyword">in</span>=<span class="keyword">new</span> FileInputStream(f);
            byte[] b=<span class="keyword">new</span> byte[(int)f.length()];
            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; b.length; i++) {
                b[i]=(byte)<span class="keyword">in</span>.read();
            }
            <span class="keyword">in</span>.close();
            System.out.println(<span class="keyword">new</span> String(b));
    */

           <span class="comment">//判断是否独到文件的末尾</span>
           InputStream <span class="keyword">in</span>=<span class="keyword">new</span> FileInputStream(f);
            byte[] b=<span class="keyword">new</span> byte[<span class="number">1024</span>];
            int count =<span class="number">0</span>;
            int temp=<span class="number">0</span>;
            <span class="keyword">while</span>((temp=<span class="keyword">in</span>.read())!=(-<span class="number">1</span>)){
                b[count++]=(byte)temp;
            }
            <span class="keyword">in</span>.close();
            System.out.println(<span class="keyword">new</span> String(b));
    }
}
</code></pre><h6 id="字符流">字符流</h6>
<pre><code><span class="keyword">package</span> com.liu.io;
<span class="comment">//字符流</span>
<span class="keyword">import</span> java.io.File;
<span class="keyword">import</span> java.io.FileReader;
<span class="keyword">import</span> java.io.FileWriter;
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.io.Reader;
<span class="keyword">import</span> java.io.Writer;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test07</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> IOException {
        String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;
        File f=<span class="keyword">new</span> File(fileName);
        <span class="comment">//写入数据</span>
  <span class="comment">/*      //追加内容
        Writer out =new FileWriter(f,true);
       // Writer out =new FileWriter(f);
        String str="hello";
        out.write(str);
        out.close();
    */</span>
        <span class="comment">//读内容</span>
        <span class="keyword">char</span>[] ch =<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];
        Reader read=<span class="keyword">new</span> FileReader(f);
        <span class="keyword">int</span> temp=<span class="number">0</span>;
        <span class="keyword">int</span> count=<span class="number">0</span>;
        <span class="keyword">while</span>((temp=read.read())!=(-<span class="number">1</span>)){
            ch[count++]=(<span class="keyword">char</span>)temp;
        }
        read.close();
        System.out.println(<span class="string">"内容为"</span>+<span class="keyword">new</span> String(ch,<span class="number">0</span>,count));
    }
}
</code></pre><p>下面例子总结摘自网上</p>
<h6 id="OutputStreramWriter_和InputStreamReader类">OutputStreramWriter 和InputStreamReader类</h6>
<pre><code>OutputStreramWriter将输出的字符流转化为字节流
InputStreamReader将输入的字节流转换为字符流
但是不管如何操作，最后都是以字节的形式保存在文件中的。
<span class="javadoc">/**
 * 将字节输出流转化为字符输出流
 * */</span>
<span class="keyword">import</span> java.io.*;
class hello{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> IOException {
        String fileName= <span class="string">"d:"</span>+File.separator+<span class="string">"hello.txt"</span>;
        File file=<span class="keyword">new</span> File(fileName);
        Writer out=<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file));
        out.write(<span class="string">"hello"</span>);
        out.close();
    }
}
<span class="javadoc">/**
 * 将字节输入流变为字符输入流
 * */</span>
<span class="keyword">import</span> java.io.*;
class hello{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> IOException {
        String fileName= <span class="string">"d:"</span>+File.separator+<span class="string">"hello.txt"</span>;
        File file=<span class="keyword">new</span> File(fileName);
        Reader read=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file));
        <span class="keyword">char</span>[] b=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];
        <span class="keyword">int</span> len=read.read(b);
        System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,len));
        read.close();
    }
}
</code></pre>]]></content>
    
    
      <category term="Java" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/Java/"/>
    
      <category term="Java" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程总结]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/Java/java_thread/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/Java/java_thread/</id>
    <published>2014-05-21T03:48:20.000Z</published>
    <updated>2014-05-21T05:13:53.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一个线程的生命期">一个线程的生命期</h4>
<p>线程经过其生命周期的各个阶段。下图显示了一个线程完整的生命周期。</p>
<p><img src="/img/Java/java_thread.jpg" alt="线程的生命期"></p>
<ul>
<li>新状态: 一个新产生的线程从新状态开始了它的生命周期。它保持这个状态知道程序start这个线程。</li>
<li>运行状态:当一个新状态的线程被start以后，线程就变成可运行状态，一个线程在此状态下被认为是开始执行其任务</li>
<li>就绪状态:当一个线程等待另外一个线程执行一个任务的时候，该线程就进入就绪状态。当另一个线程给就绪状态的线程发送信号时，该线程才重新切换到运行状态。</li>
<li>休眠状态: 由于一个线程的时间片用完了，该线程从运行状态进入休眠状态。当时间间隔到期或者等待的时间发生了，该状态的线程切换到运行状态。</li>
<li>终止状态: 一个运行状态的线程完成任务或者其他终止条件发生，该线程就切换到终止状态。</li>
</ul>
<h4 id="线程的优先级">线程的优先级</h4>
<p>每一个Java线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java优先级在MIN_PRIORITY（1）和MAX_PRIORITY（10）之间的范围内。默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY（5）。具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器时间。然而，线程优先级不能保证线程执行的顺序，而且非常依赖于平台.</p>
<h4 id="创建一个线程">创建一个线程</h4>
<p>Java提供了两种创建线程方法：</p>
<ul>
<li>通过实现Runable接口</li>
<li>通过继承Thread类本身</li>
</ul>
<h5 id="直接继承Thread的类">直接继承Thread的类</h5>
<pre><code><span class="keyword">package</span> com.liu.test;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>  <span class="keyword">extends</span> <span class="title">Thread</span>{</span>
    <span class="keyword">private</span> String name;
    <span class="keyword">public</span> <span class="title">MyThread</span>(){
    }
    <span class="keyword">public</span> <span class="title">MyThread</span>(String name){
        <span class="keyword">this</span>.name=name;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++){
            System.out.println(name+<span class="string">"运行  "</span>+i);
        }
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        MyThread h1=<span class="keyword">new</span> MyThread(<span class="string">"A"</span>);
        MyThread h2=<span class="keyword">new</span> MyThread(<span class="string">"B"</span>);
        h1.start();
        h2.start();
    }
}
</code></pre><h5 id="通过实现Runable接口">通过实现Runable接口</h5>
<pre><code>package com.liu.test;
 <span class="class"><span class="keyword">class</span> <span class="title">MyThread02</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">Runnable</span> {</span>
     <span class="keyword">private</span> String name;

     <span class="keyword">public</span> MyThread02(){

     }

     <span class="keyword">public</span> MyThread02(String name){
         <span class="keyword">this</span>.name=name;
     }

    @Override
    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        <span class="comment">// TODO Auto-generated method stub</span>
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++){
            System.out.println(name+<span class="string">"运行"</span>+i);
        }
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args){
        MyThread02 h1 =<span class="keyword">new</span> MyThread02(<span class="string">"A"</span>);
        MyThread02 h2 =<span class="keyword">new</span> MyThread02(<span class="string">"B"</span>);
        Thread s1=<span class="keyword">new</span> Thread(h1);
        Thread s2=<span class="keyword">new</span> Thread(h2);
        s1.start();
        s2.start();
    }

}
</code></pre><h4 id="实现Runnable接口比继承Thread类所具有的优势">实现Runnable接口比继承Thread类所具有的优势</h4>
<ul>
<li>适合多个相同的程序代码的线程去处理同一个资源</li>
<li>可以避免java中的单继承的限制</li>
<li>增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。    </li>
</ul>
<h4 id="线程同步">线程同步</h4>
<p>所谓同步就是在统一时间段中只有有一个线程运行，其他的线程必须等到这个线程结束之后才能继续执行。采用同步的话，可以使用同步代码块和同步方法两种来完成。</p>
<pre><code><span class="keyword">package</span> com.liu.synchronize;
<span class="comment">//采用同步的话，可以使用同步代码块和同步方法两种来完成。</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span>{</span>
    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">5</span>;
    <span class="comment">//同步代码块</span>
<span class="comment">/*    public void run() {
        for (int i=0;i&lt;10;i++){
            synchronized (this){
                if(count&gt;0){
                    try{
                        Thread.sleep(1000);
                    }catch (Exception e) {
                        e.printStackTrace();
                    }
                    System.out.println(count--);
                }
            }
        }
    }
    */</span>
    <span class="comment">//同步方法</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {
            sale();
        }
    }
    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span>() {
        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">1000</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(count--);
        }
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        test t1 =<span class="keyword">new</span> test();
        Thread h1 =<span class="keyword">new</span> Thread(t1);
        Thread h2 =<span class="keyword">new</span> Thread(t1);
        Thread h3 =<span class="keyword">new</span> Thread(t1);
        h1.start();
        h2.start();
        h3.start();
    }


}
</code></pre><h4 id="经典问题_生产者与消费者">经典问题 生产者与消费者</h4>
<pre><code><span class="comment">/**
 * 生产者生产商品放到容器中，容器有一定的容量（只能顺序放，先放后拿），
 * 消费者消费商品，当容器满了后，生产者等待，当容器为空时，消费者等待。
 * 当生产者将商品放入容器后，通知消费者；当消费者拿走商品后，通知生产者。
 */</span>

package com.liu.consumerproducer;

<span class="class"><span class="keyword">class</span> <span class="title">Goods</span>{</span>
    <span class="keyword">int</span> id;
    <span class="keyword">public</span> Goods(<span class="keyword">int</span> id){
        <span class="keyword">this</span>.id=id;
    }
    <span class="keyword">public</span> String toString(){
        <span class="keyword">return</span> <span class="string">"商品"</span>+<span class="keyword">this</span>.id;
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Container</span>{</span>
    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">index</span>=<span class="number">0</span>;
    Goods[] goods =<span class="keyword">new</span> Goods[<span class="number">6</span>];
    <span class="keyword">public</span> synchronized <span class="keyword">void</span> push(Goods good){
        <span class="keyword">while</span> (<span class="keyword">index</span>==goods.length){
            <span class="comment">//容器满了，生产者等待</span>
            <span class="keyword">try</span> {
                wait();
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
        }
        goods[<span class="keyword">index</span>]=good;
        <span class="keyword">index</span>++;
        notifyAll();<span class="comment">//当生产者放入商品后通知消费者</span>
    }
     <span class="keyword">public</span> synchronized Goods pop(){
            <span class="keyword">while</span>(<span class="keyword">index</span>==<span class="number">0</span>){<span class="comment">//当容器内没有商品消费者等待</span>
                <span class="keyword">try</span> {
                    wait();
                } <span class="keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            <span class="keyword">index</span>--;
            notifyAll();<span class="comment">//当消费者消费了商品后通知生产者</span>
            <span class="keyword">return</span> goods[<span class="keyword">index</span>];
        }
}

<span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">Runnable</span>{</span>

    Container con =<span class="keyword">new</span> Container();
    <span class="keyword">public</span> Producer(Container con) {
        <span class="keyword">this</span>.con=con;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++){
            Goods good=<span class="keyword">new</span> Goods(i);
            con.push(good);
            System.out.println(<span class="string">"生产了："</span>+good);
        }
        <span class="keyword">try</span> {
            Thread.sleep(<span class="number">1000</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">Runnable</span>{</span>

    Container con = <span class="keyword">new</span> Container();
    <span class="keyword">public</span> Consumer(Container con){
        <span class="keyword">this</span>.con=con;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> run(){
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++){
            Goods good=con.pop();
            System.out.println(<span class="string">"消费了："</span>+good);
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">1000</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                <span class="comment">// TODO Auto-generated catch block</span>
                e.printStackTrace();
            }
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
        Container con =<span class="keyword">new</span> Container();
        Producer p =<span class="keyword">new</span> Producer(con);
        Consumer c = <span class="keyword">new</span> Consumer(con);
        <span class="keyword">new</span> Thread(p).start();
        <span class="keyword">new</span> Thread(c).start();
    }

}
</code></pre>]]></content>
    
    
      <category term="Java" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/Java/"/>
    
      <category term="Java" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/Java/"/>
    
  </entry>
  
</feed>
