<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[DaMinger's blog]]></title>
  <subtitle><![CDATA[信春哥，系统稳，闭眼上线不回滚]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://github.com/DaMinger/DaMinger.github.io.git/"/>
  <updated>2014-06-05T02:24:07.349Z</updated>
  <id>https://github.com/DaMinger/DaMinger.github.io.git/</id>
  
  <author>
    <name><![CDATA[DaMinger]]></name>
    <email><![CDATA[564400632@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[LeetCode:Search for a Range]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/search_for_a_range/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/search_for_a_range/</id>
    <published>2014-06-05T02:13:08.000Z</published>
    <updated>2014-06-05T02:21:34.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a sorted array <span class="keyword">of</span> integers, find <span class="keyword">the</span> starting <span class="keyword">and</span> ending position <span class="keyword">of</span> a <span class="keyword">given</span> target value.

Your algorithm's runtime complexity must be <span class="keyword">in</span> <span class="keyword">the</span> order <span class="keyword">of</span> O(<span class="command">log</span> n).

If <span class="keyword">the</span> target <span class="keyword">is</span> <span class="keyword">not</span> found <span class="keyword">in</span> <span class="keyword">the</span> array, <span class="constant">return</span> [-<span class="number">1</span>, -<span class="number">1</span>].

For example,
Given [<span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>] <span class="keyword">and</span> target value <span class="number">8</span>,
<span class="command">return</span> [<span class="number">3</span>, <span class="number">4</span>].
</code></pre><p>思路：就是先用二分查找找到其中一个target，然后再往左右找到target的边缘。找边缘的方法跟二分查找仍然是一样的，只是切半的条件变成相等，或者不等（往左边找则是小于，往右边找则是大于）。这样下来总共进行了三次二分查找，所以算法的时间复杂度仍是O(logn)，空间复杂度是O(1)。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">searchRange</span>(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target) {
    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];
    res[<span class="number">0</span>] = -<span class="number">1</span>;
    res[<span class="number">1</span>] = -<span class="number">1</span>;
    <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)
    {
        <span class="keyword">return</span> res;
    }
    <span class="keyword">int</span> l=<span class="number">0</span>;
    <span class="keyword">int</span> r=A.length-<span class="number">1</span>;
    <span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;
    <span class="keyword">while</span>(l&lt;=r)
    {
        m=(l+r)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[m]==target)
        {
            res[<span class="number">0</span>]=m;
            res[<span class="number">1</span>]=m;
            <span class="keyword">break</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(A[m]&gt;target)
        {
            r = m-<span class="number">1</span>;
        }
        <span class="keyword">else</span>
        {
            l = m+<span class="number">1</span>;
        }
    }
    <span class="keyword">if</span>(A[m]!=target)
        <span class="keyword">return</span> res;
    <span class="keyword">int</span> newL = m;
    <span class="keyword">int</span> newR = A.length-<span class="number">1</span>;
    <span class="keyword">while</span>(newL&lt;=newR)
    {
        <span class="keyword">int</span> newM=(newL+newR)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[newM]==target)
        {
            newL = newM+<span class="number">1</span>;
        }
        <span class="keyword">else</span>
        {
            newR = newM-<span class="number">1</span>;
        }            
    }
    res[<span class="number">1</span>]=newR;
    newL = <span class="number">0</span>;
    newR = m;
    <span class="keyword">while</span>(newL&lt;=newR)
    {
        <span class="keyword">int</span> newM=(newL+newR)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[newM]==target)
        {
            newR = newM-<span class="number">1</span>;
        }
        <span class="keyword">else</span>
        {
            newL = newM+<span class="number">1</span>;
        }            
    }
    res[<span class="number">0</span>]=newL;        
    <span class="keyword">return</span> res;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Search a 2D Matrix]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/search_a_2d_matrix/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/search_a_2d_matrix/</id>
    <published>2014-06-05T02:08:06.000Z</published>
    <updated>2014-06-05T02:11:45.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Write an efficient algorithm <span class="keyword">that</span> searches <span class="keyword">for</span> a value <span class="keyword">in</span> an m x n matrix. This matrix has <span class="keyword">the</span> following properties:

Integers <span class="keyword">in</span> each row are sorted <span class="keyword">from</span> left <span class="keyword">to</span> right.
The <span class="keyword">first</span> <span class="type">integer</span> <span class="keyword">of</span> each row <span class="keyword">is</span> <span class="keyword">greater than</span> <span class="keyword">the</span> <span class="keyword">last</span> <span class="type">integer</span> <span class="keyword">of</span> <span class="keyword">the</span> previous row.
For example,

Consider <span class="keyword">the</span> following matrix:

[
  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],
  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],
  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]
]
Given target = <span class="number">3</span>, <span class="constant">return</span> <span class="constant">true</span>.
</code></pre><p>思路：二分查找</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
   <span class="keyword">public</span> boolean <span class="title">searchMatrix</span>(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target) {
    <span class="keyword">int</span> row = matrix.length;
    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;
    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[row * col];
    <span class="keyword">int</span> count = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) {
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) {
        temp[count++] = matrix[i][j];
      }
    }
    <span class="keyword">int</span> low = <span class="number">0</span>;
    <span class="keyword">int</span> high = row * col-<span class="number">1</span>;
    <span class="keyword">int</span> mid = -<span class="number">1</span>;
    <span class="keyword">while</span> (low &lt;= high) {
      mid = (low + high) / <span class="number">2</span>;
      <span class="keyword">if</span> (temp[mid] == target) {
        <span class="keyword">return</span> <span class="keyword">true</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (temp[mid] &gt; target) {
        high = mid - <span class="number">1</span>;
      } <span class="keyword">else</span> {
        low = mid + <span class="number">1</span>;
      }
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
  }
}
<span class="comment">//参考网上的，空间复杂度比上一种降低</span>
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
   <span class="keyword">public</span> boolean <span class="title">searchMatrix</span>(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target) {
    <span class="keyword">int</span> row = matrix.length;
    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;
    <span class="keyword">int</span> low = <span class="number">0</span>;
    <span class="keyword">int</span> high = row * col - <span class="number">1</span>;
    <span class="keyword">int</span> mid = -<span class="number">1</span>;
    <span class="keyword">while</span> (low &lt;= high) {
      mid = (low + high) / <span class="number">2</span>;
      <span class="keyword">if</span> (matrix[mid/col][mid%col] == target) {
        <span class="keyword">return</span> <span class="keyword">true</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid/col][mid%col] &gt; target) {
        high = mid - <span class="number">1</span>;
      } <span class="keyword">else</span> {
        low = mid + <span class="number">1</span>;
      }
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
   }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Remove Duplicates from Sorted List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/remove_duplicates_from_sorted_list/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/remove_duplicates_from_sorted_list/</id>
    <published>2014-06-05T02:04:18.000Z</published>
    <updated>2014-06-05T02:06:35.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a sorted linked <span class="built_in">list</span>, delete <span class="literal">all</span> duplicates such that each element appear only once<span class="built_in">.</span>

For example,
Given <span class="number">1</span><span class="subst">-&gt;</span><span class="number">1</span><span class="subst">-&gt;</span><span class="number">2</span>, <span class="keyword">return</span> <span class="number">1</span><span class="subst">-&gt;</span><span class="number">2.</span>
Given <span class="number">1</span><span class="subst">-&gt;</span><span class="number">1</span><span class="subst">-&gt;</span><span class="number">2</span><span class="subst">-&gt;</span><span class="number">3</span><span class="subst">-&gt;</span><span class="number">3</span>, <span class="keyword">return</span> <span class="number">1</span><span class="subst">-&gt;</span><span class="number">2</span><span class="subst">-&gt;</span><span class="number">3.</span>
</code></pre><h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span>(ListNode head) {
        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)
            <span class="keyword">return</span> head;

        ListNode p = head;

        <span class="keyword">while</span>( p!= <span class="keyword">null</span> &amp;&amp; p.next != <span class="keyword">null</span>){
            <span class="keyword">if</span>(p.val == p.next.val){
                p.next = p.next.next;
            }<span class="keyword">else</span>{
                p = p.next; 
            }
        }

        <span class="keyword">return</span> head;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Remove Duplicates from Sorted Array II]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/remove_duplicates_from_sorted_array_ii/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/remove_duplicates_from_sorted_array_ii/</id>
    <published>2014-06-05T02:01:29.000Z</published>
    <updated>2014-06-05T02:03:49.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Follow up <span class="keyword">for</span> <span class="string">"Remove Duplicates"</span>:
What <span class="keyword">if</span> duplicates are allowed at most twice?

<span class="keyword">For</span> example,
Given sorted <span class="keyword">array</span> A = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>],

Your <span class="keyword">function</span> should <span class="keyword">return</span> length = <span class="number">5</span>, <span class="keyword">and</span> A <span class="keyword">is</span> now [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>].
</code></pre><p>思路：俩指针</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span>(<span class="keyword">int</span>[] A) {
        <span class="keyword">if</span> (A.length &lt;= <span class="number">2</span>)
            <span class="keyword">return</span> A.length;

        <span class="keyword">int</span> prev = <span class="number">1</span>; <span class="comment">// point to previous</span>
        <span class="keyword">int</span> curr = <span class="number">2</span>; <span class="comment">// point to current</span>

        <span class="keyword">while</span> (curr &lt; A.length) {
            <span class="keyword">if</span> (A[curr] == A[prev] &amp;&amp; A[curr] == A[prev - <span class="number">1</span>]) {
                curr++;
            } <span class="keyword">else</span> {
                prev++;
                A[prev] = A[curr];
                curr++;
            }
        }

        <span class="keyword">return</span> prev + <span class="number">1</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Remove Duplicates from Sorted Array]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/remove_duplicates_from_sorted_array/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/remove_duplicates_from_sorted_array/</id>
    <published>2014-06-05T01:52:17.000Z</published>
    <updated>2014-06-05T01:59:29.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> sorted array, remove <span class="operator">the</span> duplicates <span class="operator">in</span> place such that <span class="keyword">each</span> <span class="keyword">element</span> appear only once <span class="operator">and</span> <span class="constant">return</span> <span class="operator">the</span> <span class="built_in">new</span> <span class="built_in">length</span>.

Do <span class="operator">not</span> allocate extra <span class="constant">space</span> <span class="keyword">for</span> another array, you must <span class="built_in">do</span> this <span class="operator">in</span> place <span class="operator">with</span> <span class="built_in">constant</span> memory.

For example,
Given input array A = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],

Your <span class="function"><span class="keyword">function</span> <span class="title">should</span> <span class="title">return</span> <span class="title">length</span> = <span class="title">2</span>, <span class="title">and</span> <span class="title">A</span> <span class="title">is</span> <span class="title">now</span> [<span class="title">1</span>,<span class="title">2</span>].</span>
</code></pre><h4 id="解法">解法</h4>
<pre><code><span class="comment">//这种写法有BUG，能返回数组各不相同的元素的个数，但A数组可能不对</span>
<span class="comment">//{1, 2, 2, 3, 3}-&gt;{1, 2, 3, 3, 3}  正确的数组应该是{1, 2, 3}</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicatesNaive</span>(<span class="keyword">int</span>[] A) {
    <span class="keyword">if</span> (A.length &lt; <span class="number">2</span>)
        <span class="keyword">return</span> A.length;

    <span class="keyword">int</span> j = <span class="number">0</span>;
    <span class="keyword">int</span> i = <span class="number">1</span>;

    <span class="keyword">while</span> (i &lt; A.length) {
        <span class="keyword">if</span> (A[i] == A[j]) {
            i++;
        } <span class="keyword">else</span> {
            j++;
            A[j] = A[i];
            i++;
        }
    }

    <span class="keyword">return</span> j + <span class="number">1</span>;
}
<span class="comment">//解法2</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] <span class="title">removeDuplicates</span>(<span class="keyword">int</span>[] A) {
    <span class="keyword">if</span> (A.length &lt; <span class="number">2</span>)
        <span class="keyword">return</span> A;

    <span class="keyword">int</span> j = <span class="number">0</span>;
    <span class="keyword">int</span> i = <span class="number">1</span>;

    <span class="keyword">while</span> (i &lt; A.length) {
        <span class="keyword">if</span> (A[i] == A[j]) {
            i++;
        } <span class="keyword">else</span> {
            j++;
            A[j] = A[i];
            i++;
        }
    }

    <span class="keyword">int</span>[] B = Arrays.copyOf(A, j + <span class="number">1</span>);

    <span class="keyword">return</span> B;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Reverse Nodes in k-Group]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/reverse_nodes_in_k-group/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/reverse_nodes_in_k-group/</id>
    <published>2014-06-05T01:46:26.000Z</published>
    <updated>2014-06-05T01:50:07.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a linked <span class="type">list</span>, <span class="property">reverse</span> <span class="keyword">the</span> nodes <span class="keyword">of</span> a linked <span class="type">list</span> k <span class="keyword">at</span> a <span class="property">time</span> <span class="keyword">and</span> <span class="constant">return</span> <span class="keyword">its</span> modified <span class="type">list</span>.

If <span class="keyword">the</span> <span class="type">number</span> <span class="keyword">of</span> nodes <span class="keyword">is</span> <span class="keyword">not</span> a multiple <span class="keyword">of</span> k <span class="keyword">then</span> left-out nodes <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">end</span> should remain <span class="keyword">as</span> <span class="keyword">it</span> <span class="keyword">is</span>.

You may <span class="keyword">not</span> alter <span class="keyword">the</span> values <span class="keyword">in</span> <span class="keyword">the</span> nodes, only nodes itself may be changed.

Only <span class="type">constant</span> memory <span class="keyword">is</span> allowed.

For example,
Given this linked <span class="type">list</span>: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>

For k = <span class="number">2</span>, you should <span class="constant">return</span>: <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>

For k = <span class="number">3</span>, you should <span class="constant">return</span>: <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>
</code></pre><p>思路: 链表反转的变形，注意分组条件即可</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> ListNode reverseKGroup(ListNode head, <span class="built_in">int</span> k) {
    <span class="keyword">if</span>(head == <span class="literal">null</span>)
    {
        return <span class="literal">null</span>;
    }
    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
    dummy.<span class="keyword">next</span> = head;
    <span class="built_in">int</span> count = <span class="number">0</span>;
    ListNode pre = dummy;
    ListNode cur = head;
    <span class="keyword">while</span>(cur != <span class="literal">null</span>)
    {
        count ++;
        ListNode <span class="keyword">next</span> = cur.<span class="keyword">next</span>;
        <span class="keyword">if</span>(count == k)
        {
            pre = reverse(pre, <span class="keyword">next</span>);
            count = <span class="number">0</span>;   
        }
        cur = <span class="keyword">next</span>;
    }
    return dummy.<span class="keyword">next</span>;
}
<span class="keyword">private</span> ListNode reverse(ListNode pre, ListNode <span class="keyword">end</span>)
{
    <span class="keyword">if</span>(pre==<span class="literal">null</span> || pre.<span class="keyword">next</span>==<span class="literal">null</span>)
        return pre;
    ListNode head = pre.<span class="keyword">next</span>;
    ListNode cur = pre.<span class="keyword">next</span>.<span class="keyword">next</span>;
    <span class="keyword">while</span>(cur!=<span class="keyword">end</span>)
    {
        ListNode <span class="keyword">next</span> = cur.<span class="keyword">next</span>;
        cur.<span class="keyword">next</span> = pre.<span class="keyword">next</span>;
        pre.<span class="keyword">next</span> = cur;
        cur = <span class="keyword">next</span>;
    }
    head.<span class="keyword">next</span> = <span class="keyword">end</span>;
    return head;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Regular Expression Matching]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/regular_expression_matching/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/regular_expression_matching/</id>
    <published>2014-06-05T01:39:54.000Z</published>
    <updated>2014-06-05T01:45:10.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Implement regular expression matching <span class="operator">with</span> support <span class="keyword">for</span> <span class="string">'.'</span> <span class="operator">and</span> <span class="string">'*'</span>.

<span class="string">'.'</span> Matches <span class="keyword">any</span> single <span class="keyword">character</span>.
<span class="string">'*'</span> Matches <span class="constant">zero</span> <span class="operator">or</span> more <span class="operator">of</span> <span class="operator">the</span> preceding <span class="keyword">element</span>.

The matching should cover <span class="operator">the</span> entire input <span class="keyword">string</span> (<span class="operator">not</span> partial).

The <span class="function"><span class="keyword">function</span> <span class="title">prototype</span> <span class="title">should</span> <span class="title">be</span>:</span>
bool isMatch(const <span class="keyword">char</span> *s, const <span class="keyword">char</span> *p)

Some examples:
isMatch(<span class="string">"aa"</span>,<span class="string">"a"</span>) → <span class="constant">false</span>
isMatch(<span class="string">"aa"</span>,<span class="string">"aa"</span>) → <span class="constant">true</span>
isMatch(<span class="string">"aaa"</span>,<span class="string">"aa"</span>) → <span class="constant">false</span>
isMatch(<span class="string">"aa"</span>, <span class="string">"a*"</span>) → <span class="constant">true</span>
isMatch(<span class="string">"aa"</span>, <span class="string">".*"</span>) → <span class="constant">true</span>
isMatch(<span class="string">"ab"</span>, <span class="string">".*"</span>) → <span class="constant">true</span>
isMatch(<span class="string">"aab"</span>, <span class="string">"c*a*b"</span>) → <span class="constant">true</span>
</code></pre><p>思路：注意s为1的情况，递归验证即可</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> boolean <span class="title">isMatch</span>(String s, String p) {

        <span class="keyword">if</span>(p.length() == <span class="number">0</span>)
            <span class="keyword">return</span> s.length() == <span class="number">0</span>;

        <span class="comment">//p's length 1 is special case    </span>
        <span class="keyword">if</span>(p.length() == <span class="number">1</span> || p.charAt(<span class="number">1</span>) != <span class="string">'*'</span>){
            <span class="keyword">if</span>(s.length() &lt; <span class="number">1</span> || (p.charAt(<span class="number">0</span>) != <span class="string">'.'</span> &amp;&amp; s.charAt(<span class="number">0</span>) != p.charAt(<span class="number">0</span>)))
                <span class="keyword">return</span> <span class="keyword">false</span>;
            <span class="keyword">return</span> isMatch(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));    

        }<span class="keyword">else</span>{
            <span class="keyword">int</span> len = s.length();

            <span class="keyword">int</span> i = -<span class="number">1</span>; 
            <span class="keyword">while</span>(i&lt;len &amp;&amp; (i &lt; <span class="number">0</span> || p.charAt(<span class="number">0</span>) == <span class="string">'.'</span> || p.charAt(<span class="number">0</span>) == s.charAt(i))){
                <span class="keyword">if</span>(isMatch(s.substring(i+<span class="number">1</span>), p.substring(<span class="number">2</span>)))
                    <span class="keyword">return</span> <span class="keyword">true</span>;
                i++;
            }
            <span class="keyword">return</span> <span class="keyword">false</span>;
        } 
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Path Sum]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/pathsum/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/pathsum/</id>
    <published>2014-06-05T01:33:39.000Z</published>
    <updated>2014-06-05T01:41:25.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> binary tree <span class="operator">and</span> <span class="operator">a</span> <span class="built_in">sum</span>, determine <span class="keyword">if</span> <span class="operator">the</span> tree has <span class="operator">a</span> root-<span class="built_in">to</span>-leaf path such that adding up all <span class="operator">the</span> values along <span class="operator">the</span> path equals <span class="operator">the</span> given <span class="built_in">sum</span>.

For example:
Given <span class="operator">the</span> below binary tree <span class="operator">and</span> <span class="built_in">sum</span> = <span class="number">22</span>,
              <span class="number">5</span>
             / \
            <span class="number">4</span>   <span class="number">8</span>
           /   / \
          <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span>
         /  \      \
        <span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span>
<span class="constant">return</span> <span class="constant">true</span>, <span class="keyword">as</span> there exist <span class="operator">a</span> root-<span class="built_in">to</span>-leaf path <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">11</span>-&gt;<span class="number">2</span> which <span class="built_in">sum</span> is <span class="number">22.</span>
</code></pre><p>思路：把所有节点放进队列里面，把节点的值放入另外一个队列里面，当它是叶子节点时，计算总和（BFS问题）</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> boolean hasPathSum(TreeNode root, <span class="built_in">int</span> sum) {
        <span class="keyword">if</span>(root == <span class="literal">null</span>) return <span class="literal">false</span>;

        LinkedList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();
        LinkedList&lt;Integer&gt; values = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();

        nodes.add(root);
        values.add(root.val);

        <span class="keyword">while</span>(!nodes.<span class="built_in">isEmpty</span>()){
            TreeNode curr = nodes.poll();
            <span class="built_in">int</span> sumValue = values.poll();

            <span class="keyword">if</span>(curr.<span class="built_in">left</span> == <span class="literal">null</span> &amp;&amp; curr.<span class="built_in">right</span> == <span class="literal">null</span> &amp;&amp; sumValue==sum){
                return <span class="literal">true</span>;
            }

            <span class="keyword">if</span>(curr.<span class="built_in">left</span> != <span class="literal">null</span>){
                nodes.add(curr.<span class="built_in">left</span>);
                values.add(sumValue+curr.<span class="built_in">left</span>.val);
            }

            <span class="keyword">if</span>(curr.<span class="built_in">right</span> != <span class="literal">null</span>){
                nodes.add(curr.<span class="built_in">right</span>);
                values.add(sumValue+curr.<span class="built_in">right</span>.val);
            }
        }

        return <span class="literal">false</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Partition List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/partition_list/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/partition_list/</id>
    <published>2014-06-05T01:28:44.000Z</published>
    <updated>2014-06-05T01:41:14.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> linked list <span class="operator">and</span> <span class="operator">a</span> <span class="built_in">value</span> x, partition <span class="keyword">it</span> such that all nodes less than x come <span class="keyword">before</span> nodes greater than <span class="operator">or</span> equal <span class="built_in">to</span> x.

You should preserve <span class="operator">the</span> original <span class="built_in">relative</span> order <span class="operator">of</span> <span class="operator">the</span> nodes <span class="operator">in</span> <span class="keyword">each</span> <span class="operator">of</span> <span class="operator">the</span> <span class="constant">two</span> partitions.

For example,
Given <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span> <span class="operator">and</span> x = <span class="number">3</span>,
<span class="constant">return</span> <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5.</span>
</code></pre><p>思路：分两段拼接。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> ListNode <span class="title">partition</span>(ListNode head, <span class="keyword">int</span> x) {
        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;

        ListNode fakeHead1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
        ListNode fakeHead2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
        fakeHead1.next = head;

        ListNode p = head;
        ListNode prev = fakeHead1;
        ListNode p2 = fakeHead2;

        <span class="keyword">while</span>(p != <span class="keyword">null</span>){
            <span class="keyword">if</span>(p.val &lt; x){
                p = p.next;
                prev = prev.next;
            }<span class="keyword">else</span>{

                p2.next = p;
                prev.next = p.next;

                p = prev.next;
                p2 = p2.next;
            } 
        }

        <span class="comment">// close the list</span>
        p2.next = <span class="keyword">null</span>;

        prev.next = fakeHead2.next;

        <span class="keyword">return</span> fakeHead1.next;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:NQueen I II]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/nqueen_i_ii/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/nqueen_i_ii/</id>
    <published>2014-06-05T01:18:13.000Z</published>
    <updated>2014-06-05T01:27:25.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>N-Queens
The n-queens puzzle <span class="keyword">is</span> the problem <span class="keyword">of</span> placing n queens <span class="keyword">on</span> an n×n chessboard such that no two queens attack each other.
Given an <span class="typename">integer</span> n, <span class="keyword">return</span> <span class="keyword">all</span> distinct solutions <span class="keyword">to</span> the n-queens puzzle.
Each solution contains a distinct board <span class="keyword">configuration</span> <span class="keyword">of</span> the n-queens' placement, where <span class="attribute">'Q</span>' <span class="keyword">and</span> '.' both indicate a queen 
<span class="keyword">and</span> an empty space respectively.
<span class="keyword">For</span> example,There exist two distinct solutions <span class="keyword">to</span> the <span class="number">4</span>-queens puzzle:
[
 [<span class="string">".Q.."</span>,  // Solution <span class="number">1</span>
  <span class="string">"...Q"</span>,
  <span class="string">"Q..."</span>,
  <span class="string">"..Q."</span>],

 [<span class="string">"..Q."</span>,  // Solution <span class="number">2</span>
  <span class="string">"Q..."</span>,
  <span class="string">"...Q"</span>,
  <span class="string">".Q.."</span>]
]
N-Queens II 
Follow up <span class="keyword">for</span> N-Queens problem.
Now, instead outputting board configurations, <span class="keyword">return</span> the total number <span class="keyword">of</span> distinct solutions.
</code></pre><p>思路: 传统的dfs递归,验证放置Queen的地方是否合法,输出Board结果</p>
<h4 id="解法">解法</h4>
<pre><code>NQueen I 
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> ArrayList&lt;String[]&gt; <span class="title">solveNQueens</span>(<span class="keyword">int</span> n) {
        ArrayList&lt;String[]&gt; res = <span class="keyword">new</span> ArrayList&lt;String[]&gt;();
        <span class="keyword">int</span>[] loc = <span class="keyword">new</span> <span class="keyword">int</span>[n];
        dfs(res,loc,<span class="number">0</span>,n);
        <span class="keyword">return</span> res;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span>(ArrayList&lt;String[]&gt; res, <span class="keyword">int</span>[] loc, <span class="keyword">int</span> cur, <span class="keyword">int</span> n){
        <span class="keyword">if</span>(cur==n) 
            printboard(res,loc,n);
        <span class="keyword">else</span>{
            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){
                loc[cur] = i;
                <span class="keyword">if</span>(isValid(loc,cur))
                    dfs(res,loc,cur+<span class="number">1</span>,n);
            }
        }
    }
    <span class="keyword">public</span> boolean <span class="title">isValid</span>(<span class="keyword">int</span>[] loc, <span class="keyword">int</span> cur){
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur;i++){
            <span class="keyword">if</span>(loc[i]==loc[cur]||Math.abs(loc[i]-loc[cur])==(cur-i))
                <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printboard</span>(ArrayList&lt;String[]&gt; res, <span class="keyword">int</span>[] loc, <span class="keyword">int</span> n){
        String[] ans = <span class="keyword">new</span> String[n];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){
            String row = <span class="keyword">new</span> String();
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){
                <span class="keyword">if</span>(j==loc[i]) row += <span class="string">"Q"</span>;
                <span class="keyword">else</span> row += <span class="string">"."</span>;
            }
            ans[i] = row;
        }
        res.add(ans);
    }
}
dfs的循环是指这一行里，从第一列到最后一列放置的所有可能，如果放置的地点通过isValid验证，
通过cur+<span class="number">1</span>进入下一行进行递归， 如果没通过验证，试下一个位置，如果所有位置都不Valid，跳回上一层

NQueen II
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">int</span> res; 
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span>(<span class="keyword">int</span> n) {
        res = <span class="number">0</span>;
        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> res;
        <span class="keyword">int</span>[] loc = <span class="keyword">new</span> <span class="keyword">int</span>[n];
        dfs(loc,<span class="number">0</span>,n);
        <span class="keyword">return</span> res;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span>(<span class="keyword">int</span>[] loc, <span class="keyword">int</span> cur, <span class="keyword">int</span> n){
        <span class="keyword">if</span> (cur==n) {
            res+=<span class="number">1</span>;
            <span class="keyword">return</span>;
        }
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){
            loc[cur] = i;
            <span class="keyword">if</span>(isValid(loc,cur))
                dfs(loc,cur+<span class="number">1</span>,n);
        }
    }
    <span class="keyword">public</span> boolean <span class="title">isValid</span>(<span class="keyword">int</span>[] loc, <span class="keyword">int</span> cur){
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur;i++){
            <span class="keyword">if</span>(loc[i]==loc[cur]||Math.abs(loc[i]-loc[cur])==(cur-i))
                <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Minimum Depth of Binary Tree]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/minimum_depth_of_binary_tree/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/minimum_depth_of_binary_tree/</id>
    <published>2014-06-04T05:33:53.000Z</published>
    <updated>2014-06-04T05:39:21.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a binary tree, find <span class="keyword">its</span> minimum depth.

The minimum depth <span class="keyword">is</span> <span class="keyword">the</span> <span class="type">number</span> <span class="keyword">of</span> nodes along <span class="keyword">the</span> shortest path <span class="keyword">from</span> <span class="keyword">the</span> root node down <span class="keyword">to</span> <span class="keyword">the</span> nearest leaf node.
</code></pre><p>思路：需要辅助队列，遍历到左子树或者右子树为空的时候，返回count</p>
<h4 id="解法">解法</h4>
<pre><code><span class="javadoc">/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span>
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span>(TreeNode root) {
        <span class="keyword">if</span>(root == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }

        LinkedList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();
        LinkedList&lt;Integer&gt; counts = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();

        nodes.add(root);
        counts.add(<span class="number">1</span>);

        <span class="keyword">while</span>(!nodes.isEmpty()){
            TreeNode curr = nodes.remove();
            <span class="keyword">int</span> count = counts.remove();

            <span class="keyword">if</span>(curr.left != <span class="keyword">null</span>){
                nodes.add(curr.left);
                counts.add(count+<span class="number">1</span>);
            }

            <span class="keyword">if</span>(curr.right != <span class="keyword">null</span>){
                nodes.add(curr.right);
                counts.add(count+<span class="number">1</span>);
            }

            <span class="keyword">if</span>(curr.left == <span class="keyword">null</span> &amp;&amp; curr.right == <span class="keyword">null</span>){
                <span class="keyword">return</span> count;
            }
        }

        <span class="keyword">return</span> <span class="number">0</span>;
    }
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Merge Sorted Array]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/merge_sorted_array/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/merge_sorted_array/</id>
    <published>2014-06-04T05:29:41.000Z</published>
    <updated>2014-06-04T05:34:49.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="constant">two</span> sorted <span class="keyword">integer</span> arrays A <span class="operator">and</span> B, <span class="built_in">merge</span> B <span class="keyword">into</span> A <span class="keyword">as</span> <span class="constant">one</span> sorted array.
</code></pre><p>思路：这个真心没啥好说的。。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span>(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n) {
        <span class="keyword">int</span> i=m-<span class="number">1</span>;
        <span class="keyword">int</span> j=n-<span class="number">1</span>;
        <span class="keyword">int</span> k=m+n-<span class="number">1</span>;
        <span class="keyword">while</span>(k&gt;=<span class="number">0</span>){
            <span class="keyword">if</span>(j&lt;<span class="number">0</span>||(i&gt;=<span class="number">0</span>&amp;&amp;A[i]&gt;B[j]))
                A[k--]=A[i--];
            <span class="keyword">else</span>
                A[k--]=B[j--];
        }
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Merge k Sorted Lists]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/merge_k_sorted_list/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/merge_k_sorted_list/</id>
    <published>2014-06-04T05:16:33.000Z</published>
    <updated>2014-06-04T05:42:14.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Merge k sorted linked lists <span class="keyword">and</span> <span class="constant">return</span> <span class="keyword">it</span> <span class="keyword">as</span> one sorted <span class="type">list</span>. Analyze <span class="keyword">and</span> describe <span class="keyword">its</span> complexity.
</code></pre><p>思路：本来想一条一条比，但是超时了，后来想到mergesort的思想，还得分而治之。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="comment">//超时</span>
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> ListNode <span class="title">mergeKLists</span>(ArrayList&lt;ListNode&gt; lists) {
        <span class="comment">// Start typing your Java solution below</span>
        <span class="comment">// DO NOT write main() function</span>
        ListNode head = <span class="keyword">null</span>;
        <span class="keyword">int</span> len = lists.size();
        <span class="keyword">if</span>(len == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">null</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">1</span>){
            <span class="keyword">return</span> lists.<span class="keyword">get</span>(<span class="number">0</span>);
        }
        head = merge2List(lists.<span class="keyword">get</span>(<span class="number">0</span>), lists.<span class="keyword">get</span>(<span class="number">1</span>));
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++){
            head = merge2List(lists.<span class="keyword">get</span>(i), head);
        }
        <span class="keyword">return</span> head;
    }
    <span class="keyword">public</span> ListNode <span class="title">merge2List</span>(ListNode node1, ListNode node2){
        ListNode head = <span class="keyword">new</span> ListNode(Integer.MIN_VALUE);
        ListNode tmp = head;
        <span class="keyword">while</span>(node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>){
            <span class="keyword">if</span>(node1.val &lt;= node2.val){
                ListNode node = <span class="keyword">new</span> ListNode(node1.val);
                tmp.next = node;
                tmp = tmp.next;
                node1 = node1.next;
            } <span class="keyword">else</span> {
                ListNode node = <span class="keyword">new</span> ListNode(node2.val);
                tmp.next = node;
                tmp = tmp.next;
                node2 = node2.next;
            }
        }
        <span class="keyword">if</span>(node1 != <span class="keyword">null</span>){
            tmp.next = node1;
        }
        <span class="keyword">if</span>(node2 != <span class="keyword">null</span>){
            tmp.next = node2;
        }
        head = head.next;
        <span class="keyword">return</span> head;
    }
}
<span class="comment">//分治</span>
<span class="keyword">public</span> ListNode <span class="title">mergeKLists</span>(ArrayList&lt;ListNode&gt; lists) {
    <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.size()==<span class="number">0</span>)
        <span class="keyword">return</span> <span class="keyword">null</span>;
    <span class="keyword">return</span> helper(lists,<span class="number">0</span>,lists.size()-<span class="number">1</span>);
}
<span class="keyword">private</span> ListNode <span class="title">helper</span>(ArrayList&lt;ListNode&gt; lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)
{
    <span class="keyword">if</span>(l&lt;r)
    {
        <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;
        <span class="keyword">return</span> merge(helper(lists,l,m),helper(lists,m+<span class="number">1</span>,r));
    }
    <span class="keyword">return</span> lists.<span class="keyword">get</span>(l);
}
<span class="keyword">private</span> ListNode <span class="title">merge</span>(ListNode l1, ListNode l2)
{ 
    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
    dummy.next = l1;
    ListNode cur = dummy;
    <span class="keyword">while</span>(l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>)
    {
        <span class="keyword">if</span>(l1.val&lt;l2.val)
        {
            l1 = l1.next;
        }
        <span class="keyword">else</span>
        {
            ListNode next = l2.next;
            cur.next = l2;
            l2.next = l1;
            l2 = next;
        }
        cur = cur.next;
    }
    <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)
        cur.next = l2;
    <span class="keyword">return</span> dummy.next;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Merge Two Sorted Lists]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/merge_two_sorted_list/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/merge_two_sorted_list/</id>
    <published>2014-06-04T05:16:11.000Z</published>
    <updated>2014-06-04T05:22:06.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Merge <span class="constant">two</span> sorted linked lists <span class="operator">and</span> <span class="constant">return</span> <span class="keyword">it</span> <span class="keyword">as</span> <span class="operator">a</span> <span class="built_in">new</span> list. The <span class="built_in">new</span> list should be made <span class="keyword">by</span> splicing together <span class="operator">the</span> nodes <span class="operator">of</span> <span class="operator">the</span> <span class="keyword">first</span> <span class="constant">two</span> lists.
</code></pre><p>思路：分别比较两个链表的节点。</p>
<h4 id="解法">解法</h4>
<pre><code>/**
 * Definition <span class="keyword">for</span> singly-linked list.
 * <span class="keyword">public</span> <span class="keyword">class</span> ListNode {
 *     <span class="built_in">int</span> val;
 *     ListNode <span class="keyword">next</span>;
 *     ListNode(<span class="built_in">int</span> x) {
 *         val = x;
 *         <span class="keyword">next</span> = <span class="literal">null</span>;
 *     }
 * }
 */
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> ListNode mergeTwoLists(ListNode l1, ListNode l2) {

        ListNode p1 = l1;
        ListNode p2 = l2;

        ListNode fakeHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
        ListNode p = fakeHead;

        <span class="keyword">while</span>(p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>){
          <span class="keyword">if</span>(p1.val &lt;= p2.val){
              p.<span class="keyword">next</span> = p1;
              p1 = p1.<span class="keyword">next</span>;
          }<span class="keyword">else</span>{
              p.<span class="keyword">next</span> = p2;
              p2 = p2.<span class="keyword">next</span>;
          }

          p = p.<span class="keyword">next</span>;
        }

        <span class="keyword">if</span>(p1 != <span class="literal">null</span>)
            p.<span class="keyword">next</span> = p1;
        <span class="keyword">if</span>(p2 != <span class="literal">null</span>)
            p.<span class="keyword">next</span> = p2;

        return fakeHead.<span class="keyword">next</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Maximum Subarray]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/maximum_subarray/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/maximum_subarray/</id>
    <published>2014-06-04T05:10:01.000Z</published>
    <updated>2014-06-04T05:43:54.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Find <span class="operator">the</span> contiguous subarray <span class="operator">within</span> <span class="operator">an</span> array (containing <span class="keyword">at</span> least <span class="constant">one</span> <span class="built_in">number</span>) which has <span class="operator">the</span> largest <span class="built_in">sum</span>.

For example, given <span class="operator">the</span> array [−<span class="number">2</span>,<span class="number">1</span>,−<span class="number">3</span>,<span class="number">4</span>,−<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,−<span class="number">5</span>,<span class="number">4</span>],
<span class="operator">the</span> contiguous subarray [<span class="number">4</span>,−<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] has <span class="operator">the</span> largest <span class="built_in">sum</span> = <span class="number">6.</span>
</code></pre><p>思路：从头到尾遍历这个数组的时候，对于一个数组里的数字，它有几种选择呢？它只有两种选择： 1. 加入之前的SubArray， 2. 自己另起一个SubArray.如果之前SubArray的总体和大于0的话，我们可以认为其对后续数字是有贡献的。这种情况下我们选择加入之前的SubArray；如果之前SubArray的总体和为0或者小于0的话，我们可以认为其对后续数字是没有贡献，甚至是有害的（小于0时）。这种情况下我们只能选择以这个数字开始，另起一个SubArray.sum记录之前SubArray的和，max用来返回最大值，当sum的值大于max时，说明发现和更大的SubArray序列，此时更新max的值。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span>
    <span class="keyword">public</span> <span class="keyword">int</span> maxSubArray(<span class="keyword">int</span>[] A) {
        <span class="keyword">int</span> max = Integer.MIN_VALUE;
        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.length; i++){
            <span class="keyword">sum</span> = <span class="keyword">sum</span>&gt;<span class="number">0</span>? <span class="keyword">sum</span> + A[i]: A[i];
            max = Math.max(<span class="keyword">sum</span>,max);
        }
        <span class="keyword">return</span> max;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Longest Substring Without Repeating Characters]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/longest_substring_without_repeating_characters/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/longest_substring_without_repeating_characters/</id>
    <published>2014-06-04T05:01:10.000Z</published>
    <updated>2014-06-04T05:46:03.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a <span class="type">string</span>, find <span class="keyword">the</span> <span class="property">length</span> <span class="keyword">of</span> <span class="keyword">the</span> longest substring <span class="keyword">without</span> repeating <span class="property">characters</span>. 
For example, <span class="keyword">the</span> longest substring <span class="keyword">without</span> repeating letters <span class="keyword">for</span> <span class="string">"abcabcbb"</span> <span class="keyword">is</span> <span class="string">"abc"</span>, which <span class="keyword">the</span> <span class="property">length</span> <span class="keyword">is</span> <span class="number">3.</span> 
For <span class="string">"bbbbb"</span> <span class="keyword">the</span> longest substring <span class="keyword">is</span> <span class="string">"b"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="property">length</span> <span class="keyword">of</span> <span class="number">1.</span>
</code></pre><p>思路：本想用hashmap,但是超时了，参考 <a href="http://blog.csdn.net/linhuanmars/article/details/19949159" target="_blank">http://blog.csdn.net/linhuanmars/article/details/19949159</a>     左右窗口滑动的想法，很不错。</p>
<p>基本思路是维护一个窗口，每次关注窗口中的字符串，在每次判断中，左窗口和右窗口选择其一向前移动。同样是维护一个HashSet, 正常情况下移动右窗口，如果没有出现重复则继续移动右窗口，如果发现重复字符，则说明当前窗口中的串已经不满足要求，继续移动有窗口不可能得到更好的结果，此时移动左窗口，直到不再有重复字符为止，中间跳过的这些串中不会有更好的结果，因为他们不是重复就是更短。因为左窗口和右窗口都只向前，所以两个窗口都对每个元素访问不超过一遍，因此时间复杂度为O(2*n)=O(n),是线性算法。空间复杂度为HashSet的size,也是O(n).</p>
<h4 id="解法">解法</h4>
<pre><code><span class="comment">//超时</span>
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span>(String s) {

    <span class="keyword">char</span>[] arr = s.toCharArray();
    <span class="keyword">int</span> pre = <span class="number">0</span>;

    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {
        <span class="keyword">if</span> (!map.containsKey(arr[i])) {
            map.put(arr[i], i);
        } <span class="keyword">else</span> {
            pre = pre &gt; map.size() ? pre : map.size();
            i = map.<span class="keyword">get</span>(arr[i]);
            map.clear();
        }
    }

    <span class="keyword">return</span> Math.max(pre, map.size());
}
}
<span class="comment"><span class="xmlDocTag">///</span>左右窗口滑动 </span>
<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span>(String s) {
    <span class="keyword">if</span>(s==<span class="keyword">null</span> &amp;&amp; s.length()==<span class="number">0</span>)
        <span class="keyword">return</span> <span class="number">0</span>;
    HashSet&lt;Character&gt; <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;Character&gt;();
    <span class="keyword">int</span> max = <span class="number">0</span>;
    <span class="keyword">int</span> walker = <span class="number">0</span>;
    <span class="keyword">int</span> runner = <span class="number">0</span>;
    <span class="keyword">while</span>(runner&lt;s.length())
    {
        <span class="keyword">if</span>(<span class="keyword">set</span>.contains(s.charAt(runner)))
        {
            <span class="keyword">if</span>(max&lt;runner-walker)
            {
                max = runner-walker;
            }
            <span class="keyword">while</span>(s.charAt(walker)!=s.charAt(runner))
            {
                <span class="keyword">set</span>.remove(s.charAt(walker));
                walker++;
            }
            walker++;
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">set</span>.add(s.charAt(runner));
        }
        runner++;
    }
    max = Math.max(max,runner-walker);
    <span class="keyword">return</span> max;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Restore IP Addresses]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/restore_ip_addresses/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/restore_ip_addresses/</id>
    <published>2014-06-04T04:50:56.000Z</published>
    <updated>2014-06-04T04:57:11.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a <span class="type">string</span> containing only digits, restore <span class="keyword">it</span> <span class="keyword">by</span> <span class="keyword">returning</span> all possible valid IP address combinations.

For example:
Given <span class="string">"25525511135"</span>,
<span class="command">
return</span> [<span class="string">"255.255.11.135"</span>, <span class="string">"255.255.111.35"</span>]. (Order <span class="keyword">does</span> <span class="keyword">not</span> matter)
</code></pre><p>思路：dfs思路解决  每一段判断时考虑0作为首位的情况</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        String s = <span class="string">"12213452"</span>;
        ArrayList&lt;String&gt; list = (<span class="keyword">new</span> Solution()).restoreIpAddresses(s);
        System.<span class="keyword">out</span>.println(list);
    }
    <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">restoreIpAddresses</span>(String s) {
        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();
        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &gt; <span class="number">12</span> || s.length() &lt; <span class="number">4</span>) <span class="keyword">return</span> list;
        restore(s, <span class="number">1</span>, <span class="string">""</span>, list);
        <span class="keyword">return</span> list;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span>(String s, <span class="keyword">int</span> num, String ip, ArrayList&lt;String&gt; list) {
        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span>;
        <span class="keyword">if</span> (num == <span class="number">4</span> &amp;&amp; valid(s)) {
            ip += s;
            list.add(ip);
            <span class="keyword">return</span>;
        }
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) {
            <span class="keyword">if</span> (i &gt; s.length()) <span class="keyword">break</span>;
            String pre = s.substring(<span class="number">0</span>, i);
            <span class="keyword">if</span> (valid(pre)) {
                String post = s.substring(i);
                restore(post, num + <span class="number">1</span>, ip + pre + <span class="string">"."</span>, list);
            }
        }
    }

    <span class="keyword">public</span> boolean <span class="title">valid</span>(String s) {
        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span> (s.length() &gt; <span class="number">1</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">int</span> v = Integer.parseInt(s);
        <span class="keyword">if</span> (v &gt;= <span class="number">0</span> &amp;&amp; v &lt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Flatten Binary Tree to Linked List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/flatten_binary_tree_to_linked_list/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/flatten_binary_tree_to_linked_list/</id>
    <published>2014-06-04T04:43:28.000Z</published>
    <updated>2014-06-04T04:48:09.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a binary tree, flatten it to a linked list in-place.

For example,
Given

         1
        / <span class="command">\
</span>       2   5
      / <span class="command">\ </span>  <span class="command">\
</span>     3   4   6
The flattened tree should look like:
   1
    <span class="command">\
</span>     2
      <span class="command">\
</span>       3
        <span class="command">\
</span>         4
          <span class="command">\
</span>           5
            <span class="command">\
</span>             6
</code></pre><p>思路：遍历左结点，当它的右节点不为空，将右节点压入栈</p>
<h4 id="解法">解法</h4>
<pre><code>/**
 * Definition <span class="keyword">for</span> binary tree
 * <span class="keyword">public</span> <span class="keyword">class</span> TreeNode {
 *     <span class="built_in">int</span> val;
 *     TreeNode <span class="built_in">left</span>;
 *     TreeNode <span class="built_in">right</span>;
 *     TreeNode(<span class="built_in">int</span> x) { val = x; }
 * }
 */
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> void flatten(TreeNode root) {
        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();
        TreeNode p = root;

        <span class="keyword">while</span>(p != <span class="literal">null</span> || !stack.<span class="literal">empty</span>()){

            <span class="keyword">if</span>(p.<span class="built_in">right</span> != <span class="literal">null</span>){
                stack.push(p.<span class="built_in">right</span>);
            }

            <span class="keyword">if</span>(p.<span class="built_in">left</span> != <span class="literal">null</span>){
                p.<span class="built_in">right</span> = p.<span class="built_in">left</span>;
                p.<span class="built_in">left</span> = <span class="literal">null</span>;
            }<span class="keyword">else</span> <span class="keyword">if</span>(!stack.<span class="literal">empty</span>()){
                TreeNode temp = stack.pop();
                p.<span class="built_in">right</span>=temp;
            }

            p = p.<span class="built_in">right</span>;
        }
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Convert Sorted List to Binary Search Tree]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/convert_sorted_list_to_binary_search_tree/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/convert_sorted_list_to_binary_search_tree/</id>
    <published>2014-06-03T05:43:43.000Z</published>
    <updated>2014-06-03T05:56:09.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> singly linked list where elements are sorted <span class="operator">in</span> <span class="keyword">ascending</span> order, <span class="built_in">convert</span> <span class="keyword">it</span> <span class="built_in">to</span> <span class="operator">a</span> height balanced BST
</code></pre><p>思路：二分+递归  比有序数组转二叉树麻烦点，因为数组可以在O(1)时间内找到任意节点，链表做不到，创建个bottom-up节点，作为每次递归的父节点，这样可以在创建二叉树的节点同时找到对应的节点。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="comment">//  Definition for singly-linked list.</span>
class ListNode {
    <span class="keyword">int</span> val;
    ListNode next;

    ListNode(<span class="keyword">int</span> x) {
        val = x;
        next = <span class="keyword">null</span>;
    }
}

<span class="comment">// Definition for binary tree</span>
class TreeNode {
    <span class="keyword">int</span> val;
    TreeNode left;
    TreeNode right;

    TreeNode(<span class="keyword">int</span> x) {
        val = x;
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">static</span> ListNode h;

    <span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span>(ListNode head) {
        <span class="keyword">if</span> (head == <span class="keyword">null</span>)
            <span class="keyword">return</span> <span class="keyword">null</span>;

        h = head;
        <span class="keyword">int</span> len = getLength(head);
        <span class="keyword">return</span> sortedListToBST(<span class="number">0</span>, len - <span class="number">1</span>);
    }

    <span class="comment">// get list length</span>
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span>(ListNode head) {
        <span class="keyword">int</span> len = <span class="number">0</span>;
        ListNode p = head;

        <span class="keyword">while</span> (p != <span class="keyword">null</span>) {
            len++;
            p = p.next;
        }
        <span class="keyword">return</span> len;
    }

    <span class="comment">// build tree bottom-up</span>
    <span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end) {
        <span class="keyword">if</span> (start &gt; end)
            <span class="keyword">return</span> <span class="keyword">null</span>;

        <span class="comment">// mid</span>
        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;

        TreeNode left = sortedListToBST(start, mid - <span class="number">1</span>);
        TreeNode root = <span class="keyword">new</span> TreeNode(h.val);
        h = h.next;
        TreeNode right = sortedListToBST(mid + <span class="number">1</span>, end);

        root.left = left;
        root.right = right;

        <span class="keyword">return</span> root;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Convert Sorted Array to Binary Search Tree]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/convert_sorted_array_to_binary_search_tree/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/convert_sorted_array_to_binary_search_tree/</id>
    <published>2014-06-03T05:39:33.000Z</published>
    <updated>2014-06-03T05:42:52.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">an</span> array where elements are sorted <span class="operator">in</span> <span class="keyword">ascending</span> order, <span class="built_in">convert</span> <span class="keyword">it</span> <span class="built_in">to</span> <span class="operator">a</span> height balanced BST.
</code></pre><p>思路：二分+递归解决</p>
<h4 id="解法">解法</h4>
<pre><code><span class="comment">// Definition for binary tree</span>
class TreeNode {
    <span class="keyword">int</span> val;
    TreeNode left;
    TreeNode right;

    TreeNode(<span class="keyword">int</span> x) {
        val = x;
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span>(<span class="keyword">int</span>[] num) {
        <span class="keyword">if</span> (num.length == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">null</span>;

        <span class="keyword">return</span> sortedArrayToBST(num, <span class="number">0</span>, num.length - <span class="number">1</span>);
    }

    <span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span>(<span class="keyword">int</span>[] num, <span class="keyword">int</span> start, <span class="keyword">int</span> end) {
        <span class="keyword">if</span> (start &gt; end)
            <span class="keyword">return</span> <span class="keyword">null</span>;

        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;
        TreeNode root = <span class="keyword">new</span> TreeNode(num[mid]);
        root.left = sortedArrayToBST(num, start, mid - <span class="number">1</span>);
        root.right = sortedArrayToBST(num, mid + <span class="number">1</span>, end);

        <span class="keyword">return</span> root;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
