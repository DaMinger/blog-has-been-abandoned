<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[DaMinger's blog]]></title>
  <subtitle><![CDATA[信春哥，系统稳，闭眼上线不回滚]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://github.com/DaMinger/DaMinger.github.io.git/"/>
  <updated>2014-05-27T09:22:57.148Z</updated>
  <id>https://github.com/DaMinger/DaMinger.github.io.git/</id>
  
  <author>
    <name><![CDATA[DaMinger]]></name>
    <email><![CDATA[564400632@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[LeetCode:Two Sum]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/twosum/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/数据结构与算法/LeetCode/twosum/</id>
    <published>2014-05-27T09:15:45.000Z</published>
    <updated>2014-05-27T09:20:22.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given an array <span class="keyword">of</span> integers, find two numbers such <span class="keyword">that</span> they add up <span class="keyword">to</span> a specific target <span class="type">number</span>.

The function twoSum should <span class="constant">return</span> indices <span class="keyword">of</span> <span class="keyword">the</span> two numbers such <span class="keyword">that</span> they add up <span class="keyword">to</span> <span class="keyword">the</span> target, <span class="keyword">where</span> index1 must be <span class="keyword">less than</span> index2. Please note <span class="keyword">that</span> your returned answers (both index1 <span class="keyword">and</span> index2) are <span class="keyword">not</span> zero-based.

You may assume <span class="keyword">that</span> each input would have exactly one solution.

Input: numbers={<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>}, target=<span class="number">9</span>
Output: index1=<span class="number">1</span>, index2=<span class="number">2</span>
</code></pre><p>思路：hashmap 存另外一个数及其index</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">twoSum</span>(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) {
        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();
        <span class="keyword">int</span> [] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++){
            <span class="keyword">if</span>(map.containsKey(numbers[i])){
                <span class="keyword">int</span> index=map.<span class="keyword">get</span>(numbers[i]);
                result[<span class="number">0</span>]=index+<span class="number">1</span>;
                result[<span class="number">1</span>]=i+<span class="number">1</span>;
                <span class="keyword">break</span>;
            }<span class="keyword">else</span>{
                map.put(target-numbers[i],i);
            }
        }
        <span class="keyword">return</span> result;
    }
    <span class="comment">//超时写法</span>
    <span class="comment">//    public int[]twoSum(int[]numbers,int target){</span>
    <span class="comment">//        int[]ret=new int[2];</span>
    <span class="comment">//        for(int i=0;i&lt;numbers.length;i++){</span>
    <span class="comment">//            for(int j=i+1;j&lt;numbers.length;j++){</span>
    <span class="comment">//                if(numbers[i]+numbers[j]==target){</span>
    <span class="comment">//                    ret[0]=i+1;</span>
    <span class="comment">//                    ret[1]=j+1;</span>
    <span class="comment">//                }        </span>
    <span class="comment">//            }</span>
    <span class="comment">//        }</span>
    <span class="comment">//        return ret;</span>
    <span class="comment">//    }</span>
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Reorder List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/reorderlist/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/数据结构与算法/LeetCode/reorderlist/</id>
    <published>2014-05-27T06:18:26.000Z</published>
    <updated>2014-05-27T06:23:39.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a singly linked <span class="type">list</span> L: L0→L1→…→Ln-<span class="number">1</span>→Ln,
reorder <span class="keyword">it</span> <span class="keyword">to</span>: L0→Ln→L1→Ln-<span class="number">1</span>→L2→Ln-<span class="number">2</span>→…

You must do this <span class="keyword">in</span>-place <span class="keyword">without</span> altering <span class="keyword">the</span> nodes' values.

For example,
Given {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}, reorder <span class="keyword">it</span> <span class="keyword">to</span> {<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>}.
</code></pre><p>思路：第一把整个链表划分成2个等长的子链表，如果原链表长度为奇数，那么第一个子链表的长度多1；第二翻转第二个子链表；第三将两个子链表合并。</p>
<h4 id="解法">解法</h4>
<pre><code>class ListNode {
      <span class="keyword">int</span> val;
      ListNode next;
      ListNode(<span class="keyword">int</span> x) {
         val = x;
          next = <span class="keyword">null</span>;
      }
}

<span class="keyword">public</span> <span class="keyword">class</span> Reorderlist {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span>(ListNode head) {
        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)
            <span class="keyword">return</span>;
        ListNode slowNode=head,fastNode=head;
        <span class="keyword">while</span>(fastNode.next!=<span class="keyword">null</span>){
            fastNode=fastNode.next;
            <span class="keyword">if</span>(fastNode.next!=<span class="keyword">null</span>)
                fastNode=fastNode.next;
            <span class="keyword">else</span>
                <span class="keyword">break</span>;
            slowNode=slowNode.next;
        }
        <span class="comment">//快慢指针确定链表中点</span>
        ListNode head1=head,head2=slowNode.next;
        slowNode.next=<span class="keyword">null</span>;
        <span class="comment">//对后半部分就行进行逆序</span>
        ListNode cur=head2,post=cur.next;
        cur.next=<span class="keyword">null</span>;
        <span class="keyword">while</span>(post!=<span class="keyword">null</span>){
            ListNode temp=post.next;
            post.next=cur;
            cur=post;
            post=temp;
        }
        head2 =cur;
        <span class="comment">//合并链表</span>
        ListNode p=head1,q=head2;
        <span class="keyword">while</span>(q!=<span class="keyword">null</span>){
            ListNode temp1=p.next;
            ListNode temp2=q.next;
            p.next=q;
            q.next=temp1;
            p=temp1;
            q=temp2;
        }
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Pow(x, n)]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/power_x_n/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/数据结构与算法/LeetCode/power_x_n/</id>
    <published>2014-05-25T11:13:08.000Z</published>
    <updated>2014-05-25T11:46:44.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Implement <span class="built_in">pow</span>(x, n).
</code></pre><p>思路：最简单的方法是循环，循环n-1遍，每次乘以x。时间复杂度：O(N)。很显然，最后超时了。并且如果用递归的话，函数好写简洁，但是碰见大数，栈空间不够用会导致运行时错误（stack overflow）。<br>二分法解决问题：x^n = x^n/2 <em> x^n/2 </em> x^n%2  n考虑奇数偶数 时间复杂度：O(logN)<br><img src="/img/数据结构与算法/2.png" alt=" "></p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span>(<span class="keyword">double</span> x, <span class="keyword">int</span> n) {
        <span class="keyword">if</span> (n == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">1.0</span>;
        <span class="keyword">double</span> half = pow(x, n/<span class="number">2</span>);
        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)
            <span class="keyword">return</span> half * half;
        <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)
            <span class="keyword">return</span> half * half * x;
        <span class="keyword">else</span> 
            <span class="keyword">return</span> half * half / x;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Single Number I and  II]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/singlenumber/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/数据结构与算法/LeetCode/singlenumber/</id>
    <published>2014-05-25T11:12:39.000Z</published>
    <updated>2014-05-25T11:31:08.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>I:
Given <span class="operator">an</span> array <span class="operator">of</span> integers, every <span class="keyword">element</span> appears twice except <span class="keyword">for</span> <span class="constant">one</span>. Find that single <span class="constant">one</span>.
II:
Given <span class="operator">an</span> array <span class="operator">of</span> integers, every <span class="keyword">element</span> appears <span class="constant">three</span> times except <span class="keyword">for</span> <span class="constant">one</span>. Find that single <span class="constant">one</span>.

Note:
Your algorithm should have <span class="operator">a</span> linear runtime complexity. Could you implement <span class="keyword">it</span> <span class="keyword">without</span> <span class="keyword">using</span> extra memory?
</code></pre><p>思路：hashmap去存数组及对应的次数即可。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="keyword">int</span>[] A) {
        <span class="keyword">if</span>(A.length==<span class="number">0</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }
        HashMap&lt;Integer,Integer&gt; hash= <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();
        <span class="keyword">for</span>(<span class="keyword">int</span> a:A){
            <span class="keyword">if</span>(hash.containsKey(a)){
                hash.put(a,hash.<span class="keyword">get</span>(a)+<span class="number">1</span>);
            }
            <span class="keyword">else</span>{
                hash.put(a,<span class="number">1</span>);
            }
        }
        <span class="keyword">for</span>(<span class="keyword">int</span> key:hash.keySet()){
            <span class="keyword">if</span>(hash.<span class="keyword">get</span>(key)==<span class="number">1</span>)
                <span class="keyword">return</span> key;
        }
        <span class="keyword">return</span> <span class="number">0</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Copy List with Random Pointer]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/copylistwithrandompointer/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/数据结构与算法/LeetCode/copylistwithrandompointer/</id>
    <published>2014-05-25T11:10:30.000Z</published>
    <updated>2014-05-25T11:47:03.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>A linked <span class="type">list</span> <span class="keyword">is</span> <span class="keyword">given</span> such <span class="keyword">that</span> each node <span class="keyword">contains</span> an additional random pointer which could point <span class="keyword">to</span> any node <span class="keyword">in</span> <span class="keyword">the</span> <span class="type">list</span> <span class="keyword">or</span> null.

Return a deep <span class="keyword">copy</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="type">list</span>.
</code></pre><p>思路：因为每个链表都有随机指针，遍历一遍肯定是不行的，遍历2遍，第一遍去记下next，第二遍去记下random，但是时间复杂度o(n^2),参考下面帖子想法不错，<br><a href="http://blog.csdn.net/zhaojinjia/article/details/9313275" target="_blank">http://blog.csdn.net/zhaojinjia/article/details/9313275</a>  <a href="http://blog.csdn.net/ljphhj/article/details/21832129" target="_blank">http://blog.csdn.net/ljphhj/article/details/21832129</a> <a href="http://blog.csdn.net/linhuanmars/article/details/22463599" target="_blank">http://blog.csdn.net/linhuanmars/article/details/22463599</a></p>
<p>第一步对每个节点进行扫描，复制每个节点，将新节点接在旧节点后面；第二步扫描每个旧节点，把旧结点的随机指针赋给新节点的随机指针；第三步扫描所有节点，把链表拆成两个，第一个还原原链表，而第二个就是我们要求的复制链表。因为现在链表是旧新更替，只要把每隔两个结点分别相连，对链表进行分割即可。这个方法总共进行三次线性扫描，所以时间复杂度是O(n)。而这里并不需要额外空间，所以空间复杂度是O(1)。</p>
<h4 id="解法">解法</h4>
<pre><code>class RandomListNode {
        <span class="keyword">int</span> label;
        RandomListNode next, random;
        RandomListNode(<span class="keyword">int</span> x) { <span class="keyword">this</span>.label = x; }
     };
<span class="keyword">public</span> <span class="keyword">class</span> copyListWithRandom {
    <span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span>(RandomListNode head) {
        <span class="keyword">if</span>(head ==<span class="keyword">null</span>){
            <span class="keyword">return</span> head;
        }
        RandomListNode nowNode=head;
        <span class="keyword">while</span>(nowNode !=<span class="keyword">null</span>){
            RandomListNode copyNode=<span class="keyword">new</span> RandomListNode(nowNode.label);
            copyNode.next=nowNode.next;
            nowNode.next=copyNode;
            nowNode =nowNode.next.next;
        }
        <span class="comment">//把随机节点接好</span>
        nowNode=head;
        <span class="keyword">while</span>(nowNode !=<span class="keyword">null</span>){
            <span class="keyword">if</span>(nowNode.random!=<span class="keyword">null</span>){
                nowNode.next.random=nowNode.random.next;
            }
            nowNode=nowNode.next.next;
        }
        <span class="comment">//分成两个链表，第一个链表还原，第二链表就是我们想要的</span>
        RandomListNode newHead =head.next;
        nowNode=head;
        <span class="keyword">while</span>(nowNode!=<span class="keyword">null</span>){
            <span class="comment">//还原第一个链表</span>
            RandomListNode newNode =nowNode.next;
            nowNode.next=newNode.next;
            <span class="keyword">if</span>(newNode.next!=<span class="keyword">null</span>)
                newNode.next=newNode.next.next;
            nowNode=nowNode.next;
        }
        <span class="keyword">return</span> newHead;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:String to Integer(atoi)]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/stringtointeger/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/stringtointeger/</id>
    <published>2014-05-23T12:27:57.000Z</published>
    <updated>2014-05-23T13:07:58.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>String <span class="built_in">to</span> Integer (atoi) 
Implement atoi <span class="built_in">to</span> <span class="built_in">convert</span> <span class="operator">a</span> <span class="keyword">string</span> <span class="built_in">to</span> <span class="operator">an</span> <span class="keyword">integer</span>.
</code></pre><p>思路：输入的情况比较多，空串，一串空格，空，正负数，数组越界</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringtoInteger</span> {</span>
     <span class="keyword">public</span> <span class="keyword">int</span> atoi(String <span class="keyword">str</span>) {
            <span class="comment">//空串</span>
            <span class="keyword">if</span>(<span class="keyword">str</span>==<span class="keyword">null</span>){
                <span class="keyword">return</span> <span class="number">0</span>;
            }
            <span class="comment">//一堆空格</span>
            <span class="keyword">str</span>=<span class="keyword">str</span>.trim();
            <span class="keyword">if</span>(<span class="keyword">str</span>.length()==<span class="number">0</span>){
                <span class="keyword">return</span> <span class="number">0</span>;
            }
            <span class="comment">//正负数</span>
            <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;
            <span class="keyword">int</span> i=<span class="number">0</span>;
            <span class="keyword">if</span>(<span class="keyword">str</span>.charAt(<span class="number">0</span>)==<span class="string">'-'</span>){
                flag=<span class="keyword">false</span>;
                i++;
            }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">str</span>.charAt(<span class="number">0</span>)==<span class="string">'+'</span>){
                i++;
            }
            <span class="comment">//这里一定要用比INT大的数据类型，用INT，数组刚刚越界时（自动转型），过不去</span>
            <span class="keyword">long</span>  result =<span class="number">0</span>;
            <span class="keyword">while</span>(<span class="keyword">str</span>.length()&gt;i&amp;&amp;<span class="keyword">str</span>.charAt(i)&gt;=<span class="string">'0'</span>&amp;&amp;<span class="keyword">str</span>.charAt(i)&lt;=<span class="string">'9'</span>){
                result=result*<span class="number">10</span>+<span class="keyword">str</span>.charAt(i)-<span class="string">'0'</span>;
                i++;
            }
            <span class="keyword">if</span>(!flag){
                result=-result;
            }
            <span class="keyword">if</span> (result &gt; Integer.MAX_VALUE)
                <span class="keyword">return</span> Integer.MAX_VALUE;

            <span class="keyword">if</span> (result &lt; Integer.MIN_VALUE)
                <span class="keyword">return</span> Integer.MIN_VALUE;
            <span class="keyword">return</span> (<span class="keyword">int</span>) result;
        }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Reverse Integer]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/reverinteger/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/reverinteger/</id>
    <published>2014-05-23T12:27:35.000Z</published>
    <updated>2014-05-23T13:05:17.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Reverse Integer 
Reverse digits <span class="operator">of</span> <span class="operator">an</span> <span class="keyword">integer</span>.

Example1: x = <span class="number">123</span>, <span class="constant">return</span> <span class="number">321</span>
Example2: x = -<span class="number">123</span>, <span class="constant">return</span> -<span class="number">321</span>
</code></pre><p>思路：整数各位取余</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span>(<span class="keyword">int</span> x) {
    <span class="keyword">int</span> nReverse = <span class="number">0</span>;
            <span class="keyword">while</span> (x != <span class="number">0</span>) {
                nReverse = nReverse * <span class="number">10</span> + x % <span class="number">10</span>;
                x = x / <span class="number">10</span>;
            }
            <span class="keyword">return</span> nReverse;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Linked List Cycle II]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/linkedlistcycle2/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/linkedlistcycle2/</id>
    <published>2014-05-23T12:26:02.000Z</published>
    <updated>2014-05-23T13:09:17.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Linked List Cycle II 
Given <span class="operator">a</span> linked list, <span class="constant">return</span> <span class="operator">the</span> node where <span class="operator">the</span> cycle <span class="operator">begins</span>. If there is no cycle, <span class="constant">return</span> <span class="constant">null</span>.

Follow up:
Can you solve <span class="keyword">it</span> <span class="keyword">without</span> <span class="keyword">using</span> extra <span class="constant">space</span>?
</code></pre><p>思路：此题除判断回路外还需要判断闭环的位置。依旧设置快慢指针p1,p2.假设链表长度为n，环开始的节点Y为到头节点X有a步，p1和p2在距离环开始的节点b步的Z地方相遇（按顺时针），假设相遇节点Z到环开始的节点c步（按顺时针），那么p1走的路程为a+b，p2走的路程为a+b+c+b，显然p2走的路程为p1的2倍，于是2(a+b)=a+2b+c，于是我们推出a=c。</p>
<p>知道这个结论后面的解答就很简单了，p1和p2相遇后，把p1指向头节点，然后p1,p2都一次走一步，走了c步后p1 p2相遇，该节点Y就是环开始的节点。<br><img src="/img/数据结构与算法/2.jpg" alt=""></p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">class</span> ListNode {
      <span class="built_in">int</span> val;
      ListNode <span class="keyword">next</span>;
      ListNode(<span class="built_in">int</span> x) {
         val = x;
          <span class="keyword">next</span> = <span class="literal">null</span>;
      }
}
<span class="keyword">public</span> <span class="keyword">class</span> detectCycle222 {
    <span class="keyword">public</span> ListNode detectCycle(ListNode head) {
        ListNode slow=head,fast=head;
        <span class="keyword">while</span>(<span class="literal">true</span>){
            <span class="keyword">if</span>(fast ==<span class="literal">null</span>||fast.<span class="keyword">next</span>==<span class="literal">null</span>){
                return <span class="literal">null</span>;
            }
            slow =slow.<span class="keyword">next</span>;
            fast =fast.<span class="keyword">next</span>.<span class="keyword">next</span>;
            <span class="keyword">if</span>(slow ==fast){
                break;
            }
        }
        slow=head;
        <span class="keyword">while</span>(slow!=fast){
            slow=slow.<span class="keyword">next</span>;
            fast=fast.<span class="keyword">next</span>;
        }
        return slow;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Linked List Cycle]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/linkedlistcycle/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/linkedlistcycle/</id>
    <published>2014-05-23T12:25:51.000Z</published>
    <updated>2014-05-23T13:04:27.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Linked List Cycle
Given <span class="operator">a</span> linked list, determine <span class="keyword">if</span> <span class="keyword">it</span> has <span class="operator">a</span> cycle <span class="operator">in</span> <span class="keyword">it</span>.

Follow up:
Can you solve <span class="keyword">it</span> <span class="keyword">without</span> <span class="keyword">using</span> extra <span class="constant">space</span>?
</code></pre><p>思路：设计两个快慢指针，慢节点每次移动一个节点，快节点每次移动两个节点，当快慢指针相等时，则存在闭环</p>
<h4 id="解法">解法</h4>
<pre><code>class ListNode {
      <span class="keyword">int</span> val;
      ListNode next;
      ListNode(<span class="keyword">int</span> x) {
         val = x;
          next = <span class="keyword">null</span>;
      }
}

<span class="keyword">public</span> <span class="keyword">class</span> Reorderlist {
    <span class="keyword">public</span> boolean <span class="title">hasCycle</span>(ListNode head){
        ListNode slow=head,fast=head;
        <span class="keyword">while</span>(<span class="keyword">true</span>){
            <span class="keyword">if</span>(fast ==<span class="keyword">null</span>||fast.next==<span class="keyword">null</span>){
                <span class="keyword">return</span> <span class="keyword">false</span>;
            }
            slow =slow.next;
            fast =fast.next.next;
            <span class="keyword">if</span>(slow ==fast){
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:LRU Cache]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/lrucache/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/lrucache/</id>
    <published>2014-05-23T12:24:58.000Z</published>
    <updated>2014-05-23T13:03:41.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>LRU Cache
Design <span class="operator">and</span> implement <span class="operator">a</span> data structure <span class="keyword">for</span> Least Recently Used (LRU) cache. It should support <span class="operator">the</span> following operations: <span class="built_in">get</span> <span class="operator">and</span> <span class="built_in">set</span>.

<span class="built_in">get</span>(key) - Get <span class="operator">the</span> <span class="built_in">value</span> (will always be positive) <span class="operator">of</span> <span class="operator">the</span> key <span class="keyword">if</span> <span class="operator">the</span> key exists <span class="operator">in</span> <span class="operator">the</span> cache, otherwise <span class="constant">return</span> -<span class="number">1.</span>
<span class="built_in">set</span>(key, <span class="built_in">value</span>) - Set <span class="operator">or</span> insert <span class="operator">the</span> <span class="built_in">value</span> <span class="keyword">if</span> <span class="operator">the</span> key is <span class="operator">not</span> already present. When <span class="operator">the</span> cache reached its capacity, 
                  <span class="keyword">it</span> should invalidate <span class="operator">the</span> least recently used <span class="keyword">item</span> <span class="keyword">before</span> inserting <span class="operator">a</span> <span class="built_in">new</span> <span class="keyword">item</span>.
</code></pre><p>思路：双向链表+hashmap 没有超出容量之前，新节点放在头部，有重复的话，把该节点移到头结点，超出容量的话，移除尾节点<br><img src="/img/数据结构与算法/1.png" alt="双向链表"></p>
<h4 id="解法">解法</h4>
<pre><code>import java.util.HashMap;

<span class="comment">//双链表＋HashMap</span>
class Node{
    Node prev;
    Node next;
    <span class="keyword">int</span> <span class="keyword">value</span>;
    <span class="keyword">int</span> key;
    Node(<span class="keyword">int</span> key,<span class="keyword">int</span> <span class="keyword">value</span>){
        <span class="keyword">this</span>.<span class="keyword">value</span>=<span class="keyword">value</span>;
        <span class="keyword">this</span>.key=key;
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> LRUCache {
    <span class="keyword">private</span> <span class="keyword">int</span>  capacity;
    <span class="keyword">private</span> <span class="keyword">int</span> len;
    <span class="keyword">private</span> Node head;
    <span class="keyword">private</span> Node end;
    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map =<span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();
    <span class="keyword">public</span> <span class="title">LRUCache</span>(<span class="keyword">int</span> capacity) {
        <span class="keyword">this</span>.capacity=capacity;
        len=<span class="number">0</span>;
    }
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span>(<span class="keyword">int</span> key) {
        <span class="keyword">if</span>(map.containsKey(key)){
            Node last=map.<span class="keyword">get</span>(key);
            removeNode(last);
            setHead(last);
            <span class="keyword">return</span> last.<span class="keyword">value</span>;
        }<span class="keyword">else</span>{
            <span class="keyword">return</span> -<span class="number">1</span>;
        }
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span>(Node node){
        Node cur=node;
        Node pre=cur.prev;
        Node post = cur.next;
        <span class="keyword">if</span>(pre !=<span class="keyword">null</span>){
            pre.next=post;
        }<span class="keyword">else</span>{
            <span class="comment">//前驱节点为空</span>
            head =post;
        }
        <span class="keyword">if</span>(post !=<span class="keyword">null</span>){
            post.prev=pre;
        }<span class="keyword">else</span>{
            <span class="comment">//后驱节点为空</span>
            end =pre;
        }
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHead</span>(Node node){
        node.next=head;
        node.prev=<span class="keyword">null</span>;
        <span class="keyword">if</span>(head!=<span class="keyword">null</span>){
            head.prev=node;
        }
        head=node;
        <span class="keyword">if</span>(end==<span class="keyword">null</span>){
            end=node;
        }
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> <span class="keyword">value</span>) {
        <span class="keyword">if</span>(map.containsKey(key)){
            Node oldNode=map.<span class="keyword">get</span>(key);
            oldNode.<span class="keyword">value</span>=<span class="keyword">value</span>;
            removeNode(oldNode);
            setHead(oldNode);
        }<span class="keyword">else</span>{
            Node newNode =<span class="keyword">new</span> Node(key, <span class="keyword">value</span>);
            <span class="keyword">if</span>(len&lt;capacity){
                <span class="comment">//把LRU里面的新节点放在头部</span>
                setHead(newNode);
                map.put(key, newNode);
                len++;
            }<span class="keyword">else</span>{
                <span class="comment">//超出容量，则移除尾节点</span>
                map.remove(end.key);
                end=end.prev;
                <span class="keyword">if</span>(end!=<span class="keyword">null</span>){
                    end.next=<span class="keyword">null</span>;
                }
                setHead(newNode);
                map.put(key, newNode);
            }
        }
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基础的数据结构总结]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/basicadt/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/数据结构与算法/basicadt/</id>
    <published>2014-05-22T06:22:03.000Z</published>
    <updated>2014-05-22T07:19:05.000Z</updated>
    <content type="html"><![CDATA[<h4 id="数组">数组</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> test {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        <span class="keyword">int</span> <span class="keyword">value</span>[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {  
             <span class="keyword">value</span>[i] = i;  
        }  

       traverse(<span class="keyword">value</span>);  
       insert(<span class="keyword">value</span>,<span class="number">666</span>,<span class="number">5</span>);  
       delete(<span class="keyword">value</span>,<span class="number">3</span>);
       traverse(<span class="keyword">value</span>);  
   }
    <span class="comment">//插入</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] <span class="title">insert</span>(<span class="keyword">int</span>[]old,<span class="keyword">int</span> <span class="keyword">value</span>,<span class="keyword">int</span> index){
        <span class="keyword">for</span>(<span class="keyword">int</span> k=old.length-<span class="number">1</span>;k&gt;index;k--){
            old[k]=old[k-<span class="number">1</span>];
        }
        old[index]=<span class="keyword">value</span>;
        <span class="keyword">return</span> old;
    }
    <span class="comment">//遍历</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverse</span>(<span class="keyword">int</span> data[]){
        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;data.length;j++)
            System.<span class="keyword">out</span>.print(data[j]+<span class="string">" "</span>);
        System.<span class="keyword">out</span>.println(<span class="string">" "</span>);
    }
    <span class="comment">//删除</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] <span class="title">delete</span>(<span class="keyword">int</span>[]old,<span class="keyword">int</span> index){
        <span class="keyword">for</span>(<span class="keyword">int</span> h=index;h&lt;old.length -<span class="number">1</span>;h++){
            old[h] = old[h+<span class="number">1</span>];
        }
        old[old.length-<span class="number">1</span>]=<span class="number">0</span>;
        <span class="keyword">return</span> old;
    }
}
</code></pre><h4 id="String">String</h4>
<pre><code>    这些方法应该熟记
    toCharArray() //get char <span class="keyword">array</span> <span class="keyword">of</span> a <span class="typename">String</span>
    Arrays.sort()  //sort an <span class="keyword">array</span>
    Arrays.toString(char[] a) //convert <span class="keyword">to</span> <span class="typename">string</span>
    charAt(int x) //get a char at the specific index
    length() //<span class="typename">string</span> length
    length //<span class="keyword">array</span> size 
    substring(int beginIndex) 
    substring(int beginIndex, int endIndex)
    <span class="typename">Integer</span>.valueOf()//<span class="typename">string</span> <span class="keyword">to</span> <span class="typename">integer</span>
    <span class="typename">String</span>.valueOf()/<span class="typename">integer</span> <span class="keyword">to</span> <span class="typename">string</span>
</code></pre><h4 id="链表">链表</h4>
<pre><code><span class="keyword">class</span> Node {
    <span class="built_in">int</span> val;
    Node <span class="keyword">next</span>;

    Node(<span class="built_in">int</span> x) {
        val = x;
        <span class="keyword">next</span> = <span class="literal">null</span>;
    }
}
</code></pre><h4 id="栈">栈</h4>
<pre><code>class Stack{
    Node top; 

    <span class="comment">//取栈顶</span>
    <span class="keyword">public</span> Node <span class="title">peek</span>(){
        <span class="keyword">if</span>(top != <span class="keyword">null</span>){
            <span class="keyword">return</span> top;
        }

        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    <span class="comment">//出栈</span>
    <span class="keyword">public</span> Node <span class="title">pop</span>(){
        <span class="keyword">if</span>(top == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }<span class="keyword">else</span>{
            Node temp = <span class="keyword">new</span> Node(top.val);
            top = top.next;
            <span class="keyword">return</span> temp;    
        }
    }

    <span class="comment">//入栈</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(Node n){
        <span class="keyword">if</span>(n != <span class="keyword">null</span>){
            n.next = top;
            top = n;
        }
    }
}
</code></pre><h4 id="队列">队列</h4>
<pre><code>class Queue{
    Node first, last;

    <span class="comment">//入队</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span>(Node n){
        <span class="keyword">if</span>(first == <span class="keyword">null</span>){
            first = n;
            last = first;
        }<span class="keyword">else</span>{
            last.next = n;
            last = n;
        }
    }

    <span class="comment">//出队</span>
    <span class="keyword">public</span> Node <span class="title">dequeue</span>(){
        <span class="keyword">if</span>(first == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }<span class="keyword">else</span>{
            Node temp = <span class="keyword">new</span> Node(first.val);
            first = first.next;
            <span class="keyword">return</span> temp;
        }    
    }
}
</code></pre><h4 id="树（二叉树）">树（二叉树）</h4>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">T</span>&gt; {</span>
    <span class="javadoc">/**
     * 结点类。  
     */</span>
    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> {</span>
        int value; <span class="comment">// 该节点存储的值。</span>
        Node leftChild; <span class="comment">// 指向左子节点的引用。</span>
        Node rightChild; <span class="comment">// 指向右子节点的引用。</span>
        Node(int value) {
            <span class="keyword">this</span>.value = value;
            leftChild = <span class="keyword">null</span>;
            rightChild = <span class="keyword">null</span>;
        }
    }
    <span class="keyword">private</span> Node root; <span class="comment">// 根节点。</span>
    <span class="javadoc">/**
     * 无参构造方法。
     */</span>
    BinaryTree() {
        root = <span class="keyword">null</span>;
    }
    <span class="javadoc">/**
     * 使用一个数组来构造二叉树。
     */</span>
    BinaryTree(int[] arr) {
        <span class="keyword">for</span> (int i : arr) {
            insert(i);
        }
    }
    <span class="keyword">private</span> void insert(int value) {
        root = insert(root, value);
    }
    <span class="javadoc">/**
     * 将数值插入到二叉树中，比当前结点小或等于当前结点的插在当前结点的左侧，
     * 比当前结点大的数插在当前结点的右侧，每次从根结点开始递归比较。。
     */</span>
    <span class="keyword">private</span> Node insert(Node node, int value) {
        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {
            node = <span class="keyword">new</span> Node(value);
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> (value &lt;= node.value) {
                node.leftChild = insert(node.leftChild, value);
            } <span class="keyword">else</span> {
                node.rightChild = insert(node.rightChild, value);
            }
        }
        <span class="keyword">return</span> node;
    }
    <span class="javadoc">/**
     * 访问节点：将节点的值取出来并打印。
     */</span>
    <span class="keyword">private</span> void visit(Node node) {
        <span class="javadoc">/**
         * 当节点为空时返回。
         */</span>
        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {
            <span class="keyword">return</span>;
        }
        int value = node.value;
        System.out.println(value);
    }
    <span class="javadoc">/**
     * 从指定节点作为根节点开始递归对树进行先序遍历。
     */</span>
    <span class="keyword">private</span> void preOrderTravels(Node node) {
        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {
            <span class="keyword">return</span>;
        } <span class="keyword">else</span> {   
            <span class="comment">//这里调整visit顺序 即可实现先序后序中序            </span>
            visit(node);                       
            preOrderTravels(node.leftChild);
            preOrderTravels(node.rightChild);
        }
    }
    <span class="javadoc">/**
     * 从根节点开始对整个树进行先序遍历。
     * 这里是递归做法，非递归做法，需要用到栈
     */</span>
    public void preOrderTravels() {
        preOrderTravels(root);
    }
}
</code></pre><h4 id="图">图</h4>
<pre><code>class GraphNode{ 
    <span class="keyword">int</span> val;
    GraphNode next;
    GraphNode[] neighbors;
    boolean visited;

    GraphNode(<span class="keyword">int</span> x) {
        val = x;
    }

    GraphNode(<span class="keyword">int</span> x, GraphNode[] n){
        val = x;
        neighbors = n;
    }

    <span class="keyword">public</span> String <span class="title">toString</span>(){
        <span class="keyword">return</span> <span class="string">"value: "</span>+ <span class="keyword">this</span>.val; 
    }
}

<span class="comment">//使用队列辅助广度搜索</span>
class Queue{
    GraphNode first, last;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span>(GraphNode n){
        <span class="keyword">if</span>(first == <span class="keyword">null</span>){
            first = n;
            last = first;
        }<span class="keyword">else</span>{
            last.next = n;
            last = n;
        }
    }

<span class="keyword">public</span> GraphNode <span class="title">dequeue</span>(){
        <span class="keyword">if</span>(first == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }<span class="keyword">else</span>{
            GraphNode temp = <span class="keyword">new</span> GraphNode(first.val, first.neighbors);
            first = first.next;
            <span class="keyword">return</span> temp;
        }    
    }
}
<span class="keyword">public</span> <span class="keyword">class</span> test {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]){
        GraphNode n1 = <span class="keyword">new</span> GraphNode(<span class="number">1</span>); 
        GraphNode n2 = <span class="keyword">new</span> GraphNode(<span class="number">2</span>); 
        GraphNode n3 = <span class="keyword">new</span> GraphNode(<span class="number">3</span>); 
        GraphNode n4 = <span class="keyword">new</span> GraphNode(<span class="number">4</span>); 
        GraphNode n5 = <span class="keyword">new</span> GraphNode(<span class="number">5</span>); 

        n1.neighbors = <span class="keyword">new</span> GraphNode[]{n2,n3,n5};
        n2.neighbors = <span class="keyword">new</span> GraphNode[]{n1,n4};
        n3.neighbors = <span class="keyword">new</span> GraphNode[]{n1,n4,n5};
        n4.neighbors = <span class="keyword">new</span> GraphNode[]{n2,n3,n5};
        n5.neighbors = <span class="keyword">new</span> GraphNode[]{n1,n3,n4};

    <span class="comment">//  breathFirstSearch(n1, 4);</span>
        deepFirstSearch(n1, <span class="number">4</span>);
    }
    <span class="comment">//深度搜索，递归，非递归得使用到栈</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deepFirstSearch</span>(GraphNode root,<span class="keyword">int</span> x){
    <span class="comment">//    if(root.val==x)</span>
    <span class="comment">//        System.out.println("find in root");</span>
        root.visited=<span class="keyword">true</span>;
        <span class="keyword">for</span>(GraphNode n :root.neighbors ){
            <span class="keyword">if</span>(!n.visited){
                System.<span class="keyword">out</span>.print(n+<span class="string">" "</span>);
                n.visited =<span class="keyword">true</span>;
                <span class="keyword">if</span>(n.val == x){
                    System.<span class="keyword">out</span>.print(<span class="string">"Find "</span>+n);
                }
                deepFirstSearch(n, x);
            }
        }
    }
    <span class="comment">//广度搜索</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">breathFirstSearch</span>(GraphNode root,<span class="keyword">int</span> x){
        <span class="comment">//如果搜索的值正好是根节点的值</span>
        <span class="keyword">if</span>(root.val == x)
            System.<span class="keyword">out</span>.println(<span class="string">"find in root"</span>);
        Queue queue =<span class="keyword">new</span> Queue();
        root.visited=<span class="keyword">true</span>;
        queue.enqueue(root);
        <span class="keyword">while</span>(queue.first !=<span class="keyword">null</span>){
            <span class="comment">//将节点出队</span>
            GraphNode c =queue.dequeue();
            <span class="comment">//遍历邻居节点</span>
            <span class="keyword">for</span>(GraphNode n:c.neighbors){
                <span class="comment">//访问没访问过的节点</span>
                <span class="keyword">if</span>(!n.visited){
                    System.<span class="keyword">out</span>.print(n+ <span class="string">" "</span>);
                    n.visited =<span class="keyword">true</span>;
                    <span class="keyword">if</span>(n.val == x){
                        System.<span class="keyword">out</span>.print(<span class="string">"Find "</span>+n);
                    }
                    <span class="comment">//将访问过的节点从新入队</span>
                    queue.enqueue(n);
                }
            }
        }
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Insertion Sort List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/insertsortlist/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/数据结构与算法/LeetCode/insertsortlist/</id>
    <published>2014-05-22T05:48:59.000Z</published>
    <updated>2014-05-22T06:20:21.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Sort <span class="operator">a</span> linked list <span class="keyword">using</span> insertion <span class="built_in">sort</span>.
</code></pre><h6 id="插入排序大致思路">插入排序大致思路</h6>
<ul>
<li>设数组为a[0…n-1]。</li>
<li>初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1</li>
<li>将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。</li>
<li>i++并重复第二步直到i==n-1。排序完成。 </li>
</ul>
<h4 id="解法">解法</h4>
<pre><code>该题是在链表中使用插入排序，其思路都是一样的
<span class="keyword">class</span> ListNode {
     int <span class="keyword">val</span>;
     ListNode next;
     ListNode(int x) {
         <span class="keyword">val</span> = x;
         next = <span class="keyword">null</span>;
    }
 }
<span class="keyword">public</span> <span class="keyword">class</span> insertSortList {
    <span class="keyword">public</span> ListNode insertionSortList(ListNode head){
        <span class="keyword">if</span>(head ==<span class="keyword">null</span> ||head.next==<span class="keyword">null</span>)
            <span class="keyword">return</span> head;
        ListNode cur =head.next;
        <span class="keyword">while</span>(cur !=<span class="keyword">null</span>){
            ListNode tmp=head;
            <span class="comment">//用tmp节点代表有序区的最后一个节点</span>
            <span class="keyword">while</span>(tmp.<span class="keyword">val</span>&lt;cur.<span class="keyword">val</span> &amp;&amp; tmp!=cur)
                tmp=tmp.next;
            <span class="keyword">if</span>(tmp !=cur){
                <span class="keyword">while</span>(tmp !=cur){
                    int tmpvalue=tmp.<span class="keyword">val</span>;
                    tmp.<span class="keyword">val</span>=cur.<span class="keyword">val</span>;
                    cur.<span class="keyword">val</span>=tmpvalue;
                    tmp=tmp.next;
                }
            }
            cur =cur.next;
        }
        <span class="keyword">return</span> head;
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Sort List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/sortlist/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/数据结构与算法/LeetCode/sortlist/</id>
    <published>2014-05-22T05:48:29.000Z</published>
    <updated>2014-05-22T06:16:19.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Sort <span class="operator">a</span> linked list <span class="operator">in</span> O(n <span class="built_in">log</span> n) <span class="built_in">time</span> <span class="keyword">using</span> <span class="built_in">constant</span> <span class="constant">space</span> complexity.
</code></pre><p>题目要求时间复杂度是O(n log n) ,想到了快排和归并，但是链表对于快排来说，交换次数太多，可以采用归并排序，但需要额外空间O(n)</p>
<p>归并排序：其的基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？</p>
<p>可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。</p>
<p>解法参考 <a href="http://www.programcreek.com/2012/11/leetcode-solution-merge-sort-linkedlist-in-java/" target="_blank">http://www.programcreek.com/2012/11/leetcode-solution-merge-sort-linkedlist-in-java/</a></p>
<h4 id="解法">解法</h4>
<pre><code>class ListNode{
    <span class="keyword">int</span> val;
    ListNode next;
    ListNode(<span class="keyword">int</span> x){
        val=x;
        next=<span class="keyword">null</span>;
    }
}
<span class="keyword">public</span> <span class="keyword">class</span> SortLinkedList {
    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeSortList</span>(ListNode head){
            <span class="keyword">if</span>(head ==<span class="keyword">null</span> ||head.next ==<span class="keyword">null</span>)
                <span class="keyword">return</span> head;
            <span class="comment">//计算链表节点数</span>
            <span class="keyword">int</span> count=<span class="number">0</span>;
            ListNode p=head;
            <span class="keyword">while</span>(p!=<span class="keyword">null</span>){
                count++;
                p=p.next;
            }
            <span class="comment">//将链表一分为2</span>
            <span class="keyword">int</span> middle =count/<span class="number">2</span>;
            ListNode l=head,r=<span class="keyword">null</span>;
            ListNode p2=head;
            <span class="keyword">int</span> countHalf =<span class="number">0</span>;
            <span class="keyword">while</span>(p2 !=<span class="keyword">null</span>){
                countHalf++;
                ListNode next=p2.next;
                <span class="keyword">if</span>(countHalf ==middle){
                    p2.next=<span class="keyword">null</span>;<span class="comment">//左区尾节点为空</span>
                    r = next;
                }
                p2=next;
            }
            <span class="comment">//part l and part r ,循环排序</span>
            ListNode h1 = mergeSortList(l);
            ListNode h2 = mergeSortList(r);
            <span class="comment">//归并</span>
            ListNode merged = merge(h1,h2);
            <span class="keyword">return</span> merged;
    }

    <span class="keyword">public</span>  <span class="keyword">static</span> ListNode <span class="title">merge</span>(ListNode h1, ListNode h2) {
        ListNode p1=h1;
        ListNode p2=h2;
        ListNode fakeHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);
        ListNode pNew =fakeHead;
        <span class="keyword">while</span>(p1!=<span class="keyword">null</span>||p2!=<span class="keyword">null</span>){
            <span class="keyword">if</span>(p1 ==<span class="keyword">null</span>){
                pNew.next =<span class="keyword">new</span> ListNode(p2.val);
                p2=p2.next;
                pNew = pNew.next;
            }<span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="keyword">null</span>) {
                pNew.next = <span class="keyword">new</span> ListNode(p1.val);
                p1 = p1.next;
                pNew = pNew.next;
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (p1.val &lt; p2.val) {
                    pNew.next = <span class="keyword">new</span> ListNode(p1.val);
                    p1 = p1.next;
                    pNew = pNew.next;    
                } <span class="keyword">else</span> <span class="keyword">if</span> (p1.val == p2.val) {
                    pNew.next = <span class="keyword">new</span> ListNode(p1.val);
                    pNew.next.next = <span class="keyword">new</span> ListNode(p1.val);
                    pNew = pNew.next.next;
                    p1 = p1.next;
                    p2 = p2.next;

                } <span class="keyword">else</span> {
                    pNew.next = <span class="keyword">new</span> ListNode(p2.val);
                    p2 = p2.next;
                    pNew = pNew.next;
                }
            }
        }

        <span class="comment">// printList(fakeHead.next);</span>
        <span class="keyword">return</span> fakeHead.next;
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        ListNode n1 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);
        ListNode n2 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);
        ListNode n3 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);

        ListNode n4 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);
        ListNode n5 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);
        ListNode n6 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);

        n1.next = n2;
        n2.next = n3;
        n3.next = n4;
        n4.next = n5;
        n5.next = n6;

        n1 = mergeSortList(n1);

        printList(n1);
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span>(ListNode x) {
        <span class="keyword">if</span>(x != <span class="keyword">null</span>){
            System.<span class="keyword">out</span>.print(x.val + <span class="string">" "</span>);
            <span class="keyword">while</span> (x.next != <span class="keyword">null</span>) {
                System.<span class="keyword">out</span>.print(x.next.val + <span class="string">" "</span>);
                x = x.next;
            }
            System.<span class="keyword">out</span>.println();
        }

    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Max Points on a Line]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/maxpoints/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/数据结构与算法/LeetCode/maxpoints/</id>
    <published>2014-05-21T12:56:43.000Z</published>
    <updated>2014-05-22T05:49:56.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Max Points <span class="function_start"><span class="keyword">on</span></span> a Line Total 

Given n points <span class="function_start"><span class="keyword">on</span></span> a <span class="number">2</span>D plane, find <span class="keyword">the</span> maximum <span class="type">number</span> <span class="keyword">of</span> points <span class="keyword">that</span> lie <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> same straight line.
</code></pre><p>计算同一直线上最多的点数，思路：枚举+计算斜率，map存(斜率，点数)</p>
<h4 id="解法">解法</h4>
<pre><code>import java.util.HashMap;
import java.util.Map;

class Point {
     <span class="keyword">int</span> x;
     <span class="keyword">int</span> y;
     Point() { x = <span class="number">0</span>; y = <span class="number">0</span>; }
     Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b) { x = a; y = b; }
 }
<span class="comment">//枚举，计算斜率，注意重复的点</span>
<span class="keyword">public</span> <span class="keyword">class</span> test {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoints</span>(Point[] points){
        <span class="keyword">int</span> maxPoints = <span class="number">0</span>;
        <span class="keyword">int</span> curPoints = <span class="number">0</span>;
        <span class="keyword">int</span> samePoint = <span class="number">0</span>;
        <span class="keyword">double</span> slope = <span class="number">0</span>;
        <span class="comment">//map&lt;slope,curPoints&gt;</span>
        Map&lt;Double ,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Double,Integer&gt;();
        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;points.length;++i){
            curPoints = <span class="number">1</span>;
            samePoint = <span class="number">0</span>;
            map.clear();
            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;points.length;++j){
                <span class="comment">//same point</span>
                <span class="keyword">if</span>(points[j].x==points[i].x&amp;&amp;points[j].y==points[i].y){
                    ++samePoint;
                }<span class="keyword">else</span>{
                    <span class="comment">//如果两点X坐标相同，斜率无穷大</span>
                    <span class="keyword">if</span>(points[j].x != points[i].x){
                        <span class="comment">//注意0除以负数，得-0.0  计算器补码运算，所以为保持斜率一致，</span>
                        <span class="comment">//后面加上0.0，防止出现-0.0</span>
                        slope = <span class="number">1.0</span>*(points[j].y-points[i].y)/(points[j].x-points[i].x)+<span class="number">0.0</span>;
                    }<span class="keyword">else</span>{
                        slope = Double.MAX_VALUE;
                    }
                    <span class="keyword">if</span>(map.containsKey(slope)){
                        map.put(slope, map.<span class="keyword">get</span>(slope)+<span class="number">1</span>);
                    }<span class="keyword">else</span> {
                        map.put(slope, <span class="number">2</span>);
                    }
                    <span class="comment">//暂时计算当前在一条线的最多的点的个数</span>
                    <span class="keyword">if</span>(map.<span class="keyword">get</span>(slope)&gt;curPoints){
                        curPoints =map.<span class="keyword">get</span>(slope);
                    }
                }
            }
            curPoints +=samePoint;
            <span class="keyword">if</span>(curPoints &gt;maxPoints){
                maxPoints = curPoints;
            }
        }
        <span class="keyword">return</span> maxPoints;
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        Point[] points =<span class="keyword">new</span> Point[]{<span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>),<span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">3</span>),<span class="keyword">new</span> Point(-<span class="number">5</span>,<span class="number">3</span>)};
        System.<span class="keyword">out</span>.println(maxPoints(points));
    <span class="comment">//    System.out.println(1.0*(3-3)/(-3-3)+0.0);</span>
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Evaluate Reverse Polish Notation]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/polishnotation/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/数据结构与算法/LeetCode/polishnotation/</id>
    <published>2014-05-21T12:55:41.000Z</published>
    <updated>2014-05-22T05:49:58.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Evaluate the value <span class="keyword">of</span> an arithmetic expression <span class="keyword">in</span> Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer <span class="keyword">or</span> another expression.

Some <span class="attribute">examples</span>:
  [<span class="string">"2"</span>, <span class="string">"1"</span>, <span class="string">"+"</span>, <span class="string">"3"</span>, <span class="string">"*"</span>]<span class="function"> -&gt;</span> <span class="function"><span class="params">((<span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span>)</span> -&gt;</span> <span class="number">9</span>
  [<span class="string">"4"</span>, <span class="string">"13"</span>, <span class="string">"5"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>]<span class="function"> -&gt;</span> <span class="function"><span class="params">(<span class="number">4</span> + (<span class="number">13</span> / <span class="number">5</span>))</span> -&gt;</span> <span class="number">6</span>
</code></pre><p>波兰表达式，用栈就OK了</p>
<h4 id="解法">解法</h4>
<pre><code>import java.util.Stack;
<span class="comment">//波兰表达式 用栈不解释</span>
<span class="keyword">public</span> <span class="keyword">class</span> test {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]){
        String[] tokens =<span class="keyword">new</span> String[]{<span class="string">"4"</span>, <span class="string">"13"</span>, <span class="string">"5"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>};
        System.<span class="keyword">out</span>.println(evalRPN(tokens));
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span>(String[] tokens){
        String operators =<span class="string">"+-*/"</span>;
        Stack&lt;String&gt; s = <span class="keyword">new</span> Stack&lt;String&gt;();
        <span class="keyword">for</span>(String str : tokens){
            <span class="keyword">if</span>(operators.contains(str)){
                <span class="keyword">int</span> num2 = Integer.valueOf(s.pop());
                <span class="keyword">int</span> num1 = Integer.valueOf(s.pop());
                <span class="keyword">int</span> index = operators.indexOf(str);
                <span class="keyword">switch</span>(index){
                <span class="keyword">case</span> <span class="number">0</span>:
                    s.push(String.valueOf(num1+num2));
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> <span class="number">1</span>:
                    s.push(String.valueOf(num1-num2));
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> <span class="number">2</span>:
                    s.push(String.valueOf(num1*num2));
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> <span class="number">3</span>:
                    s.push(String.valueOf(num1/num2));
                    <span class="keyword">break</span>;
                }
            }<span class="keyword">else</span>{
                s.push(str);
            }
        }
        <span class="keyword">return</span> Integer.valueOf(s.pop());
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Reverse Words in a String]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/reversewords/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/数据结构与算法/LeetCode/reversewords/</id>
    <published>2014-05-21T10:01:31.000Z</published>
    <updated>2014-05-22T05:50:00.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">an</span> input <span class="keyword">string</span>, reverse <span class="operator">the</span> <span class="keyword">string</span> <span class="built_in">word</span> <span class="keyword">by</span> <span class="built_in">word</span>.
For example,
Given s = <span class="string">"the sky is blue"</span>,
<span class="constant">return</span> <span class="string">"blue is sky the"</span>.
</code></pre><p>一道反转字符串的题，可以用栈实现，也可以利用字符串的split方法进行分割字符串后处理</p>
<p>输入情况较多 ： 易遗漏” “ </p>
<h4 id="解法">解法</h4>
<pre><code>    <span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseWords</span>(String s){
        <span class="comment">//判断字符串是否为空</span>
        <span class="keyword">if</span>(s == <span class="keyword">null</span> ||s.length()==<span class="number">0</span>){
            <span class="keyword">return</span> <span class="string">""</span>;
        }
        <span class="comment">//以空格分割单词</span>
        String[] list=s.split(<span class="string">" "</span>);
        StringBuffer sb =<span class="keyword">new</span> StringBuffer();
        <span class="keyword">for</span>(<span class="keyword">int</span> i=list.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i){
            <span class="keyword">if</span>(!list[i].equals(<span class="string">""</span>)){
                sb.append(list[i]).append(<span class="string">" "</span>);
            }
        }
        <span class="comment">//考虑到" "的输入</span>
        <span class="keyword">return</span> sb.length() == <span class="number">0</span>? <span class="string">""</span>:sb.substring(<span class="number">0</span>, sb.length()-<span class="number">1</span>);
    }
    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        String s=<span class="string">"the sky   is blue"</span>;
        String d=reverseWords(s);
    }
}
</code></pre><p>注：split(“ “)单词之间有多个空格时，则认为空格之间为空,即list的元素为空””</p>
<p>str＝str.substring(int beginIndex);截取掉str从首字母起长度为beginIndex的字符串，将剩余字符串赋值给str；</p>
<p>str＝str.substring(int beginIndex，int endIndex);截取str中从beginIndex开始至endIndex结束时的字符串，并将其赋值给str;</p>
]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java的IO总结]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/Java/java_io/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/Java/java_io/</id>
    <published>2014-05-21T05:20:59.000Z</published>
    <updated>2014-05-21T06:12:36.000Z</updated>
    <content type="html"><![CDATA[<h4 id="Java流有关的类或借口">Java流有关的类或借口</h4>
<p><img src="/img/Java/io/1.png" alt=" "></p>
<h4 id="Java流类图结构">Java流类图结构</h4>
<p><img src="/img/Java/io/2.jpg" alt=" "></p>
<h4 id="流的概念和作用">流的概念和作用</h4>
<p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p>
<h5 id="IO流的分类">IO流的分类</h5>
<ul>
<li>根据处理数据类型的不同分为：字符流和字节流</li>
<li>根据数据流向不同分为：输入流和输出流</li>
</ul>
<h6 id="字符流和字节流">字符流和字节流</h6>
<p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。<br>字节流和字符流的区别：</p>
<ul>
<li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>
<li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li>
<li>缓冲区的使用：字节流在操作的时候本身是不会用到缓冲区的，是文件本身的直接操作的，但是字符流在操作的时候下后是会用到缓冲区的，是通过缓冲区来操作文件的。</li>
</ul>
<p>使用字节流好还是字符流好呢？</p>
<p>答案是字节流。首先因为硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符只是在内存中才会形成的，所以在开发中，字节流使用广泛。</p>
<h6 id="输入流和输出流">输入流和输出流</h6>
<p>对输入流只能进行读操作，对输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。 </p>
<h4 id="案例（写了很少，慢慢补充）">案例（写了很少，慢慢补充）</h4>
<h6 id="File类的两个常量">File类的两个常量</h6>
<pre><code><span class="keyword">File</span>.separator 代表 \
<span class="keyword">File</span>.pathSeparator 代表 ，
多使用它们俩，方便跨平台写路径名
</code></pre><h6 id="创建一个新文件">创建一个新文件</h6>
<pre><code><span class="keyword">package</span> com.liu.io;

<span class="keyword">import</span> java.io.File;
<span class="comment">//创建一个新文件</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> {</span>
<span class="comment">/*    public static void main(String[] args){
        File f =new File("D:\\hello.txt");
        try{
            f.createNewFile();
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
*/</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;
        File f =<span class="keyword">new</span> File(fileName);
        <span class="keyword">try</span>{
            f.createNewFile();
        }<span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h6 id="删除一个文件">删除一个文件</h6>
<pre><code>package com.liu.io;

import java.io.File;

<span class="comment">//删除一个文件</span>
<span class="keyword">public</span> <span class="keyword">class</span> test03 {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;
        File f=<span class="keyword">new</span> File(fileName);
        <span class="keyword">if</span>(f.exists()){
            f.delete();
        }<span class="keyword">else</span>{
            System.<span class="keyword">out</span>.println(<span class="string">"文件不存在"</span>);
        }
    }

}
</code></pre><h6 id="创建一个文件夹及遍历目录">创建一个文件夹及遍历目录</h6>
<pre><code>package com.liu.io;

import java.io.File;


<span class="keyword">public</span> <span class="keyword">class</span> test04 {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
    <span class="comment">//创建一个文件夹         </span>
    /*        String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello"</span>;
            File f=<span class="keyword">new</span> File(fileName);
            f.mkdir();
    */
    <span class="comment">//列出指定目录的全部文件（包括隐藏文件）</span>
    /*    String fileName=<span class="string">"D:"</span>+File.separator;
        File f=<span class="keyword">new</span> File(fileName);
        String[] str=f.list();
        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; str.length; i++) {
            System.out.println(str[i]);
        }
    */
    <span class="comment">//列出指定目录的全部文件（包括隐藏文件） 完整路径    </span>
    /*     String fileName=<span class="string">"D:"</span>+File.separator;
            File f=<span class="keyword">new</span> File(fileName);
            File[] str=f.listFiles();
            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; str.length; i++) {
                System.out.println(str[i]);
            }
    */    
    <span class="comment">//    判断一个指定的路径是否为目录</span>
    /*    String fileName=<span class="string">"D:"</span>+File.separator;
        File f=<span class="keyword">new</span> File(fileName);
        <span class="keyword">if</span>(f.isDirectory()){
            System.out.println(<span class="string">"YES"</span>);
        }<span class="keyword">else</span>{
            System.out.println(<span class="string">"NO"</span>);
        }
    */
    <span class="comment">//搜索指定目录的全部内容</span>
        String fileName=<span class="string">"D:"</span>+File.separator;
        File f=<span class="keyword">new</span> File(fileName);
        print(f);
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> print(File f){
        <span class="keyword">if</span>(f!=<span class="keyword">null</span>){
            <span class="keyword">if</span>(f.isDirectory()){
                File[] fileArray=f.listFiles();
                <span class="keyword">if</span>(fileArray!=<span class="keyword">null</span>){
                    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; fileArray.length; i++) {
                        <span class="comment">//递归调用</span>
                        print(fileArray[i]);
                    }
                }
            }
            <span class="keyword">else</span>{
                System.out.println(f);
            }
        }
    }
}
</code></pre><h6 id="使用RandomAccessFile写入文件">使用RandomAccessFile写入文件</h6>
<pre><code><span class="keyword">package</span> com.liu.io;

<span class="keyword">import</span> java.io.*;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test05</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> IOException {
        <span class="comment">//使用RandomAccessFile写入文件</span>
        String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;
        File f=<span class="keyword">new</span> File(fileName);
        RandomAccessFile demo = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
            demo = <span class="keyword">new</span> RandomAccessFile(f,<span class="string">"rw"</span>);
        } <span class="keyword">catch</span> (FileNotFoundException e) {
            e.printStackTrace();
        }
        demo.writeBytes(<span class="string">"asdsad"</span>);
        <span class="comment">//demo.writeInt(12);</span>
        <span class="comment">//demo.writeBoolean(true);</span>
        <span class="comment">//demo.writeChar('A');</span>
        <span class="comment">//demo.writeFloat(1.21f);</span>
        <span class="comment">//demo.writeDouble(12.123);</span>
        <span class="comment">//demo.close();</span>

    }

}
</code></pre><h6 id="字节流">字节流</h6>
<pre><code>package com.liu.io;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

<span class="comment">//字节流</span>
<span class="keyword">public</span> <span class="keyword">class</span> test06 {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)throws IOException {
           String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;
           File f=<span class="keyword">new</span> File(fileName);
           <span class="comment">// 向文件中写入字符串</span>
      /*    OutputStream out =<span class="keyword">new</span> FileOutputStream(f);
           String str=<span class="string">"你好"</span>;
           byte[] b=str.getBytes();
           out.write(b);
           out.close();
       */    

           <span class="comment">//向文件中追加新内容</span>
       /*   OutputStream out =<span class="keyword">new</span> FileOutputStream(f,<span class="keyword">true</span>);
           String str=<span class="string">"haha"</span>;
           byte[]b =str.getBytes();
           <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;b.length;i++){
               out.write(b[i]);
           }
           out.close();
         */

           <span class="comment">//读文件内容</span>
     /*      InputStream <span class="keyword">in</span> =<span class="keyword">new</span> FileInputStream(f);
           <span class="comment">//byte[] b=new byte[1024];</span>
           byte[] b=<span class="keyword">new</span> byte[(int)f.length()];
           <span class="comment">//如果直接用 in.read(b) 会读取大量空格</span>
            int len=<span class="keyword">in</span>.read(b);
            <span class="keyword">in</span>.close();
            System.out.println(<span class="string">"读入长度为："</span>+len);
            System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,len));
       */

           <span class="comment">//一个一个字节读</span>
    /*       InputStream <span class="keyword">in</span>=<span class="keyword">new</span> FileInputStream(f);
            byte[] b=<span class="keyword">new</span> byte[(int)f.length()];
            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; b.length; i++) {
                b[i]=(byte)<span class="keyword">in</span>.read();
            }
            <span class="keyword">in</span>.close();
            System.out.println(<span class="keyword">new</span> String(b));
    */

           <span class="comment">//判断是否独到文件的末尾</span>
           InputStream <span class="keyword">in</span>=<span class="keyword">new</span> FileInputStream(f);
            byte[] b=<span class="keyword">new</span> byte[<span class="number">1024</span>];
            int count =<span class="number">0</span>;
            int temp=<span class="number">0</span>;
            <span class="keyword">while</span>((temp=<span class="keyword">in</span>.read())!=(-<span class="number">1</span>)){
                b[count++]=(byte)temp;
            }
            <span class="keyword">in</span>.close();
            System.out.println(<span class="keyword">new</span> String(b));
    }
}
</code></pre><h6 id="字符流">字符流</h6>
<pre><code><span class="keyword">package</span> com.liu.io;
<span class="comment">//字符流</span>
<span class="keyword">import</span> java.io.File;
<span class="keyword">import</span> java.io.FileReader;
<span class="keyword">import</span> java.io.FileWriter;
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.io.Reader;
<span class="keyword">import</span> java.io.Writer;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test07</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> IOException {
        String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;
        File f=<span class="keyword">new</span> File(fileName);
        <span class="comment">//写入数据</span>
  <span class="comment">/*      //追加内容
        Writer out =new FileWriter(f,true);
       // Writer out =new FileWriter(f);
        String str="hello";
        out.write(str);
        out.close();
    */</span>
        <span class="comment">//读内容</span>
        <span class="keyword">char</span>[] ch =<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];
        Reader read=<span class="keyword">new</span> FileReader(f);
        <span class="keyword">int</span> temp=<span class="number">0</span>;
        <span class="keyword">int</span> count=<span class="number">0</span>;
        <span class="keyword">while</span>((temp=read.read())!=(-<span class="number">1</span>)){
            ch[count++]=(<span class="keyword">char</span>)temp;
        }
        read.close();
        System.out.println(<span class="string">"内容为"</span>+<span class="keyword">new</span> String(ch,<span class="number">0</span>,count));
    }
}
</code></pre><p>下面例子总结摘自网上</p>
<h6 id="OutputStreramWriter_和InputStreamReader类">OutputStreramWriter 和InputStreamReader类</h6>
<pre><code>OutputStreramWriter将输出的字符流转化为字节流
InputStreamReader将输入的字节流转换为字符流
但是不管如何操作，最后都是以字节的形式保存在文件中的。
<span class="javadoc">/**
 * 将字节输出流转化为字符输出流
 * */</span>
<span class="keyword">import</span> java.io.*;
class hello{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> IOException {
        String fileName= <span class="string">"d:"</span>+File.separator+<span class="string">"hello.txt"</span>;
        File file=<span class="keyword">new</span> File(fileName);
        Writer out=<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file));
        out.write(<span class="string">"hello"</span>);
        out.close();
    }
}
<span class="javadoc">/**
 * 将字节输入流变为字符输入流
 * */</span>
<span class="keyword">import</span> java.io.*;
class hello{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> IOException {
        String fileName= <span class="string">"d:"</span>+File.separator+<span class="string">"hello.txt"</span>;
        File file=<span class="keyword">new</span> File(fileName);
        Reader read=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file));
        <span class="keyword">char</span>[] b=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];
        <span class="keyword">int</span> len=read.read(b);
        System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,len));
        read.close();
    }
}
</code></pre>]]></content>
    
    
      <category term="Java" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/Java/"/>
    
      <category term="Java" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程总结]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/Java/java_thread/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/Java/java_thread/</id>
    <published>2014-05-21T03:48:20.000Z</published>
    <updated>2014-05-21T05:13:53.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一个线程的生命期">一个线程的生命期</h4>
<p>线程经过其生命周期的各个阶段。下图显示了一个线程完整的生命周期。</p>
<p><img src="/img/Java/java_thread.jpg" alt="线程的生命期"></p>
<ul>
<li>新状态: 一个新产生的线程从新状态开始了它的生命周期。它保持这个状态知道程序start这个线程。</li>
<li>运行状态:当一个新状态的线程被start以后，线程就变成可运行状态，一个线程在此状态下被认为是开始执行其任务</li>
<li>就绪状态:当一个线程等待另外一个线程执行一个任务的时候，该线程就进入就绪状态。当另一个线程给就绪状态的线程发送信号时，该线程才重新切换到运行状态。</li>
<li>休眠状态: 由于一个线程的时间片用完了，该线程从运行状态进入休眠状态。当时间间隔到期或者等待的时间发生了，该状态的线程切换到运行状态。</li>
<li>终止状态: 一个运行状态的线程完成任务或者其他终止条件发生，该线程就切换到终止状态。</li>
</ul>
<h4 id="线程的优先级">线程的优先级</h4>
<p>每一个Java线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java优先级在MIN_PRIORITY（1）和MAX_PRIORITY（10）之间的范围内。默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY（5）。具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器时间。然而，线程优先级不能保证线程执行的顺序，而且非常依赖于平台.</p>
<h4 id="创建一个线程">创建一个线程</h4>
<p>Java提供了两种创建线程方法：</p>
<ul>
<li>通过实现Runable接口</li>
<li>通过继承Thread类本身</li>
</ul>
<h5 id="直接继承Thread的类">直接继承Thread的类</h5>
<pre><code><span class="keyword">package</span> com.liu.test;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>  <span class="keyword">extends</span> <span class="title">Thread</span>{</span>
    <span class="keyword">private</span> String name;
    <span class="keyword">public</span> <span class="title">MyThread</span>(){
    }
    <span class="keyword">public</span> <span class="title">MyThread</span>(String name){
        <span class="keyword">this</span>.name=name;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++){
            System.out.println(name+<span class="string">"运行  "</span>+i);
        }
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        MyThread h1=<span class="keyword">new</span> MyThread(<span class="string">"A"</span>);
        MyThread h2=<span class="keyword">new</span> MyThread(<span class="string">"B"</span>);
        h1.start();
        h2.start();
    }
}
</code></pre><h5 id="通过实现Runable接口">通过实现Runable接口</h5>
<pre><code>package com.liu.test;
 <span class="class"><span class="keyword">class</span> <span class="title">MyThread02</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">Runnable</span> {</span>
     <span class="keyword">private</span> String name;

     <span class="keyword">public</span> MyThread02(){

     }

     <span class="keyword">public</span> MyThread02(String name){
         <span class="keyword">this</span>.name=name;
     }

    @Override
    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        <span class="comment">// TODO Auto-generated method stub</span>
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++){
            System.out.println(name+<span class="string">"运行"</span>+i);
        }
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args){
        MyThread02 h1 =<span class="keyword">new</span> MyThread02(<span class="string">"A"</span>);
        MyThread02 h2 =<span class="keyword">new</span> MyThread02(<span class="string">"B"</span>);
        Thread s1=<span class="keyword">new</span> Thread(h1);
        Thread s2=<span class="keyword">new</span> Thread(h2);
        s1.start();
        s2.start();
    }

}
</code></pre><h4 id="实现Runnable接口比继承Thread类所具有的优势">实现Runnable接口比继承Thread类所具有的优势</h4>
<ul>
<li>适合多个相同的程序代码的线程去处理同一个资源</li>
<li>可以避免java中的单继承的限制</li>
<li>增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。    </li>
</ul>
<h4 id="线程同步">线程同步</h4>
<p>所谓同步就是在统一时间段中只有有一个线程运行，其他的线程必须等到这个线程结束之后才能继续执行。采用同步的话，可以使用同步代码块和同步方法两种来完成。</p>
<pre><code><span class="keyword">package</span> com.liu.synchronize;
<span class="comment">//采用同步的话，可以使用同步代码块和同步方法两种来完成。</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span>{</span>
    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">5</span>;
    <span class="comment">//同步代码块</span>
<span class="comment">/*    public void run() {
        for (int i=0;i&lt;10;i++){
            synchronized (this){
                if(count&gt;0){
                    try{
                        Thread.sleep(1000);
                    }catch (Exception e) {
                        e.printStackTrace();
                    }
                    System.out.println(count--);
                }
            }
        }
    }
    */</span>
    <span class="comment">//同步方法</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {
            sale();
        }
    }
    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span>() {
        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">1000</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(count--);
        }
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        test t1 =<span class="keyword">new</span> test();
        Thread h1 =<span class="keyword">new</span> Thread(t1);
        Thread h2 =<span class="keyword">new</span> Thread(t1);
        Thread h3 =<span class="keyword">new</span> Thread(t1);
        h1.start();
        h2.start();
        h3.start();
    }


}
</code></pre><h4 id="经典问题_生产者与消费者">经典问题 生产者与消费者</h4>
<pre><code><span class="comment">/**
 * 生产者生产商品放到容器中，容器有一定的容量（只能顺序放，先放后拿），
 * 消费者消费商品，当容器满了后，生产者等待，当容器为空时，消费者等待。
 * 当生产者将商品放入容器后，通知消费者；当消费者拿走商品后，通知生产者。
 */</span>

package com.liu.consumerproducer;

<span class="class"><span class="keyword">class</span> <span class="title">Goods</span>{</span>
    <span class="keyword">int</span> id;
    <span class="keyword">public</span> Goods(<span class="keyword">int</span> id){
        <span class="keyword">this</span>.id=id;
    }
    <span class="keyword">public</span> String toString(){
        <span class="keyword">return</span> <span class="string">"商品"</span>+<span class="keyword">this</span>.id;
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Container</span>{</span>
    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">index</span>=<span class="number">0</span>;
    Goods[] goods =<span class="keyword">new</span> Goods[<span class="number">6</span>];
    <span class="keyword">public</span> synchronized <span class="keyword">void</span> push(Goods good){
        <span class="keyword">while</span> (<span class="keyword">index</span>==goods.length){
            <span class="comment">//容器满了，生产者等待</span>
            <span class="keyword">try</span> {
                wait();
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
        }
        goods[<span class="keyword">index</span>]=good;
        <span class="keyword">index</span>++;
        notifyAll();<span class="comment">//当生产者放入商品后通知消费者</span>
    }
     <span class="keyword">public</span> synchronized Goods pop(){
            <span class="keyword">while</span>(<span class="keyword">index</span>==<span class="number">0</span>){<span class="comment">//当容器内没有商品消费者等待</span>
                <span class="keyword">try</span> {
                    wait();
                } <span class="keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            <span class="keyword">index</span>--;
            notifyAll();<span class="comment">//当消费者消费了商品后通知生产者</span>
            <span class="keyword">return</span> goods[<span class="keyword">index</span>];
        }
}

<span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">Runnable</span>{</span>

    Container con =<span class="keyword">new</span> Container();
    <span class="keyword">public</span> Producer(Container con) {
        <span class="keyword">this</span>.con=con;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++){
            Goods good=<span class="keyword">new</span> Goods(i);
            con.push(good);
            System.out.println(<span class="string">"生产了："</span>+good);
        }
        <span class="keyword">try</span> {
            Thread.sleep(<span class="number">1000</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">Runnable</span>{</span>

    Container con = <span class="keyword">new</span> Container();
    <span class="keyword">public</span> Consumer(Container con){
        <span class="keyword">this</span>.con=con;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> run(){
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++){
            Goods good=con.pop();
            System.out.println(<span class="string">"消费了："</span>+good);
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">1000</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                <span class="comment">// TODO Auto-generated catch block</span>
                e.printStackTrace();
            }
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
        Container con =<span class="keyword">new</span> Container();
        Producer p =<span class="keyword">new</span> Producer(con);
        Consumer c = <span class="keyword">new</span> Consumer(con);
        <span class="keyword">new</span> Thread(p).start();
        <span class="keyword">new</span> Thread(c).start();
    }

}
</code></pre>]]></content>
    
    
      <category term="Java" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/Java/"/>
    
      <category term="Java" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vmstat iostat top sar总结]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/Linux/linux_%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/Linux/linux_性能监控/</id>
    <published>2014-05-21T02:30:30.000Z</published>
    <updated>2014-05-21T03:46:07.000Z</updated>
    <content type="html"><![CDATA[<h3 id="vmstat">vmstat</h3>
<p>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数</p>
<pre><code><span class="comment">root@localhost:~#</span> <span class="comment">vmstat</span> <span class="comment">2</span> <span class="comment">100</span>
<span class="comment">procs</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">memory</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">swap</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">io</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="comment">system</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">cpu</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
 <span class="comment">r</span>  <span class="comment">b</span>   <span class="comment">swpd</span>   <span class="comment">free</span>   <span class="comment">buff</span>  <span class="comment">cache</span>   <span class="comment">si</span>   <span class="comment">so</span>    <span class="comment">bi</span>    <span class="comment">bo</span>   <span class="comment">in</span>   <span class="comment">cs</span> <span class="comment">us</span> <span class="comment">sy</span> <span class="comment">id</span> <span class="comment">wa</span>
 <span class="comment">1</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">3498472</span> <span class="comment">315836</span> <span class="comment">3819540</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">1</span>    <span class="comment">2</span>    <span class="comment">0</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>
 <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">3499584</span> <span class="comment">315836</span> <span class="comment">3819660</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">88</span>  <span class="comment">158</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>
 <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">3499708</span> <span class="comment">315836</span> <span class="comment">3819660</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">2</span>   <span class="comment">86</span>  <span class="comment">162</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>
 <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">3499708</span> <span class="comment">315836</span> <span class="comment">3819660</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>    <span class="comment">10</span>   <span class="comment">81</span>  <span class="comment">151</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>
 <span class="comment">1</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">3499732</span> <span class="comment">315836</span> <span class="comment">3819660</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">2</span>   <span class="comment">83</span>  <span class="comment">154</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>
</code></pre><h6 id="进程procs：">进程procs：</h6>
<p>r：在运行队列中等待的进程数(就是说多少个进程真的分配到CPU) 。当这个值超过了CPU数目，就会出现CPU瓶颈了</p>
<p>b：在等待io的进程数 。</p>
<h6 id="Linux_内存监控内存memoy：">Linux 内存监控内存memoy：</h6>
<p>swpd：现时可用的交换内存（单位KB）。 如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器</p>
<p>free：空闲的内存（单位KB）。</p>
<p>buff: 缓冲去中的内存数（单位：KB）。</p>
<p>cache：被用来做为高速缓存的内存数（单位：KB）。</p>
<h6 id="Linux_内存监控swap交换页面">Linux 内存监控swap交换页面</h6>
<p>si: 从磁盘交换到内存的交换页数量，单位：KB/秒。 如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉</p>
<p>so: 从内存交换到磁盘的交换页数量，单位：KB/秒。 如上</p>
<h6 id="Linux_内存监控_io块设备:">Linux 内存监控 io块设备:</h6>
<p>bi: 发送到块设备的块数，单位：块/秒。</p>
<p>bo: 从块设备接收到的块数，单位：块/秒。</p>
<h6 id="Linux_内存监控system系统：">Linux 内存监控system系统：</h6>
<p>in: 每秒的中断数，包括时钟中断。</p>
<p>cs: 每秒的环境（上下文）转换次数。例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。</p>
<h6 id="Linux_内存监控cpu中央处理器：">Linux 内存监控cpu中央处理器：</h6>
<p>us：用户进程使用的时间 。以百分比表示。</p>
<p>sy：系统进程使用的时间。 以百分比表示。如果太高，表示系统调用时间长，例如是IO操作频繁</p>
<p>id：中央处理器的空闲时间 。以百分比表示。一般来说，id + us + sy = 100,一般认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率</p>
<p>wa 等待IO CPU时间</p>
<p>假如 r经常大于 4 ，且id经常小于40，表示中央处理器的负荷很重。 假如bi，bo 长期不等于0，表示物理内存容量太小。</p>
<h3 id="iostat">iostat</h3>
<p>个人常用iostat -x 1每一秒输出IO信息，-x能让你看到更多信息</p>
<pre><code><span class="variable">$iostat</span> -<span class="keyword">x</span> <span class="number">1</span>
Linux <span class="number">2.6</span>.<span class="number">33</span>-fukai (fukai-laptop)          _i686<span class="number">_</span>    (<span class="number">2</span> CPU)
avg-cpu:  <span class="variable">%user</span>   <span class="variable">%nice</span> <span class="variable">%system</span> <span class="variable">%iowait</span>  <span class="variable">%steal</span>   <span class="variable">%idle</span>
           <span class="number">5.47</span>    <span class="number">0</span>.<span class="number">50</span>    <span class="number">8.96</span>   <span class="number">48.26</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">36.82</span>

Device:         rrqm/<span class="keyword">s</span>   wrqm/<span class="keyword">s</span>     r/<span class="keyword">s</span>     w/<span class="keyword">s</span>   rsec/<span class="keyword">s</span>   wsec/<span class="keyword">s</span> avgrq-sz avgqu-sz   await  svctm  <span class="variable">%util</span>
sda               <span class="number">6.00</span>   <span class="number">273.00</span>   <span class="number">99.00</span>    <span class="number">7.00</span>  <span class="number">2240.00</span>  <span class="number">2240.00</span>    <span class="number">42.26</span>     <span class="number">1.12</span>   <span class="number">10.57</span>   <span class="number">7.96</span>  <span class="number">84.40</span>
sdb               <span class="number">0</span>.<span class="number">00</span>     <span class="number">4.00</span>    <span class="number">0</span>.<span class="number">00</span>  <span class="number">350.00</span>     <span class="number">0</span>.<span class="number">00</span>  <span class="number">2068.00</span>     <span class="number">5.91</span>     <span class="number">0</span>.<span class="number">55</span>    <span class="number">1.58</span>   <span class="number">0</span>.<span class="number">54</span>  <span class="number">18.80</span>

rrqm/<span class="keyword">s</span>:  每秒进行 merge 的读操作数目.即 delta(rmerge)/<span class="keyword">s</span>
（当系统调用需要读取数据的时候，VFS（虚拟文件系统）将请求发到各个FS，如果FS发现不同的读取请求读取的是相同Block的数据，FS会将这个请求合并Merge）
wrqm/<span class="keyword">s</span>:  每秒进行 merge 的写操作数目.即 delta(wmerge)/<span class="keyword">s</span>
r/<span class="keyword">s</span>:     每秒完成的读 I/O 设备次数.即 delta(rio)/<span class="keyword">s</span>
w/<span class="keyword">s</span>:     每秒完成的写 I/O 设备次数.即 delta(wio)/<span class="keyword">s</span>
rsec/<span class="keyword">s</span>:  每秒读扇区数.即 delta(rsect)/<span class="keyword">s</span>
wsec/<span class="keyword">s</span>:  每秒写扇区数.即 delta(wsect)/<span class="keyword">s</span>
rkB/<span class="keyword">s</span>:   每秒读K字节数.是 rsect/<span class="keyword">s</span> 的一半,因为每扇区大小为<span class="number">512</span>字节.(需要计算)
wkB/<span class="keyword">s</span>:   每秒写K字节数.是 wsect/<span class="keyword">s</span> 的一半.(需要计算)
avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区).delta(rsect+wsect)/delta(rio+wio)
avgqu-sz: 平均I/O队列长度.即 delta(aveq)/<span class="regexp">s/1000 (因为aveq的单位为毫秒).
await:  平均每次设备I/O操作的等待时间 (毫秒).即 delta(ruse+wuse)/delta</span>(rio+wio)
svctm:  平均每次设备I/O操作的服务时间 (毫秒).即 delta(<span class="keyword">use</span>)/delta(rio+wio)
<span class="variable">%util</span>:  一秒中有百分之多少的时间用于 I/O 操作,或者说一秒中有多少时间 I/O 队列是非空的.即 delta(<span class="keyword">use</span>)/<span class="keyword">s</span>/<span class="number">1000</span> (因为<span class="keyword">use</span>的单位为毫秒)
</code></pre><p>如果 %util 接近 100%,说明产生的I/O请求太多,I/O系统已经满负荷,该磁盘可能存在瓶颈.idle小于70% IO压力就较大了,一般读取速度有较多的wait.同时可以结合vmstat 查看查看b参数(等待资源的进程数)和wa参数(IO等待所占用的CPU时间的百分比,高过30%时IO压力高)</p>
<p>另外 await 的参数也要多和 svctm 来参考.差的过高就一定有 IO 的问题.avgqu-sz 也是个做 IO 调优时需要注意的地方,这个就是直接每次操作的数据的大小,如果次数多,但数据拿的小的话,其实 IO 也会很小.如果数据拿的大,才IO 的数据会高.也可以通过 avgqu-sz × ( r/s or w/s ) = rsec/s or wsec/s.也就是讲,读定速度是这个来决定的.</p>
<h3 id="top">top</h3>
<p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况</p>
<pre><code>[root<span class="variable">@localhost</span> <span class="keyword">log</span>]<span class="comment"># top</span>
top - <span class="number">14</span>:<span class="number">06</span>:<span class="number">23</span> up <span class="number">70</span> days, <span class="number">16</span>:<span class="number">44</span>,  <span class="number">2</span> users,  load average: <span class="number">1.25</span>, <span class="number">1.32</span>, <span class="number">1.35</span>
Tasks: <span class="number">206</span> total,   <span class="number">1</span> running, <span class="number">205</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie
Cpu(<span class="keyword">s</span>):  <span class="number">5.9</span><span class="variable">%us</span>,  <span class="number">3.4</span><span class="variable">%sy</span>,  <span class="number">0</span>.<span class="number">0</span><span class="variable">%ni</span>, <span class="number">90.4</span><span class="variable">%id</span>,  <span class="number">0</span>.<span class="number">0</span><span class="variable">%wa</span>,  <span class="number">0</span>.<span class="number">0</span><span class="variable">%hi</span>,  <span class="number">0</span>.<span class="number">2</span><span class="variable">%si</span>,  <span class="number">0</span>.<span class="number">0</span><span class="variable">%st</span>
Mem:  <span class="number">32949016</span>k total, <span class="number">14411180</span>k used, <span class="number">18537836</span>k free,   <span class="number">169884</span>k buffers
Swap: <span class="number">32764556</span>k total,        0k used, <span class="number">32764556</span>k free,  <span class="number">3612636</span>k cached
  PID USER      PR  NI  VIRT  RES  SHR S <span class="variable">%CPU</span> <span class="variable">%MEM</span>    TIME+  COMMAND                                                                
<span class="number">28894</span> root      <span class="number">22</span>   <span class="number">0</span> <span class="number">1501</span><span class="keyword">m</span> <span class="number">405</span><span class="keyword">m</span>  <span class="number">10</span><span class="keyword">m</span> S <span class="number">52.2</span>  <span class="number">1.3</span>   <span class="number">2534</span>:<span class="number">16</span> java                                                                   
<span class="number">18249</span> root      <span class="number">18</span>   <span class="number">0</span> <span class="number">3201</span><span class="keyword">m</span> <span class="number">1.9</span>g  <span class="number">11</span><span class="keyword">m</span> S <span class="number">35.9</span>  <span class="number">6.0</span> <span class="number">569</span>:<span class="number">39.41</span> java                                                                   
 <span class="number">2808</span> root      <span class="number">25</span>   <span class="number">0</span> <span class="number">3333</span><span class="keyword">m</span> <span class="number">1.0</span>g  <span class="number">11</span><span class="keyword">m</span> S <span class="number">24.3</span>  <span class="number">3.1</span> <span class="number">526</span>:<span class="number">51.85</span> java                                                                   
<span class="number">25668</span> root      <span class="number">23</span>   <span class="number">0</span> <span class="number">3180</span><span class="keyword">m</span> <span class="number">704</span><span class="keyword">m</span>  <span class="number">11</span><span class="keyword">m</span> S <span class="number">14.0</span>  <span class="number">2.2</span> <span class="number">360</span>:<span class="number">44.53</span> java                                                                   
  <span class="number">574</span> root      <span class="number">25</span>   <span class="number">0</span> <span class="number">3168</span><span class="keyword">m</span> <span class="number">611</span><span class="keyword">m</span>  <span class="number">10</span><span class="keyword">m</span> S <span class="number">12.6</span>  <span class="number">1.9</span> <span class="number">556</span>:<span class="number">59.63</span> java                                                                   
 <span class="number">1599</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">3237</span><span class="keyword">m</span> <span class="number">1.9</span>g  <span class="number">11</span><span class="keyword">m</span> S <span class="number">12.3</span>  <span class="number">6.2</span> <span class="number">262</span>:<span class="number">01</span>.<span class="number">14</span> java                                                                   
 <span class="number">1008</span> root      <span class="number">21</span>   <span class="number">0</span> <span class="number">3147</span><span class="keyword">m</span> <span class="number">842</span><span class="keyword">m</span>  <span class="number">10</span><span class="keyword">m</span> S  <span class="number">0</span>.<span class="number">3</span>  <span class="number">2.6</span>   <span class="number">4</span>:<span class="number">31.08</span> java                                                                   
<span class="number">13823</span> root      <span class="number">23</span>   <span class="number">0</span> <span class="number">3031</span><span class="keyword">m</span> <span class="number">2.1</span>g  <span class="number">10</span><span class="keyword">m</span> S  <span class="number">0</span>.<span class="number">3</span>  <span class="number">6.8</span> <span class="number">176</span>:<span class="number">57.34</span> java                                                                   
<span class="number">28218</span> root      <span class="number">15</span>   <span class="number">0</span> <span class="number">12760</span> <span class="number">1168</span>  <span class="number">808</span> R  <span class="number">0</span>.<span class="number">3</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">01</span>.<span class="number">43</span> top                                                                    
<span class="number">29062</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">1241</span><span class="keyword">m</span> <span class="number">227</span><span class="keyword">m</span>  <span class="number">10</span><span class="keyword">m</span> S  <span class="number">0</span>.<span class="number">3</span>  <span class="number">0</span>.<span class="number">7</span>   <span class="number">2</span>:<span class="number">07</span>.<span class="number">32</span> java                                                                   
    <span class="number">1</span> root      <span class="number">15</span>   <span class="number">0</span> <span class="number">10368</span>  <span class="number">684</span>  <span class="number">572</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">1</span>:<span class="number">30.85</span> init                                                                   
    <span class="number">2</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">01</span>.<span class="number">01</span> migration/<span class="number">0</span>                                                            
    <span class="number">3</span> root      <span class="number">34</span>  <span class="number">19</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> ksoftirqd/<span class="number">0</span>                                                            
    <span class="number">4</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> watchdog/<span class="number">0</span>                                                             
    <span class="number">5</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">80</span> migration/<span class="number">1</span>                                                            
    <span class="number">6</span> root      <span class="number">34</span>  <span class="number">19</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> ksoftirqd/<span class="number">1</span>                                                            
    <span class="number">7</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> watchdog/<span class="number">1</span>                                                             
    <span class="number">8</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">20.59</span> migration/<span class="number">2</span>                                                            
    <span class="number">9</span> root      <span class="number">34</span>  <span class="number">19</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.09 ksoftirqd/<span class="number">2</span>                                                            
   <span class="number">10</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> watchdog/<span class="number">2</span>                                                             
   <span class="number">11</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">23.66</span> migration/<span class="number">3</span>                                                            
   <span class="number">12</span> root      <span class="number">34</span>  <span class="number">19</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">03</span> ksoftirqd/<span class="number">3</span>                                                            
   <span class="number">13</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> watchdog/<span class="number">3</span>                                                             
   <span class="number">14</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">20.29</span> migration/<span class="number">4</span>                                                            
   <span class="number">15</span> root      <span class="number">34</span>  <span class="number">19</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">07</span> ksoftirqd/<span class="number">4</span>                                                            
   <span class="number">16</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> watchdog/<span class="number">4</span>                                                             
   <span class="number">17</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">23.07</span> migration/<span class="number">5</span>                                                            
   <span class="number">18</span> root      <span class="number">34</span>  <span class="number">19</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">07</span> ksoftirqd/<span class="number">5</span>                                                            
   <span class="number">19</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> watchdog/<span class="number">5</span>                                                             
   <span class="number">20</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">17.16</span> migration/<span class="number">6</span>                                                            
   <span class="number">21</span> root      <span class="number">34</span>  <span class="number">19</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">05</span> ksoftirqd/<span class="number">6</span>                                                            
   <span class="number">22</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> watchdog/<span class="number">6</span>                                                             
   <span class="number">23</span> root      RT  -<span class="number">5</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>   <span class="number">0</span>:<span class="number">58.28</span> migration/<span class="number">7</span>
</code></pre><h6 id="统计信息区：">统计信息区：</h6>
<p>前五行是当前系统情况整体的统计信息区。下面我们看每一行信息的具体意义。</p>
<p>第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：</p>
<pre><code><span class="number">14</span>:<span class="number">06</span>:<span class="number">23</span> — 当前系统时间
up <span class="number">70</span> days, <span class="number">16</span>:<span class="number">44</span> — 系统已经运行了<span class="number">70</span>天<span class="number">16</span>小时<span class="number">44</span>分钟（在这期间系统没有重启过的吆！）
<span class="number">2</span> users — 当前有<span class="number">2</span>个用户登录系统
<span class="built_in">load</span> <span class="built_in">average</span>: <span class="number">1.15</span>, <span class="number">1.42</span>, <span class="number">1.44</span> — <span class="built_in">load</span> <span class="built_in">average</span>后面的三个数分别是<span class="number">1</span>分钟、<span class="number">5</span>分钟、<span class="number">15</span>分钟的负载情况。
<span class="built_in">load</span> <span class="built_in">average</span>数据是每隔<span class="number">5</span>秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。
如果这个数除以逻辑CPU的数量，结果高于<span class="number">5</span>的时候就表明系统在超负荷运转了。
</code></pre><p>第二行，Tasks — 任务（进程），具体信息说明如下：</p>
<p>系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p>
<p>第三行，cpu状态信息，具体属性说明如下：</p>
<pre><code><span class="number">5.9</span><span class="comment">%us — 用户空间占用CPU的百分比。</span>
<span class="number">3.4</span><span class="comment">% sy — 内核空间占用CPU的百分比。</span>
<span class="number">0.0</span><span class="comment">% ni — 改变过优先级的进程占用CPU的百分比</span>
<span class="number">90.4</span><span class="comment">% id — 空闲CPU百分比</span>
<span class="number">0.0</span><span class="comment">% wa — IO等待占用CPU的百分比</span>
<span class="number">0.0</span><span class="comment">% hi — 硬中断（Hardware IRQ）占用CPU的百分比</span>
<span class="number">0.2</span><span class="comment">% si — 软中断（Software Interrupts）占用CPU的百分比</span>
</code></pre><p>第四行,内存状态，具体信息如下：</p>
<pre><code><span class="number">32949016</span>k total — 物理内存总量（<span class="number">32</span>GB）
<span class="number">14411180</span>k used — 使用中的内存总量（<span class="number">14</span>GB）
<span class="number">18537836</span>k <span class="built_in">free</span> — 空闲内存总量（<span class="number">18</span>GB）
<span class="number">169884</span>k buffers — 缓存的内存量 （<span class="number">169</span>M）
</code></pre><p>第五行，swap交换分区信息，具体信息说明如下：</p>
<pre><code><span class="number">32764556</span>k total — 交换区总量（<span class="number">32</span>GB）
<span class="number">0</span>k used — 使用的交换区总量（<span class="number">0</span><span class="keyword">K</span>）
<span class="number">32764556</span>k free — 空闲交换区总量（<span class="number">32</span>GB）
<span class="number">3612636</span>k cached — 缓冲的交换区总量（<span class="number">3.6</span>GB）
</code></pre><p>备注：</p>
<p>如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存：18537836k +169884k +3612636k = 22GB左右。</p>
<p>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p>
<p>第六行，空行。</p>
<p>第七行以下：各进程（任务）的状态监控，项目列信息说明如下：</p>
<pre><code><span class="xml"><span class="tag"><span class="attribute">PID</span> — 进程<span class="attribute">id</span>
<span class="attribute">USER</span> — 进程所有者
<span class="attribute">PR</span> — 进程优先级
<span class="attribute">NI</span> — <span class="attribute">nice</span>值。负值表示高优先级，正值表示低优先级
<span class="attribute">VIRT</span> — 进程使用的虚拟内存总量，单位<span class="attribute">kb</span>。<span class="attribute">VIRT</span>=<span class="value">SWAP+RES</span>
<span class="attribute">RES</span> — 进程使用的、未被换出的物理内存大小，单位<span class="attribute">kb</span>。<span class="attribute">RES</span>=<span class="value">CODE+DATA</span>
<span class="attribute">SHR</span> — 共享内存大小，单位<span class="attribute">kb</span>
<span class="attribute">S</span> — 进程状态。<span class="attribute">D</span>=<span class="value">不可中断的睡眠状态</span> <span class="attribute">R</span>=<span class="value">运行</span> <span class="attribute">S</span>=<span class="value">睡眠</span> <span class="attribute">T</span>=<span class="value">跟踪</span>/停止 <span class="attribute">Z</span>=<span class="value">僵尸进程</span>
%<span class="attribute">CPU</span> — 上次更新到现在的<span class="attribute">CPU</span>时间占用百分比
%<span class="attribute">MEM</span> — 进程使用的物理内存百分比
<span class="attribute">TIME</span>+ — 进程使用的<span class="attribute">CPU</span>时间总计，单位<span class="attribute">1</span>/<span class="attribute">100</span>秒
<span class="attribute">COMMAND</span> — 进程名称（命令名/命令行）</span></span>
</code></pre><h3 id="sar">sar</h3>
<p>sar（System Activity Reporter）是系统活动情况报告的缩写。sar 工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据；取样数据和分析的结果都可以存入文件，所需的负载很小。 sar 是目前 Linux 上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：文件的读写情况、系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程活动及IPC有关的活动等。为了提供不同的信息，sar 提供了丰富的选项、因此使用较为复杂。</p>
<p>安装：</p>
<pre><code><span class="preprocessor"># yum install sysstat</span>
</code></pre><p>一般格式：</p>
<pre><code>sar [ options... ] [ <span class="tag">&lt;<span class="title">interval</span>&gt;</span> [ <span class="tag">&lt;<span class="title">count</span>&gt;</span> ] ]
</code></pre><p>常用选项：</p>
<pre><code>-<span class="ruby"><span class="constant">A</span> ：包括绝大多数选项。
</span>-<span class="ruby">b ：报告<span class="constant">I</span>/<span class="constant">O</span>和传输速率统计。
</span>-<span class="ruby"><span class="constant">B</span> ：报告分页统计。
</span>-<span class="ruby">c ：报告进程创建活动。
</span>-<span class="ruby">d ：报告每个活动的块设备。(指磁盘)
</span>-<span class="ruby">e [ <span class="symbol">hh:</span><span class="symbol">mm:</span>ss ] ：设置sar命令执行的结束时间，时间为<span class="number">24</span>小时制格式。
</span>-<span class="ruby"><span class="constant">I</span> { irq | <span class="constant">SUM</span> | <span class="constant">ALL</span> | <span class="constant">XALL</span> } ：报告给定中断的统计。
</span>-<span class="ruby">n { <span class="constant">DEV</span> | <span class="constant">EDEV</span> | <span class="constant">NFS</span> | <span class="constant">NFSD</span> | <span class="constant">SOCK</span> | <span class="constant">ALL</span> } ：报告网络统计。
</span>-<span class="ruby"><span class="constant">P</span> { cpu | <span class="constant">ALL</span> } ：报告每个处理器的统计信息，可以统计指定或全部处理器。
</span>-<span class="ruby">q ：报告队列长度和平均负载。
</span>-<span class="ruby">r ：报告内存和交换空间的利用情况统计。
</span>-<span class="ruby"><span class="constant">R</span> ：报告内存统计。
</span>-<span class="ruby">u ：报告<span class="constant">CPU</span>利用率。
</span>interval ：两次输出之间的间隔时间。
count ：按照这个时间间隔统计的次数。
</code></pre><p>举例：</p>
<pre><code># sar 5 10
查看CUP使用情况，每隔5秒统计一次，共打印10次。
<span class="tag">%<span class="title">user</span></span> ：CPU在用户使用下的时间百分比。
<span class="tag">%<span class="title">nice</span></span> ：CPU在优先级用户下的使用时间百分比。
<span class="tag">%<span class="title">system</span></span> ：CPU在系统使用下的时间百分比。
<span class="tag">%<span class="title">iowait</span></span> ：CPU等待磁盘I/O完成时间的百分比。
<span class="tag">%<span class="title">steal</span></span> ：虚拟机占用的时间百分比。
<span class="tag">%<span class="title">idle</span></span> ：CPU空闲时间百分比。
# sar -b 2 5
查看磁盘I/O和传输速率情况，每隔2秒统计一次，共打印5次。
tps ：每秒传送到物理设备的总数。
rtps ：每秒读取物理设备请求的总数。
wtps ：每秒写入到物理设备请求的总数。
bread/s ：每秒从块设备读取数据的速度。
bwrtn/s ：每秒向块设备写入数据的速度。
单位为块(block)，一块为512 bytes。
# sar -c
查看进程创建情况。
proc/s ：每秒进程创建数。
# sar -d 2 3
查看设备使用情况。
DEV ：磁盘设备。
tps ：每秒传送到设备的总数。
rd_sec/s ：每秒读取数。(一扇区为512 bytes)
wr_sec/s ：每秒写入数。(一扇区为512 bytes)
avgrq-sz ：设备扇区请求的平均大小。
avgqu-sz ：设备队列请求的平均大小。
await ：服务等待I/O请求的平均时间。(单位毫秒)
svctm ：设备处理I/O请求的平均时间。(单位毫秒)
<span class="tag">%<span class="title">util</span></span> ：向设备I/O请求期间的CPU时间的百分比。
# sar -n DEV
查看网络接口信息。
IFACE ：LAN接口。
rxpck/s ：每秒钟接收的数据包。
txpck/s ：每秒钟发送的数据包。
rxbyt/s ：每秒钟接收的字节数。
txbyt/s ：每秒钟发送的字节数。
rxcmp/s ：每秒钟接收的压缩数据包。
txcmp/s ：每秒钟发送的压缩数据包。
rxmcst/s ：每秒钟接收的多播数据包。
# sar -u
查看CPU使用情况，与不带-u选项一样。
</code></pre>]]></content>
    
    
      <category term="Linux" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/Linux/"/>
    
      <category term="Linux" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式之观察者模式]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/observer/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/21/设计模式/observer/</id>
    <published>2014-05-21T01:49:19.000Z</published>
    <updated>2014-05-21T02:24:13.000Z</updated>
    <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<p>定义了一种一对多的关系，让多个观察对象同时监听一个主题对象，当主题对象状态发生变化时会通知所有观察者。<br><img src="/img/Design patterns/observer.png" alt="类图"></p>
<h4 id="优缺点">优缺点</h4>
<ul>
<li>观察者与被观察者之间是属于轻度的关联关系，并且是抽象耦合的，这样，对于两者来说都比较容易进行扩展。</li>
<li>观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察者的方法进行处理。但同时，这也算是观察者模式一个缺点，由于是链式触发，当观察者比较多的时候，性能问题是比较令人担忧的。并且，在链式结构中，比较容易出现循环引用的错误，造成系统假死。</li>
</ul>
<p>实验来自《大话设计模式》案例：公司里有两种上班时趁老板不在时偷懒的员工：看NBA的和看股票行情的，当老板出现时，老板秘书会提前通知他们继续做手头上的工作。</p>
<p><img src="/img/Design patterns/observer_1.jpg" alt="类图"></p>
<h4 id="Java版">Java版</h4>
<p>抽象通知者接口  老板给通知，或者前台给通知</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> Subject {

    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">Attach</span>(Observer observer);
    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">Detach</span>(Observer observer);
    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">Notify</span>();
    <span class="keyword">public</span>  String <span class="title">getAction</span>();
    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setAction</span>(String action);
}
</code></pre><p>抽象观察者</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Observer {

    <span class="keyword">protected</span> String name;
    <span class="keyword">protected</span> Subject sub;
    <span class="keyword">public</span> <span class="title">Observer</span>(String name,Subject sub) {
        <span class="keyword">this</span>.name =name;
        <span class="keyword">this</span>.sub = sub;
    }
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Update</span>();
}
</code></pre><p>具体通知者 Boss 前台，给所有观察者发通知</p>
<pre><code><span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">Subject</span> {</span>
    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();
    <span class="keyword">private</span> String action;
    <span class="keyword">public</span> String <span class="title">getAction</span>() {
        <span class="keyword">return</span> action;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAction</span>(String action) {
        <span class="keyword">this</span>.action = action;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attach</span>(Observer observer) {
        <span class="comment">// TODO Auto-generated method stub</span>
        observers.add(observer);

    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Detach</span>(Observer observer) {
        <span class="comment">// TODO Auto-generated method stub</span>
        observers.remove(observer);

    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span>() {
        <span class="comment">// TODO Auto-generated method stub</span>
        <span class="keyword">for</span> (Observer o : observers) {
            o.Update();
        }

    }
}
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Secretary</span> <span class="keyword">implements</span> <span class="title">Subject</span>{</span>
    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();
    <span class="keyword">private</span> String action;
    <span class="keyword">public</span> String <span class="title">getAction</span>() {
        <span class="keyword">return</span> action;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAction</span>(String action) {
        <span class="keyword">this</span>.action = action;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attach</span>(Observer observer) {
        observers.add(observer);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Detach</span>(Observer observer) {
        observers.remove(observer);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span>() {
        <span class="keyword">for</span> (Observer o : observers) {
            o.Update();
        }
    }

}
</code></pre><p>具体观察者</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBAObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> {</span>
    <span class="keyword">public</span> <span class="title">NBAObserver</span>(String name,Subject sub) {
        <span class="keyword">super</span>(name, sub);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>() {
        System.out.printf(<span class="keyword">super</span>.sub.getAction() + <span class="string">","</span> + <span class="keyword">super</span>.name + <span class="string">" stop watching NBA!!! go on working!!!\n"</span>);

    }

}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span>{</span>
    <span class="keyword">public</span> <span class="title">StockObserver</span>(String name,Subject sub) {
        <span class="keyword">super</span>(name,sub);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(){
        System.out.printf(<span class="keyword">super</span>.sub.getAction() + <span class="string">","</span> + <span class="keyword">super</span>.name + <span class="string">" stop stocking!!! go on working!!!\n"</span>);
    }

}
</code></pre><p>客户端</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> test {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        <span class="comment">// TODO Auto-generated method stub</span>
        Secretary sec = <span class="keyword">new</span> Secretary();
        Boss boss = <span class="keyword">new</span> Boss();
        StockObserver so1 = <span class="keyword">new</span> StockObserver(<span class="string">"A"</span>,sec);
        NBAObserver so2 = <span class="keyword">new</span> NBAObserver(<span class="string">"B"</span>,sec);
        StockObserver so3 = <span class="keyword">new</span> StockObserver(<span class="string">"C"</span>,boss);
        NBAObserver so4 = <span class="keyword">new</span> NBAObserver(<span class="string">"D"</span>,boss);
        NBAObserver so5 = <span class="keyword">new</span> NBAObserver(<span class="string">"E"</span>,boss);
        sec.Attach(so1);
        sec.Attach(so2);
        boss.Attach(so3);
        boss.Attach(so4);
        boss.Attach(so5);
        boss.Detach(so4);
        sec.setAction(<span class="string">"boss is comming!!!"</span>);
        boss.setAction(<span class="string">"I'boss!!!"</span>);
        sec.Notify();
        boss.Notify();
    }

}
</code></pre><h4 id="Python版">Python版</h4>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Observer</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,strname,strsub)</span>:</span>
        self.name = strname
        self.sub = strsub
    <span class="function"><span class="keyword">def</span> <span class="title">Update</span><span class="params">(self)</span>:</span>
        <span class="keyword">pass</span>

<span class="class"><span class="keyword">class</span> <span class="title">StockObserver</span><span class="params">(Observer)</span>:</span>
    <span class="comment">#no need to rewrite __init__()</span>
    <span class="function"><span class="keyword">def</span> <span class="title">Update</span><span class="params">(self)</span>:</span>
        <span class="keyword">print</span> <span class="string">"%s:%s,stop watching Stock and go on work!"</span> %(self.name,self.sub.action)

<span class="class"><span class="keyword">class</span> <span class="title">NBAObserver</span><span class="params">(Observer)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">Update</span><span class="params">(self)</span>:</span>
        <span class="keyword">print</span> <span class="string">"%s:%s,stop watching NBA and go on work!"</span> %(self.name,self.sub.action)

<span class="class"><span class="keyword">class</span> <span class="title">SecretaryBase</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        self.observers = []
    <span class="function"><span class="keyword">def</span> <span class="title">Attach</span><span class="params">(self,new_observer)</span>:</span>
        <span class="keyword">pass</span> 
    <span class="function"><span class="keyword">def</span> <span class="title">Notify</span><span class="params">(self)</span>:</span>
        <span class="keyword">pass</span>

<span class="class"><span class="keyword">class</span> <span class="title">Secretary</span><span class="params">(SecretaryBase)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">Attach</span><span class="params">(self,new_observer)</span>:</span>
        self.observers.append(new_observer)
    <span class="function"><span class="keyword">def</span> <span class="title">Notify</span><span class="params">(self)</span>:</span>
        <span class="keyword">for</span> p <span class="keyword">in</span> self.observers:
            p.Update()

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    p = Secretary()
    s1 = StockObserver(<span class="string">"xh"</span>,p)
    s2 = NBAObserver(<span class="string">"wyt"</span>,p)
    p.Attach(s1);
    p.Attach(s2);
    p.action = <span class="string">"WARNING:BOSS "</span>;
    p.Notify()
</code></pre>]]></content>
    
    
      <category term="设计模式" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
