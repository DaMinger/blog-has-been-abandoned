<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[DaMinger's blog]]></title>
  <subtitle><![CDATA[信春哥，系统稳，闭眼上线不回滚]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://github.com/DaMinger/DaMinger.github.io.git/"/>
  <updated>2014-06-04T05:48:18.648Z</updated>
  <id>https://github.com/DaMinger/DaMinger.github.io.git/</id>
  
  <author>
    <name><![CDATA[DaMinger]]></name>
    <email><![CDATA[564400632@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[LeetCode：Minimum Depth of Binary Tree]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/minimum_depth_of_binary_tree/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/minimum_depth_of_binary_tree/</id>
    <published>2014-06-04T05:33:53.000Z</published>
    <updated>2014-06-04T05:39:21.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a binary tree, find <span class="keyword">its</span> minimum depth.

The minimum depth <span class="keyword">is</span> <span class="keyword">the</span> <span class="type">number</span> <span class="keyword">of</span> nodes along <span class="keyword">the</span> shortest path <span class="keyword">from</span> <span class="keyword">the</span> root node down <span class="keyword">to</span> <span class="keyword">the</span> nearest leaf node.
</code></pre><p>思路：需要辅助队列，遍历到左子树或者右子树为空的时候，返回count</p>
<h4 id="解法">解法</h4>
<pre><code><span class="javadoc">/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span>
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span>(TreeNode root) {
        <span class="keyword">if</span>(root == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }

        LinkedList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();
        LinkedList&lt;Integer&gt; counts = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();

        nodes.add(root);
        counts.add(<span class="number">1</span>);

        <span class="keyword">while</span>(!nodes.isEmpty()){
            TreeNode curr = nodes.remove();
            <span class="keyword">int</span> count = counts.remove();

            <span class="keyword">if</span>(curr.left != <span class="keyword">null</span>){
                nodes.add(curr.left);
                counts.add(count+<span class="number">1</span>);
            }

            <span class="keyword">if</span>(curr.right != <span class="keyword">null</span>){
                nodes.add(curr.right);
                counts.add(count+<span class="number">1</span>);
            }

            <span class="keyword">if</span>(curr.left == <span class="keyword">null</span> &amp;&amp; curr.right == <span class="keyword">null</span>){
                <span class="keyword">return</span> count;
            }
        }

        <span class="keyword">return</span> <span class="number">0</span>;
    }
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Merge Sorted Array]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/merge_sorted_array/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/merge_sorted_array/</id>
    <published>2014-06-04T05:29:41.000Z</published>
    <updated>2014-06-04T05:34:49.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="constant">two</span> sorted <span class="keyword">integer</span> arrays A <span class="operator">and</span> B, <span class="built_in">merge</span> B <span class="keyword">into</span> A <span class="keyword">as</span> <span class="constant">one</span> sorted array.
</code></pre><p>思路：这个真心没啥好说的。。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span>(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n) {
        <span class="keyword">int</span> i=m-<span class="number">1</span>;
        <span class="keyword">int</span> j=n-<span class="number">1</span>;
        <span class="keyword">int</span> k=m+n-<span class="number">1</span>;
        <span class="keyword">while</span>(k&gt;=<span class="number">0</span>){
            <span class="keyword">if</span>(j&lt;<span class="number">0</span>||(i&gt;=<span class="number">0</span>&amp;&amp;A[i]&gt;B[j]))
                A[k--]=A[i--];
            <span class="keyword">else</span>
                A[k--]=B[j--];
        }
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Merge k Sorted Lists]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/merge_k_sorted_list/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/merge_k_sorted_list/</id>
    <published>2014-06-04T05:16:33.000Z</published>
    <updated>2014-06-04T05:42:14.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Merge k sorted linked lists <span class="keyword">and</span> <span class="constant">return</span> <span class="keyword">it</span> <span class="keyword">as</span> one sorted <span class="type">list</span>. Analyze <span class="keyword">and</span> describe <span class="keyword">its</span> complexity.
</code></pre><p>思路：本来想一条一条比，但是超时了，后来想到mergesort的思想，还得分而治之。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="comment">//超时</span>
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> ListNode <span class="title">mergeKLists</span>(ArrayList&lt;ListNode&gt; lists) {
        <span class="comment">// Start typing your Java solution below</span>
        <span class="comment">// DO NOT write main() function</span>
        ListNode head = <span class="keyword">null</span>;
        <span class="keyword">int</span> len = lists.size();
        <span class="keyword">if</span>(len == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">null</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">1</span>){
            <span class="keyword">return</span> lists.<span class="keyword">get</span>(<span class="number">0</span>);
        }
        head = merge2List(lists.<span class="keyword">get</span>(<span class="number">0</span>), lists.<span class="keyword">get</span>(<span class="number">1</span>));
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++){
            head = merge2List(lists.<span class="keyword">get</span>(i), head);
        }
        <span class="keyword">return</span> head;
    }
    <span class="keyword">public</span> ListNode <span class="title">merge2List</span>(ListNode node1, ListNode node2){
        ListNode head = <span class="keyword">new</span> ListNode(Integer.MIN_VALUE);
        ListNode tmp = head;
        <span class="keyword">while</span>(node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>){
            <span class="keyword">if</span>(node1.val &lt;= node2.val){
                ListNode node = <span class="keyword">new</span> ListNode(node1.val);
                tmp.next = node;
                tmp = tmp.next;
                node1 = node1.next;
            } <span class="keyword">else</span> {
                ListNode node = <span class="keyword">new</span> ListNode(node2.val);
                tmp.next = node;
                tmp = tmp.next;
                node2 = node2.next;
            }
        }
        <span class="keyword">if</span>(node1 != <span class="keyword">null</span>){
            tmp.next = node1;
        }
        <span class="keyword">if</span>(node2 != <span class="keyword">null</span>){
            tmp.next = node2;
        }
        head = head.next;
        <span class="keyword">return</span> head;
    }
}
<span class="comment">//分治</span>
<span class="keyword">public</span> ListNode <span class="title">mergeKLists</span>(ArrayList&lt;ListNode&gt; lists) {
    <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.size()==<span class="number">0</span>)
        <span class="keyword">return</span> <span class="keyword">null</span>;
    <span class="keyword">return</span> helper(lists,<span class="number">0</span>,lists.size()-<span class="number">1</span>);
}
<span class="keyword">private</span> ListNode <span class="title">helper</span>(ArrayList&lt;ListNode&gt; lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)
{
    <span class="keyword">if</span>(l&lt;r)
    {
        <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;
        <span class="keyword">return</span> merge(helper(lists,l,m),helper(lists,m+<span class="number">1</span>,r));
    }
    <span class="keyword">return</span> lists.<span class="keyword">get</span>(l);
}
<span class="keyword">private</span> ListNode <span class="title">merge</span>(ListNode l1, ListNode l2)
{ 
    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
    dummy.next = l1;
    ListNode cur = dummy;
    <span class="keyword">while</span>(l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>)
    {
        <span class="keyword">if</span>(l1.val&lt;l2.val)
        {
            l1 = l1.next;
        }
        <span class="keyword">else</span>
        {
            ListNode next = l2.next;
            cur.next = l2;
            l2.next = l1;
            l2 = next;
        }
        cur = cur.next;
    }
    <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)
        cur.next = l2;
    <span class="keyword">return</span> dummy.next;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Merge Two Sorted Lists]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/merge_two_sorted_list/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/merge_two_sorted_list/</id>
    <published>2014-06-04T05:16:11.000Z</published>
    <updated>2014-06-04T05:22:06.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Merge <span class="constant">two</span> sorted linked lists <span class="operator">and</span> <span class="constant">return</span> <span class="keyword">it</span> <span class="keyword">as</span> <span class="operator">a</span> <span class="built_in">new</span> list. The <span class="built_in">new</span> list should be made <span class="keyword">by</span> splicing together <span class="operator">the</span> nodes <span class="operator">of</span> <span class="operator">the</span> <span class="keyword">first</span> <span class="constant">two</span> lists.
</code></pre><p>思路：分别比较两个链表的节点。</p>
<h4 id="解法">解法</h4>
<pre><code>/**
 * Definition <span class="keyword">for</span> singly-linked list.
 * <span class="keyword">public</span> <span class="keyword">class</span> ListNode {
 *     <span class="built_in">int</span> val;
 *     ListNode <span class="keyword">next</span>;
 *     ListNode(<span class="built_in">int</span> x) {
 *         val = x;
 *         <span class="keyword">next</span> = <span class="literal">null</span>;
 *     }
 * }
 */
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> ListNode mergeTwoLists(ListNode l1, ListNode l2) {

        ListNode p1 = l1;
        ListNode p2 = l2;

        ListNode fakeHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
        ListNode p = fakeHead;

        <span class="keyword">while</span>(p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>){
          <span class="keyword">if</span>(p1.val &lt;= p2.val){
              p.<span class="keyword">next</span> = p1;
              p1 = p1.<span class="keyword">next</span>;
          }<span class="keyword">else</span>{
              p.<span class="keyword">next</span> = p2;
              p2 = p2.<span class="keyword">next</span>;
          }

          p = p.<span class="keyword">next</span>;
        }

        <span class="keyword">if</span>(p1 != <span class="literal">null</span>)
            p.<span class="keyword">next</span> = p1;
        <span class="keyword">if</span>(p2 != <span class="literal">null</span>)
            p.<span class="keyword">next</span> = p2;

        return fakeHead.<span class="keyword">next</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Maximum Subarray]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/maximum_subarray/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/maximum_subarray/</id>
    <published>2014-06-04T05:10:01.000Z</published>
    <updated>2014-06-04T05:43:54.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Find <span class="operator">the</span> contiguous subarray <span class="operator">within</span> <span class="operator">an</span> array (containing <span class="keyword">at</span> least <span class="constant">one</span> <span class="built_in">number</span>) which has <span class="operator">the</span> largest <span class="built_in">sum</span>.

For example, given <span class="operator">the</span> array [−<span class="number">2</span>,<span class="number">1</span>,−<span class="number">3</span>,<span class="number">4</span>,−<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,−<span class="number">5</span>,<span class="number">4</span>],
<span class="operator">the</span> contiguous subarray [<span class="number">4</span>,−<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] has <span class="operator">the</span> largest <span class="built_in">sum</span> = <span class="number">6.</span>
</code></pre><p>思路：从头到尾遍历这个数组的时候，对于一个数组里的数字，它有几种选择呢？它只有两种选择： 1. 加入之前的SubArray， 2. 自己另起一个SubArray.如果之前SubArray的总体和大于0的话，我们可以认为其对后续数字是有贡献的。这种情况下我们选择加入之前的SubArray；如果之前SubArray的总体和为0或者小于0的话，我们可以认为其对后续数字是没有贡献，甚至是有害的（小于0时）。这种情况下我们只能选择以这个数字开始，另起一个SubArray.sum记录之前SubArray的和，max用来返回最大值，当sum的值大于max时，说明发现和更大的SubArray序列，此时更新max的值。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span>
    <span class="keyword">public</span> <span class="keyword">int</span> maxSubArray(<span class="keyword">int</span>[] A) {
        <span class="keyword">int</span> max = Integer.MIN_VALUE;
        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.length; i++){
            <span class="keyword">sum</span> = <span class="keyword">sum</span>&gt;<span class="number">0</span>? <span class="keyword">sum</span> + A[i]: A[i];
            max = Math.max(<span class="keyword">sum</span>,max);
        }
        <span class="keyword">return</span> max;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Longest Substring Without Repeating Characters]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/longest_substring_without_repeating_characters/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/longest_substring_without_repeating_characters/</id>
    <published>2014-06-04T05:01:10.000Z</published>
    <updated>2014-06-04T05:46:03.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a <span class="type">string</span>, find <span class="keyword">the</span> <span class="property">length</span> <span class="keyword">of</span> <span class="keyword">the</span> longest substring <span class="keyword">without</span> repeating <span class="property">characters</span>. 
For example, <span class="keyword">the</span> longest substring <span class="keyword">without</span> repeating letters <span class="keyword">for</span> <span class="string">"abcabcbb"</span> <span class="keyword">is</span> <span class="string">"abc"</span>, which <span class="keyword">the</span> <span class="property">length</span> <span class="keyword">is</span> <span class="number">3.</span> 
For <span class="string">"bbbbb"</span> <span class="keyword">the</span> longest substring <span class="keyword">is</span> <span class="string">"b"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="property">length</span> <span class="keyword">of</span> <span class="number">1.</span>
</code></pre><p>思路：本想用hashmap,但是超时了，参考 <a href="http://blog.csdn.net/linhuanmars/article/details/19949159" target="_blank">http://blog.csdn.net/linhuanmars/article/details/19949159</a>     左右窗口滑动的想法，很不错。</p>
<p>基本思路是维护一个窗口，每次关注窗口中的字符串，在每次判断中，左窗口和右窗口选择其一向前移动。同样是维护一个HashSet, 正常情况下移动右窗口，如果没有出现重复则继续移动右窗口，如果发现重复字符，则说明当前窗口中的串已经不满足要求，继续移动有窗口不可能得到更好的结果，此时移动左窗口，直到不再有重复字符为止，中间跳过的这些串中不会有更好的结果，因为他们不是重复就是更短。因为左窗口和右窗口都只向前，所以两个窗口都对每个元素访问不超过一遍，因此时间复杂度为O(2*n)=O(n),是线性算法。空间复杂度为HashSet的size,也是O(n).</p>
<h4 id="解法">解法</h4>
<pre><code><span class="comment">//超时</span>
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span>(String s) {

    <span class="keyword">char</span>[] arr = s.toCharArray();
    <span class="keyword">int</span> pre = <span class="number">0</span>;

    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {
        <span class="keyword">if</span> (!map.containsKey(arr[i])) {
            map.put(arr[i], i);
        } <span class="keyword">else</span> {
            pre = pre &gt; map.size() ? pre : map.size();
            i = map.<span class="keyword">get</span>(arr[i]);
            map.clear();
        }
    }

    <span class="keyword">return</span> Math.max(pre, map.size());
}
}
<span class="comment"><span class="xmlDocTag">///</span>左右窗口滑动 </span>
<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span>(String s) {
    <span class="keyword">if</span>(s==<span class="keyword">null</span> &amp;&amp; s.length()==<span class="number">0</span>)
        <span class="keyword">return</span> <span class="number">0</span>;
    HashSet&lt;Character&gt; <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;Character&gt;();
    <span class="keyword">int</span> max = <span class="number">0</span>;
    <span class="keyword">int</span> walker = <span class="number">0</span>;
    <span class="keyword">int</span> runner = <span class="number">0</span>;
    <span class="keyword">while</span>(runner&lt;s.length())
    {
        <span class="keyword">if</span>(<span class="keyword">set</span>.contains(s.charAt(runner)))
        {
            <span class="keyword">if</span>(max&lt;runner-walker)
            {
                max = runner-walker;
            }
            <span class="keyword">while</span>(s.charAt(walker)!=s.charAt(runner))
            {
                <span class="keyword">set</span>.remove(s.charAt(walker));
                walker++;
            }
            walker++;
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">set</span>.add(s.charAt(runner));
        }
        runner++;
    }
    max = Math.max(max,runner-walker);
    <span class="keyword">return</span> max;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Restore IP Addresses]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/restore_ip_addresses/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/restore_ip_addresses/</id>
    <published>2014-06-04T04:50:56.000Z</published>
    <updated>2014-06-04T04:57:11.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a <span class="type">string</span> containing only digits, restore <span class="keyword">it</span> <span class="keyword">by</span> <span class="keyword">returning</span> all possible valid IP address combinations.

For example:
Given <span class="string">"25525511135"</span>,
<span class="command">
return</span> [<span class="string">"255.255.11.135"</span>, <span class="string">"255.255.111.35"</span>]. (Order <span class="keyword">does</span> <span class="keyword">not</span> matter)
</code></pre><p>思路：dfs思路解决  每一段判断时考虑0作为首位的情况</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        String s = <span class="string">"12213452"</span>;
        ArrayList&lt;String&gt; list = (<span class="keyword">new</span> Solution()).restoreIpAddresses(s);
        System.<span class="keyword">out</span>.println(list);
    }
    <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">restoreIpAddresses</span>(String s) {
        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();
        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &gt; <span class="number">12</span> || s.length() &lt; <span class="number">4</span>) <span class="keyword">return</span> list;
        restore(s, <span class="number">1</span>, <span class="string">""</span>, list);
        <span class="keyword">return</span> list;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span>(String s, <span class="keyword">int</span> num, String ip, ArrayList&lt;String&gt; list) {
        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span>;
        <span class="keyword">if</span> (num == <span class="number">4</span> &amp;&amp; valid(s)) {
            ip += s;
            list.add(ip);
            <span class="keyword">return</span>;
        }
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) {
            <span class="keyword">if</span> (i &gt; s.length()) <span class="keyword">break</span>;
            String pre = s.substring(<span class="number">0</span>, i);
            <span class="keyword">if</span> (valid(pre)) {
                String post = s.substring(i);
                restore(post, num + <span class="number">1</span>, ip + pre + <span class="string">"."</span>, list);
            }
        }
    }

    <span class="keyword">public</span> boolean <span class="title">valid</span>(String s) {
        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span> (s.length() &gt; <span class="number">1</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">int</span> v = Integer.parseInt(s);
        <span class="keyword">if</span> (v &gt;= <span class="number">0</span> &amp;&amp; v &lt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Flatten Binary Tree to Linked List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/flatten_binary_tree_to_linked_list/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/flatten_binary_tree_to_linked_list/</id>
    <published>2014-06-04T04:43:28.000Z</published>
    <updated>2014-06-04T04:48:09.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a binary tree, flatten it to a linked list in-place.

For example,
Given

         1
        / <span class="command">\
</span>       2   5
      / <span class="command">\ </span>  <span class="command">\
</span>     3   4   6
The flattened tree should look like:
   1
    <span class="command">\
</span>     2
      <span class="command">\
</span>       3
        <span class="command">\
</span>         4
          <span class="command">\
</span>           5
            <span class="command">\
</span>             6
</code></pre><p>思路：遍历左结点，当它的右节点不为空，将右节点压入栈</p>
<h4 id="解法">解法</h4>
<pre><code>/**
 * Definition <span class="keyword">for</span> binary tree
 * <span class="keyword">public</span> <span class="keyword">class</span> TreeNode {
 *     <span class="built_in">int</span> val;
 *     TreeNode <span class="built_in">left</span>;
 *     TreeNode <span class="built_in">right</span>;
 *     TreeNode(<span class="built_in">int</span> x) { val = x; }
 * }
 */
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> void flatten(TreeNode root) {
        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();
        TreeNode p = root;

        <span class="keyword">while</span>(p != <span class="literal">null</span> || !stack.<span class="literal">empty</span>()){

            <span class="keyword">if</span>(p.<span class="built_in">right</span> != <span class="literal">null</span>){
                stack.push(p.<span class="built_in">right</span>);
            }

            <span class="keyword">if</span>(p.<span class="built_in">left</span> != <span class="literal">null</span>){
                p.<span class="built_in">right</span> = p.<span class="built_in">left</span>;
                p.<span class="built_in">left</span> = <span class="literal">null</span>;
            }<span class="keyword">else</span> <span class="keyword">if</span>(!stack.<span class="literal">empty</span>()){
                TreeNode temp = stack.pop();
                p.<span class="built_in">right</span>=temp;
            }

            p = p.<span class="built_in">right</span>;
        }
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Convert Sorted List to Binary Search Tree]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/convert_sorted_list_to_binary_search_tree/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/convert_sorted_list_to_binary_search_tree/</id>
    <published>2014-06-03T05:43:43.000Z</published>
    <updated>2014-06-03T05:56:09.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> singly linked list where elements are sorted <span class="operator">in</span> <span class="keyword">ascending</span> order, <span class="built_in">convert</span> <span class="keyword">it</span> <span class="built_in">to</span> <span class="operator">a</span> height balanced BST
</code></pre><p>思路：二分+递归  比有序数组转二叉树麻烦点，因为数组可以在O(1)时间内找到任意节点，链表做不到，创建个bottom-up节点，作为每次递归的父节点，这样可以在创建二叉树的节点同时找到对应的节点。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="comment">//  Definition for singly-linked list.</span>
class ListNode {
    <span class="keyword">int</span> val;
    ListNode next;

    ListNode(<span class="keyword">int</span> x) {
        val = x;
        next = <span class="keyword">null</span>;
    }
}

<span class="comment">// Definition for binary tree</span>
class TreeNode {
    <span class="keyword">int</span> val;
    TreeNode left;
    TreeNode right;

    TreeNode(<span class="keyword">int</span> x) {
        val = x;
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">static</span> ListNode h;

    <span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span>(ListNode head) {
        <span class="keyword">if</span> (head == <span class="keyword">null</span>)
            <span class="keyword">return</span> <span class="keyword">null</span>;

        h = head;
        <span class="keyword">int</span> len = getLength(head);
        <span class="keyword">return</span> sortedListToBST(<span class="number">0</span>, len - <span class="number">1</span>);
    }

    <span class="comment">// get list length</span>
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span>(ListNode head) {
        <span class="keyword">int</span> len = <span class="number">0</span>;
        ListNode p = head;

        <span class="keyword">while</span> (p != <span class="keyword">null</span>) {
            len++;
            p = p.next;
        }
        <span class="keyword">return</span> len;
    }

    <span class="comment">// build tree bottom-up</span>
    <span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end) {
        <span class="keyword">if</span> (start &gt; end)
            <span class="keyword">return</span> <span class="keyword">null</span>;

        <span class="comment">// mid</span>
        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;

        TreeNode left = sortedListToBST(start, mid - <span class="number">1</span>);
        TreeNode root = <span class="keyword">new</span> TreeNode(h.val);
        h = h.next;
        TreeNode right = sortedListToBST(mid + <span class="number">1</span>, end);

        root.left = left;
        root.right = right;

        <span class="keyword">return</span> root;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Convert Sorted Array to Binary Search Tree]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/convert_sorted_array_to_binary_search_tree/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/convert_sorted_array_to_binary_search_tree/</id>
    <published>2014-06-03T05:39:33.000Z</published>
    <updated>2014-06-03T05:42:52.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">an</span> array where elements are sorted <span class="operator">in</span> <span class="keyword">ascending</span> order, <span class="built_in">convert</span> <span class="keyword">it</span> <span class="built_in">to</span> <span class="operator">a</span> height balanced BST.
</code></pre><p>思路：二分+递归解决</p>
<h4 id="解法">解法</h4>
<pre><code><span class="comment">// Definition for binary tree</span>
class TreeNode {
    <span class="keyword">int</span> val;
    TreeNode left;
    TreeNode right;

    TreeNode(<span class="keyword">int</span> x) {
        val = x;
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span>(<span class="keyword">int</span>[] num) {
        <span class="keyword">if</span> (num.length == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">null</span>;

        <span class="keyword">return</span> sortedArrayToBST(num, <span class="number">0</span>, num.length - <span class="number">1</span>);
    }

    <span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span>(<span class="keyword">int</span>[] num, <span class="keyword">int</span> start, <span class="keyword">int</span> end) {
        <span class="keyword">if</span> (start &gt; end)
            <span class="keyword">return</span> <span class="keyword">null</span>;

        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;
        TreeNode root = <span class="keyword">new</span> TreeNode(num[mid]);
        root.left = sortedArrayToBST(num, start, mid - <span class="number">1</span>);
        root.right = sortedArrayToBST(num, mid + <span class="number">1</span>, end);

        <span class="keyword">return</span> root;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Balanced Binary Tree]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/balanced_binary_tree/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/balanced_binary_tree/</id>
    <published>2014-06-03T05:32:24.000Z</published>
    <updated>2014-06-03T05:55:58.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> binary tree, determine <span class="keyword">if</span> <span class="keyword">it</span> is height-balanced.

For this problem, <span class="operator">a</span> height-balanced binary tree is defined <span class="keyword">as</span> <span class="operator">a</span> binary tree
<span class="operator">in</span> which <span class="operator">the</span> depth <span class="operator">of</span> <span class="operator">the</span> <span class="constant">two</span> subtrees <span class="operator">of</span> every node never differ <span class="keyword">by</span> more than <span class="number">1.</span>
</code></pre><p>思路：递归解决</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span>(TreeNode root) {
        <span class="keyword">if</span>(root == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="comment">// 如果子树高度差大于1，则不平衡</span>
        <span class="keyword">if</span>(Math.abs(depth(root.left)-depth(root.right)) &gt; <span class="number">1</span>){
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="comment">// 递归检查左子树和右子树的平衡性</span>
        <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);
    }

    <span class="comment">// 帮助方法，返回树的高度</span>
    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span>(TreeNode root){
        <span class="keyword">if</span>(root == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }
        <span class="keyword">return</span> <span class="number">1</span> + Math.max(depth(root.left), depth(root.right));
    }
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:4Sum]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/4sum/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/4sum/</id>
    <published>2014-06-03T05:25:59.000Z</published>
    <updated>2014-06-03T05:55:48.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">an</span> array S <span class="operator">of</span> n integers, are there elements <span class="operator">a</span>, b, c, <span class="operator">and</span> d <span class="operator">in</span> S such that <span class="operator">a</span> + b + c + d = target? 
Find all unique quadruplets <span class="operator">in</span> <span class="operator">the</span> array which gives <span class="operator">the</span> <span class="built_in">sum</span> <span class="operator">of</span> target.

Note:
Elements <span class="operator">in</span> <span class="operator">a</span> quadruplet (<span class="operator">a</span>,b,c,d) must be <span class="operator">in</span> non-<span class="keyword">descending</span> order. (ie, <span class="operator">a</span> ≤ b ≤ c ≤ d)
The solution <span class="built_in">set</span> must <span class="operator">not</span> contain duplicate quadruplets.
For example, given array S = {<span class="number">1</span> <span class="number">0</span> -<span class="number">1</span> <span class="number">0</span> -<span class="number">2</span> <span class="number">2</span>}, <span class="operator">and</span> target = <span class="number">0.</span>

A solution <span class="built_in">set</span> is:
(-<span class="number">1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)
(-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)
(-<span class="number">2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>)
</code></pre><p>思路：延伸为K-Sum问题了    我还是采用俩指针来解决= =！！</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target) {
    Arrays.sort(num);

    HashSet&lt;ArrayList&lt;Integer&gt;&gt; hashSet = <span class="keyword">new</span> HashSet&lt;ArrayList&lt;Integer&gt;&gt;();
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) {
        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num.length; j++) {
            <span class="keyword">int</span> k = j + <span class="number">1</span>;
            <span class="keyword">int</span> l = num.length - <span class="number">1</span>;

            <span class="keyword">while</span> (k &lt; l) {
                <span class="keyword">int</span> <span class="keyword">sum</span> = num[i] + num[j] + num[k] + num[l];

                <span class="keyword">if</span> (<span class="keyword">sum</span> &gt; target) {
                    l--;
                } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sum</span> &lt; target) {
                    k++;
                } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sum</span> == target) {
                    ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();
                    temp.add(num[i]);
                    temp.add(num[j]);
                    temp.add(num[k]);
                    temp.add(num[l]);

                    <span class="keyword">if</span> (!hashSet.contains(temp)) {
                        hashSet.add(temp);
                        result.add(temp);
                    }

                    k++;
                    l--;
                }
            }
        }
    }

    <span class="keyword">return</span> result;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:3Sum Cloest]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/3sumcloest/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/3sumcloest/</id>
    <published>2014-06-03T05:20:45.000Z</published>
    <updated>2014-06-03T05:55:29.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">an</span> array S <span class="operator">of</span> n integers, find <span class="constant">three</span> integers <span class="operator">in</span> S such that <span class="operator">the</span> <span class="built_in">sum</span> is closest <span class="built_in">to</span> <span class="operator">a</span> given <span class="built_in">number</span>, target.
Return <span class="operator">the</span> <span class="built_in">sum</span> <span class="operator">of</span> <span class="operator">the</span> <span class="constant">three</span> integers. You may assume that <span class="keyword">each</span> input would have exactly <span class="constant">one</span> solution.

For example, given array S = {-<span class="number">1</span> <span class="number">2</span> <span class="number">1</span> -<span class="number">4</span>}, <span class="operator">and</span> target = <span class="number">1.</span>

The <span class="built_in">sum</span> that is closest <span class="built_in">to</span> <span class="operator">the</span> target is <span class="number">2.</span> (-<span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).
</code></pre><p>思路：和3Sum问题解决方法相似，采用俩指针解法，只不过遍历过程中需要比较。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span>(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target) {
        <span class="keyword">int</span> min = Integer.MAX_VALUE;
        <span class="keyword">int</span> result = <span class="number">0</span>;

        Arrays.sort(num);

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) {
            <span class="keyword">int</span> j = i + <span class="number">1</span>;
            <span class="keyword">int</span> k = num.length - <span class="number">1</span>;
            <span class="keyword">while</span> (j &lt; k) {
                <span class="keyword">int</span> sum = num[i] + num[j] + num[k];
                <span class="keyword">int</span> diff = Math.abs(sum - target);
                <span class="keyword">if</span> (diff &lt; min) {
                    min = diff;
                    result = sum;
                }
                <span class="keyword">if</span> (sum &lt;= target) {
                    j++;
                } <span class="keyword">else</span> {
                    k--;
                }
            }
        }

        <span class="keyword">return</span> result;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:3Sum]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/3sum/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/3sum/</id>
    <published>2014-06-03T05:07:50.000Z</published>
    <updated>2014-06-03T06:00:31.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">an</span> array S <span class="operator">of</span> n integers, are there elements <span class="operator">a</span>, b, c <span class="operator">in</span> S such that <span class="operator">a</span> + b + c = <span class="number">0</span>? 
Find all unique triplets <span class="operator">in</span> <span class="operator">the</span> array which gives <span class="operator">the</span> <span class="built_in">sum</span> <span class="operator">of</span> <span class="constant">zero</span>.

Note:
Elements <span class="operator">in</span> <span class="operator">a</span> triplet (<span class="operator">a</span>,b,c) must be <span class="operator">in</span> non-<span class="keyword">descending</span> order. (ie, <span class="operator">a</span> ≤ b ≤ c)
The solution <span class="built_in">set</span> must <span class="operator">not</span> contain duplicate triplets.
For example, given array S = {-<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> -<span class="number">1</span> -<span class="number">4</span>},

A solution <span class="built_in">set</span> is:
(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)
(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>)
</code></pre><p>思路：俩指针，选中一个元素，首指针在选中元素之后，尾指针在最后一个元素，俩指针遍历。时间复杂度O（n^2）,注意重复元素，可将数据排序，移动指针。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(int[] num) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();

    <span class="keyword">if</span> (num.length &lt; <span class="number">3</span>)
        <span class="keyword">return</span> result;

    <span class="comment">// sort array</span>
    Arrays.sort(num);

    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; num.length - <span class="number">2</span>; i++) {
        <span class="comment">// //avoid duplicate solutions</span>
        <span class="keyword">if</span> (i == <span class="number">0</span> || num[i] &gt; num[i - <span class="number">1</span>]) {

            int negate = -num[i];

            int start = i + <span class="number">1</span>;
            int <span class="keyword">end</span> = num.length - <span class="number">1</span>;

            <span class="keyword">while</span> (start &lt; <span class="keyword">end</span>) {
                <span class="comment">//case 1</span>
                <span class="keyword">if</span> (num[start] + num[<span class="keyword">end</span>] == negate) {
                    ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();
                    temp.add(num[i]);
                    temp.add(num[start]);
                    temp.add(num[<span class="keyword">end</span>]);

                    result.add(temp);
                    start++;
                    <span class="keyword">end</span>--;
                    <span class="comment">//avoid duplicate solutions</span>
                    <span class="keyword">while</span> (start &lt; <span class="keyword">end</span> &amp;&amp; num[<span class="keyword">end</span>] == num[<span class="keyword">end</span> + <span class="number">1</span>])
                        <span class="keyword">end</span>--;

                    <span class="keyword">while</span> (start &lt; <span class="keyword">end</span> &amp;&amp; num[start] == num[start - <span class="number">1</span>])
                        start++;
                <span class="comment">//case 2</span>
                } <span class="keyword">else</span> <span class="keyword">if</span> (num[start] + num[<span class="keyword">end</span>] &lt; negate) {
                    start++;
                <span class="comment">//case 3</span>
                } <span class="keyword">else</span> {
                    <span class="keyword">end</span>--;
                }
            }

        }
    }

    <span class="keyword">return</span> result;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Longest Palindromic Substring]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/longestpalindromicstring/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/29/数据结构与算法/LeetCode/longestpalindromicstring/</id>
    <published>2014-05-29T03:03:23.000Z</published>
    <updated>2014-05-29T03:41:07.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> <span class="keyword">string</span> S, find <span class="operator">the</span> longest palindromic substring <span class="operator">in</span> S. 
You may assume that <span class="operator">the</span> maximum <span class="built_in">length</span> <span class="operator">of</span> S is <span class="number">1000</span>, 
<span class="operator">and</span> there exists <span class="constant">one</span> unique longest palindromic substring.
</code></pre><p>思路：求最长回文子串，本题解法较多，我是参考这个网址，用的动态规划<br><a href="https://github.com/xiangzhai/leetcode/blob/master/question/longest-palindromic-substring-part-i.md" target="_blank">https://github.com/xiangzhai/leetcode/blob/master/question/longest-palindromic-substring-part-i.md</a></p>
<h4 id="解法">解法</h4>
<pre><code><span class="built_in">String</span> longestPalindromeDP(<span class="built_in">string</span> s) {
    <span class="built_in">int</span> n = s.length();
    <span class="built_in">int</span> longestBegin = <span class="number">0</span>;
    <span class="built_in">int</span> maxLen = <span class="number">1</span>;
    boolean table[<span class="number">1000</span>][<span class="number">1000</span>] = {<span class="literal">false</span>};
    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)
        table[i][i] = <span class="literal">true</span>;
    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++) {
        <span class="keyword">if</span> (s[i] == s[i+<span class="number">1</span>]) {
            table[i][i+<span class="number">1</span>] = <span class="literal">true</span>;
            longestBegin = i;
            maxLen = <span class="number">2</span>;
        }
    }
    <span class="keyword">for</span> (<span class="built_in">int</span> <span class="built_in">len</span> = <span class="number">3</span>; <span class="built_in">len</span> &lt;= n; <span class="built_in">len</span>++) {
        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n-<span class="built_in">len</span>+<span class="number">1</span>; i++) {
            <span class="built_in">int</span> j = i + <span class="built_in">len</span> - <span class="number">1</span>;
            <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; table[i+<span class="number">1</span>][j-<span class="number">1</span>]) {
                table[i][j] = <span class="literal">true</span>;
                longestBegin = i;
                maxLen = <span class="built_in">len</span>;
            }
        }
    }
    return s.substr(longestBegin, maxLen);
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Add Two Numbers]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/addtownumber/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/29/数据结构与算法/LeetCode/addtownumber/</id>
    <published>2014-05-29T03:03:02.000Z</published>
    <updated>2014-05-29T03:16:33.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>You are given <span class="constant">two</span> linked lists representing <span class="constant">two</span> non-negative numbers. 
The digits are stored <span class="operator">in</span> reverse order <span class="operator">and</span> <span class="keyword">each</span> <span class="operator">of</span> their nodes contain <span class="operator">a</span> single digit. 
Add <span class="operator">the</span> <span class="constant">two</span> numbers <span class="operator">and</span> <span class="constant">return</span> <span class="keyword">it</span> <span class="keyword">as</span> <span class="operator">a</span> linked list.

Input: (<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)
Output: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span>
</code></pre><p>思路：处理好进位问题就行了，注意末尾进位。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> ListNode {
      <span class="keyword">int</span> val;
      ListNode next;
      ListNode(<span class="keyword">int</span> x) {
          val = x;
          next = <span class="keyword">null</span>;
      }
}
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span>(ListNode l1, ListNode l2) {
        <span class="keyword">int</span> carry=<span class="number">0</span>;
        ListNode newHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);
        ListNode p1=l1,p2=l2,p3=newHead;
        <span class="keyword">while</span>(p1!=<span class="keyword">null</span> ||p2!=<span class="keyword">null</span>){
            <span class="keyword">if</span>(p1!=<span class="keyword">null</span>){
                carry +=p1.val;
                p1=p1.next;
            }
            <span class="keyword">if</span>(p2!=<span class="keyword">null</span>){
                carry +=p2.val;
                p2=p2.next;
            }

            p3.next=<span class="keyword">new</span> ListNode(carry%<span class="number">10</span>);
            p3=p3.next;
            <span class="comment">//进位处理</span>
            carry /=<span class="number">10</span>;
        }
        <span class="comment">//最后末尾产生进位</span>
        <span class="keyword">if</span>(carry==<span class="number">1</span>)
            p3.next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);
        <span class="keyword">return</span> newHead.next;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Two Sum]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/twosum/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/数据结构与算法/LeetCode/twosum/</id>
    <published>2014-05-27T09:15:45.000Z</published>
    <updated>2014-05-27T09:20:22.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given an array <span class="keyword">of</span> integers, find two numbers such <span class="keyword">that</span> they add up <span class="keyword">to</span> a specific target <span class="type">number</span>.

The function twoSum should <span class="constant">return</span> indices <span class="keyword">of</span> <span class="keyword">the</span> two numbers such <span class="keyword">that</span> they add up <span class="keyword">to</span> <span class="keyword">the</span> target, <span class="keyword">where</span> index1 must be <span class="keyword">less than</span> index2. Please note <span class="keyword">that</span> your returned answers (both index1 <span class="keyword">and</span> index2) are <span class="keyword">not</span> zero-based.

You may assume <span class="keyword">that</span> each input would have exactly one solution.

Input: numbers={<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>}, target=<span class="number">9</span>
Output: index1=<span class="number">1</span>, index2=<span class="number">2</span>
</code></pre><p>思路：hashmap 存另外一个数及其index</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">twoSum</span>(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) {
        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();
        <span class="keyword">int</span> [] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++){
            <span class="keyword">if</span>(map.containsKey(numbers[i])){
                <span class="keyword">int</span> index=map.<span class="keyword">get</span>(numbers[i]);
                result[<span class="number">0</span>]=index+<span class="number">1</span>;
                result[<span class="number">1</span>]=i+<span class="number">1</span>;
                <span class="keyword">break</span>;
            }<span class="keyword">else</span>{
                map.put(target-numbers[i],i);
            }
        }
        <span class="keyword">return</span> result;
    }
    <span class="comment">//超时写法</span>
    <span class="comment">//    public int[]twoSum(int[]numbers,int target){</span>
    <span class="comment">//        int[]ret=new int[2];</span>
    <span class="comment">//        for(int i=0;i&lt;numbers.length;i++){</span>
    <span class="comment">//            for(int j=i+1;j&lt;numbers.length;j++){</span>
    <span class="comment">//                if(numbers[i]+numbers[j]==target){</span>
    <span class="comment">//                    ret[0]=i+1;</span>
    <span class="comment">//                    ret[1]=j+1;</span>
    <span class="comment">//                }        </span>
    <span class="comment">//            }</span>
    <span class="comment">//        }</span>
    <span class="comment">//        return ret;</span>
    <span class="comment">//    }</span>
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Reorder List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/reorderlist/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/数据结构与算法/LeetCode/reorderlist/</id>
    <published>2014-05-27T06:18:26.000Z</published>
    <updated>2014-05-27T06:23:39.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a singly linked <span class="type">list</span> L: L0→L1→…→Ln-<span class="number">1</span>→Ln,
reorder <span class="keyword">it</span> <span class="keyword">to</span>: L0→Ln→L1→Ln-<span class="number">1</span>→L2→Ln-<span class="number">2</span>→…

You must do this <span class="keyword">in</span>-place <span class="keyword">without</span> altering <span class="keyword">the</span> nodes' values.

For example,
Given {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}, reorder <span class="keyword">it</span> <span class="keyword">to</span> {<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>}.
</code></pre><p>思路：第一把整个链表划分成2个等长的子链表，如果原链表长度为奇数，那么第一个子链表的长度多1；第二翻转第二个子链表；第三将两个子链表合并。</p>
<h4 id="解法">解法</h4>
<pre><code>class ListNode {
      <span class="keyword">int</span> val;
      ListNode next;
      ListNode(<span class="keyword">int</span> x) {
         val = x;
          next = <span class="keyword">null</span>;
      }
}

<span class="keyword">public</span> <span class="keyword">class</span> Reorderlist {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span>(ListNode head) {
        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)
            <span class="keyword">return</span>;
        ListNode slowNode=head,fastNode=head;
        <span class="keyword">while</span>(fastNode.next!=<span class="keyword">null</span>){
            fastNode=fastNode.next;
            <span class="keyword">if</span>(fastNode.next!=<span class="keyword">null</span>)
                fastNode=fastNode.next;
            <span class="keyword">else</span>
                <span class="keyword">break</span>;
            slowNode=slowNode.next;
        }
        <span class="comment">//快慢指针确定链表中点</span>
        ListNode head1=head,head2=slowNode.next;
        slowNode.next=<span class="keyword">null</span>;
        <span class="comment">//对后半部分就行进行逆序</span>
        ListNode cur=head2,post=cur.next;
        cur.next=<span class="keyword">null</span>;
        <span class="keyword">while</span>(post!=<span class="keyword">null</span>){
            ListNode temp=post.next;
            post.next=cur;
            cur=post;
            post=temp;
        }
        head2 =cur;
        <span class="comment">//合并链表</span>
        ListNode p=head1,q=head2;
        <span class="keyword">while</span>(q!=<span class="keyword">null</span>){
            ListNode temp1=p.next;
            ListNode temp2=q.next;
            p.next=q;
            q.next=temp1;
            p=temp1;
            q=temp2;
        }
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Pow(x, n)]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/power_x_n/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/数据结构与算法/LeetCode/power_x_n/</id>
    <published>2014-05-25T11:13:08.000Z</published>
    <updated>2014-05-25T11:46:44.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Implement <span class="built_in">pow</span>(x, n).
</code></pre><p>思路：最简单的方法是循环，循环n-1遍，每次乘以x。时间复杂度：O(N)。很显然，最后超时了。并且如果用递归的话，函数好写简洁，但是碰见大数，栈空间不够用会导致运行时错误（stack overflow）。<br>二分法解决问题：x^n = x^n/2 <em> x^n/2 </em> x^n%2  n考虑奇数偶数 时间复杂度：O(logN)<br><img src="/img/数据结构与算法/2.png" alt=" "></p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span>(<span class="keyword">double</span> x, <span class="keyword">int</span> n) {
        <span class="keyword">if</span> (n == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">1.0</span>;
        <span class="keyword">double</span> half = pow(x, n/<span class="number">2</span>);
        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)
            <span class="keyword">return</span> half * half;
        <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)
            <span class="keyword">return</span> half * half * x;
        <span class="keyword">else</span> 
            <span class="keyword">return</span> half * half / x;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Single Number I and  II]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/singlenumber/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/数据结构与算法/LeetCode/singlenumber/</id>
    <published>2014-05-25T11:12:39.000Z</published>
    <updated>2014-05-25T11:31:08.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>I:
Given <span class="operator">an</span> array <span class="operator">of</span> integers, every <span class="keyword">element</span> appears twice except <span class="keyword">for</span> <span class="constant">one</span>. Find that single <span class="constant">one</span>.
II:
Given <span class="operator">an</span> array <span class="operator">of</span> integers, every <span class="keyword">element</span> appears <span class="constant">three</span> times except <span class="keyword">for</span> <span class="constant">one</span>. Find that single <span class="constant">one</span>.

Note:
Your algorithm should have <span class="operator">a</span> linear runtime complexity. Could you implement <span class="keyword">it</span> <span class="keyword">without</span> <span class="keyword">using</span> extra memory?
</code></pre><p>思路：hashmap去存数组及对应的次数即可。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="keyword">int</span>[] A) {
        <span class="keyword">if</span>(A.length==<span class="number">0</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }
        HashMap&lt;Integer,Integer&gt; hash= <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();
        <span class="keyword">for</span>(<span class="keyword">int</span> a:A){
            <span class="keyword">if</span>(hash.containsKey(a)){
                hash.put(a,hash.<span class="keyword">get</span>(a)+<span class="number">1</span>);
            }
            <span class="keyword">else</span>{
                hash.put(a,<span class="number">1</span>);
            }
        }
        <span class="keyword">for</span>(<span class="keyword">int</span> key:hash.keySet()){
            <span class="keyword">if</span>(hash.<span class="keyword">get</span>(key)==<span class="number">1</span>)
                <span class="keyword">return</span> key;
        }
        <span class="keyword">return</span> <span class="number">0</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
