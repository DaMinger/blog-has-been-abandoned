<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[DaMinger's blog]]></title>
  <subtitle><![CDATA[信春哥，系统稳，闭眼上线不回滚]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://github.com/DaMinger/DaMinger.github.io.git/"/>
  <updated>2014-06-03T06:03:26.701Z</updated>
  <id>https://github.com/DaMinger/DaMinger.github.io.git/</id>
  
  <author>
    <name><![CDATA[DaMinger]]></name>
    <email><![CDATA[564400632@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[LeetCode:Convert Sorted List to Binary Search Tree]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/convert_sorted_list_to_binary_search_tree/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/convert_sorted_list_to_binary_search_tree/</id>
    <published>2014-06-03T05:43:43.000Z</published>
    <updated>2014-06-03T05:56:09.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> singly linked list where elements are sorted <span class="operator">in</span> <span class="keyword">ascending</span> order, <span class="built_in">convert</span> <span class="keyword">it</span> <span class="built_in">to</span> <span class="operator">a</span> height balanced BST
</code></pre><p>思路：二分+递归  比有序数组转二叉树麻烦点，因为数组可以在O(1)时间内找到任意节点，链表做不到，创建个bottom-up节点，作为每次递归的父节点，这样可以在创建二叉树的节点同时找到对应的节点。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="comment">//  Definition for singly-linked list.</span>
class ListNode {
    <span class="keyword">int</span> val;
    ListNode next;

    ListNode(<span class="keyword">int</span> x) {
        val = x;
        next = <span class="keyword">null</span>;
    }
}

<span class="comment">// Definition for binary tree</span>
class TreeNode {
    <span class="keyword">int</span> val;
    TreeNode left;
    TreeNode right;

    TreeNode(<span class="keyword">int</span> x) {
        val = x;
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">static</span> ListNode h;

    <span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span>(ListNode head) {
        <span class="keyword">if</span> (head == <span class="keyword">null</span>)
            <span class="keyword">return</span> <span class="keyword">null</span>;

        h = head;
        <span class="keyword">int</span> len = getLength(head);
        <span class="keyword">return</span> sortedListToBST(<span class="number">0</span>, len - <span class="number">1</span>);
    }

    <span class="comment">// get list length</span>
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span>(ListNode head) {
        <span class="keyword">int</span> len = <span class="number">0</span>;
        ListNode p = head;

        <span class="keyword">while</span> (p != <span class="keyword">null</span>) {
            len++;
            p = p.next;
        }
        <span class="keyword">return</span> len;
    }

    <span class="comment">// build tree bottom-up</span>
    <span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end) {
        <span class="keyword">if</span> (start &gt; end)
            <span class="keyword">return</span> <span class="keyword">null</span>;

        <span class="comment">// mid</span>
        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;

        TreeNode left = sortedListToBST(start, mid - <span class="number">1</span>);
        TreeNode root = <span class="keyword">new</span> TreeNode(h.val);
        h = h.next;
        TreeNode right = sortedListToBST(mid + <span class="number">1</span>, end);

        root.left = left;
        root.right = right;

        <span class="keyword">return</span> root;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Convert Sorted Array to Binary Search Tree]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/convert_sorted_array_to_binary_search_tree/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/convert_sorted_array_to_binary_search_tree/</id>
    <published>2014-06-03T05:39:33.000Z</published>
    <updated>2014-06-03T05:42:52.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">an</span> array where elements are sorted <span class="operator">in</span> <span class="keyword">ascending</span> order, <span class="built_in">convert</span> <span class="keyword">it</span> <span class="built_in">to</span> <span class="operator">a</span> height balanced BST.
</code></pre><p>思路：二分+递归解决</p>
<h4 id="解法">解法</h4>
<pre><code><span class="comment">// Definition for binary tree</span>
class TreeNode {
    <span class="keyword">int</span> val;
    TreeNode left;
    TreeNode right;

    TreeNode(<span class="keyword">int</span> x) {
        val = x;
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span>(<span class="keyword">int</span>[] num) {
        <span class="keyword">if</span> (num.length == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">null</span>;

        <span class="keyword">return</span> sortedArrayToBST(num, <span class="number">0</span>, num.length - <span class="number">1</span>);
    }

    <span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span>(<span class="keyword">int</span>[] num, <span class="keyword">int</span> start, <span class="keyword">int</span> end) {
        <span class="keyword">if</span> (start &gt; end)
            <span class="keyword">return</span> <span class="keyword">null</span>;

        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;
        TreeNode root = <span class="keyword">new</span> TreeNode(num[mid]);
        root.left = sortedArrayToBST(num, start, mid - <span class="number">1</span>);
        root.right = sortedArrayToBST(num, mid + <span class="number">1</span>, end);

        <span class="keyword">return</span> root;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Balanced Binary Tree]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/balanced_binary_tree/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/balanced_binary_tree/</id>
    <published>2014-06-03T05:32:24.000Z</published>
    <updated>2014-06-03T05:55:58.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> binary tree, determine <span class="keyword">if</span> <span class="keyword">it</span> is height-balanced.

For this problem, <span class="operator">a</span> height-balanced binary tree is defined <span class="keyword">as</span> <span class="operator">a</span> binary tree
<span class="operator">in</span> which <span class="operator">the</span> depth <span class="operator">of</span> <span class="operator">the</span> <span class="constant">two</span> subtrees <span class="operator">of</span> every node never differ <span class="keyword">by</span> more than <span class="number">1.</span>
</code></pre><p>思路：递归解决</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span>(TreeNode root) {
        <span class="keyword">if</span>(root == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="comment">// 如果子树高度差大于1，则不平衡</span>
        <span class="keyword">if</span>(Math.abs(depth(root.left)-depth(root.right)) &gt; <span class="number">1</span>){
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="comment">// 递归检查左子树和右子树的平衡性</span>
        <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);
    }

    <span class="comment">// 帮助方法，返回树的高度</span>
    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span>(TreeNode root){
        <span class="keyword">if</span>(root == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }
        <span class="keyword">return</span> <span class="number">1</span> + Math.max(depth(root.left), depth(root.right));
    }
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:4Sum]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/4sum/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/4sum/</id>
    <published>2014-06-03T05:25:59.000Z</published>
    <updated>2014-06-03T05:55:48.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">an</span> array S <span class="operator">of</span> n integers, are there elements <span class="operator">a</span>, b, c, <span class="operator">and</span> d <span class="operator">in</span> S such that <span class="operator">a</span> + b + c + d = target? 
Find all unique quadruplets <span class="operator">in</span> <span class="operator">the</span> array which gives <span class="operator">the</span> <span class="built_in">sum</span> <span class="operator">of</span> target.

Note:
Elements <span class="operator">in</span> <span class="operator">a</span> quadruplet (<span class="operator">a</span>,b,c,d) must be <span class="operator">in</span> non-<span class="keyword">descending</span> order. (ie, <span class="operator">a</span> ≤ b ≤ c ≤ d)
The solution <span class="built_in">set</span> must <span class="operator">not</span> contain duplicate quadruplets.
For example, given array S = {<span class="number">1</span> <span class="number">0</span> -<span class="number">1</span> <span class="number">0</span> -<span class="number">2</span> <span class="number">2</span>}, <span class="operator">and</span> target = <span class="number">0.</span>

A solution <span class="built_in">set</span> is:
(-<span class="number">1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)
(-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)
(-<span class="number">2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>)
</code></pre><p>思路：延伸为K-Sum问题了    我还是采用俩指针来解决= =！！</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target) {
    Arrays.sort(num);

    HashSet&lt;ArrayList&lt;Integer&gt;&gt; hashSet = <span class="keyword">new</span> HashSet&lt;ArrayList&lt;Integer&gt;&gt;();
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) {
        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num.length; j++) {
            <span class="keyword">int</span> k = j + <span class="number">1</span>;
            <span class="keyword">int</span> l = num.length - <span class="number">1</span>;

            <span class="keyword">while</span> (k &lt; l) {
                <span class="keyword">int</span> <span class="keyword">sum</span> = num[i] + num[j] + num[k] + num[l];

                <span class="keyword">if</span> (<span class="keyword">sum</span> &gt; target) {
                    l--;
                } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sum</span> &lt; target) {
                    k++;
                } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sum</span> == target) {
                    ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();
                    temp.add(num[i]);
                    temp.add(num[j]);
                    temp.add(num[k]);
                    temp.add(num[l]);

                    <span class="keyword">if</span> (!hashSet.contains(temp)) {
                        hashSet.add(temp);
                        result.add(temp);
                    }

                    k++;
                    l--;
                }
            }
        }
    }

    <span class="keyword">return</span> result;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:3Sum Cloest]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/3sumcloest/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/3sumcloest/</id>
    <published>2014-06-03T05:20:45.000Z</published>
    <updated>2014-06-03T05:55:29.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">an</span> array S <span class="operator">of</span> n integers, find <span class="constant">three</span> integers <span class="operator">in</span> S such that <span class="operator">the</span> <span class="built_in">sum</span> is closest <span class="built_in">to</span> <span class="operator">a</span> given <span class="built_in">number</span>, target.
Return <span class="operator">the</span> <span class="built_in">sum</span> <span class="operator">of</span> <span class="operator">the</span> <span class="constant">three</span> integers. You may assume that <span class="keyword">each</span> input would have exactly <span class="constant">one</span> solution.

For example, given array S = {-<span class="number">1</span> <span class="number">2</span> <span class="number">1</span> -<span class="number">4</span>}, <span class="operator">and</span> target = <span class="number">1.</span>

The <span class="built_in">sum</span> that is closest <span class="built_in">to</span> <span class="operator">the</span> target is <span class="number">2.</span> (-<span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).
</code></pre><p>思路：和3Sum问题解决方法相似，采用俩指针解法，只不过遍历过程中需要比较。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span>(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target) {
        <span class="keyword">int</span> min = Integer.MAX_VALUE;
        <span class="keyword">int</span> result = <span class="number">0</span>;

        Arrays.sort(num);

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) {
            <span class="keyword">int</span> j = i + <span class="number">1</span>;
            <span class="keyword">int</span> k = num.length - <span class="number">1</span>;
            <span class="keyword">while</span> (j &lt; k) {
                <span class="keyword">int</span> sum = num[i] + num[j] + num[k];
                <span class="keyword">int</span> diff = Math.abs(sum - target);
                <span class="keyword">if</span> (diff &lt; min) {
                    min = diff;
                    result = sum;
                }
                <span class="keyword">if</span> (sum &lt;= target) {
                    j++;
                } <span class="keyword">else</span> {
                    k--;
                }
            }
        }

        <span class="keyword">return</span> result;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:3Sum]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/3sum/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/03/数据结构与算法/LeetCode/3sum/</id>
    <published>2014-06-03T05:07:50.000Z</published>
    <updated>2014-06-03T06:00:31.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">an</span> array S <span class="operator">of</span> n integers, are there elements <span class="operator">a</span>, b, c <span class="operator">in</span> S such that <span class="operator">a</span> + b + c = <span class="number">0</span>? 
Find all unique triplets <span class="operator">in</span> <span class="operator">the</span> array which gives <span class="operator">the</span> <span class="built_in">sum</span> <span class="operator">of</span> <span class="constant">zero</span>.

Note:
Elements <span class="operator">in</span> <span class="operator">a</span> triplet (<span class="operator">a</span>,b,c) must be <span class="operator">in</span> non-<span class="keyword">descending</span> order. (ie, <span class="operator">a</span> ≤ b ≤ c)
The solution <span class="built_in">set</span> must <span class="operator">not</span> contain duplicate triplets.
For example, given array S = {-<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> -<span class="number">1</span> -<span class="number">4</span>},

A solution <span class="built_in">set</span> is:
(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)
(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>)
</code></pre><p>思路：俩指针，选中一个元素，首指针在选中元素之后，尾指针在最后一个元素，俩指针遍历。时间复杂度O（n^2）,注意重复元素，可将数据排序，移动指针。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(int[] num) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();

    <span class="keyword">if</span> (num.length &lt; <span class="number">3</span>)
        <span class="keyword">return</span> result;

    <span class="comment">// sort array</span>
    Arrays.sort(num);

    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; num.length - <span class="number">2</span>; i++) {
        <span class="comment">// //avoid duplicate solutions</span>
        <span class="keyword">if</span> (i == <span class="number">0</span> || num[i] &gt; num[i - <span class="number">1</span>]) {

            int negate = -num[i];

            int start = i + <span class="number">1</span>;
            int <span class="keyword">end</span> = num.length - <span class="number">1</span>;

            <span class="keyword">while</span> (start &lt; <span class="keyword">end</span>) {
                <span class="comment">//case 1</span>
                <span class="keyword">if</span> (num[start] + num[<span class="keyword">end</span>] == negate) {
                    ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();
                    temp.add(num[i]);
                    temp.add(num[start]);
                    temp.add(num[<span class="keyword">end</span>]);

                    result.add(temp);
                    start++;
                    <span class="keyword">end</span>--;
                    <span class="comment">//avoid duplicate solutions</span>
                    <span class="keyword">while</span> (start &lt; <span class="keyword">end</span> &amp;&amp; num[<span class="keyword">end</span>] == num[<span class="keyword">end</span> + <span class="number">1</span>])
                        <span class="keyword">end</span>--;

                    <span class="keyword">while</span> (start &lt; <span class="keyword">end</span> &amp;&amp; num[start] == num[start - <span class="number">1</span>])
                        start++;
                <span class="comment">//case 2</span>
                } <span class="keyword">else</span> <span class="keyword">if</span> (num[start] + num[<span class="keyword">end</span>] &lt; negate) {
                    start++;
                <span class="comment">//case 3</span>
                } <span class="keyword">else</span> {
                    <span class="keyword">end</span>--;
                }
            }

        }
    }

    <span class="keyword">return</span> result;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Longest Palindromic Substring]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/longestpalindromicstring/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/29/数据结构与算法/LeetCode/longestpalindromicstring/</id>
    <published>2014-05-29T03:03:23.000Z</published>
    <updated>2014-05-29T03:41:07.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> <span class="keyword">string</span> S, find <span class="operator">the</span> longest palindromic substring <span class="operator">in</span> S. 
You may assume that <span class="operator">the</span> maximum <span class="built_in">length</span> <span class="operator">of</span> S is <span class="number">1000</span>, 
<span class="operator">and</span> there exists <span class="constant">one</span> unique longest palindromic substring.
</code></pre><p>思路：求最长回文子串，本题解法较多，我是参考这个网址，用的动态规划<br><a href="https://github.com/xiangzhai/leetcode/blob/master/question/longest-palindromic-substring-part-i.md" target="_blank">https://github.com/xiangzhai/leetcode/blob/master/question/longest-palindromic-substring-part-i.md</a></p>
<h4 id="解法">解法</h4>
<pre><code><span class="built_in">String</span> longestPalindromeDP(<span class="built_in">string</span> s) {
    <span class="built_in">int</span> n = s.length();
    <span class="built_in">int</span> longestBegin = <span class="number">0</span>;
    <span class="built_in">int</span> maxLen = <span class="number">1</span>;
    boolean table[<span class="number">1000</span>][<span class="number">1000</span>] = {<span class="literal">false</span>};
    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)
        table[i][i] = <span class="literal">true</span>;
    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++) {
        <span class="keyword">if</span> (s[i] == s[i+<span class="number">1</span>]) {
            table[i][i+<span class="number">1</span>] = <span class="literal">true</span>;
            longestBegin = i;
            maxLen = <span class="number">2</span>;
        }
    }
    <span class="keyword">for</span> (<span class="built_in">int</span> <span class="built_in">len</span> = <span class="number">3</span>; <span class="built_in">len</span> &lt;= n; <span class="built_in">len</span>++) {
        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n-<span class="built_in">len</span>+<span class="number">1</span>; i++) {
            <span class="built_in">int</span> j = i + <span class="built_in">len</span> - <span class="number">1</span>;
            <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; table[i+<span class="number">1</span>][j-<span class="number">1</span>]) {
                table[i][j] = <span class="literal">true</span>;
                longestBegin = i;
                maxLen = <span class="built_in">len</span>;
            }
        }
    }
    return s.substr(longestBegin, maxLen);
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Add Two Numbers]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/addtownumber/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/29/数据结构与算法/LeetCode/addtownumber/</id>
    <published>2014-05-29T03:03:02.000Z</published>
    <updated>2014-05-29T03:16:33.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>You are given <span class="constant">two</span> linked lists representing <span class="constant">two</span> non-negative numbers. 
The digits are stored <span class="operator">in</span> reverse order <span class="operator">and</span> <span class="keyword">each</span> <span class="operator">of</span> their nodes contain <span class="operator">a</span> single digit. 
Add <span class="operator">the</span> <span class="constant">two</span> numbers <span class="operator">and</span> <span class="constant">return</span> <span class="keyword">it</span> <span class="keyword">as</span> <span class="operator">a</span> linked list.

Input: (<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)
Output: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span>
</code></pre><p>思路：处理好进位问题就行了，注意末尾进位。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> ListNode {
      <span class="keyword">int</span> val;
      ListNode next;
      ListNode(<span class="keyword">int</span> x) {
          val = x;
          next = <span class="keyword">null</span>;
      }
}
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span>(ListNode l1, ListNode l2) {
        <span class="keyword">int</span> carry=<span class="number">0</span>;
        ListNode newHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);
        ListNode p1=l1,p2=l2,p3=newHead;
        <span class="keyword">while</span>(p1!=<span class="keyword">null</span> ||p2!=<span class="keyword">null</span>){
            <span class="keyword">if</span>(p1!=<span class="keyword">null</span>){
                carry +=p1.val;
                p1=p1.next;
            }
            <span class="keyword">if</span>(p2!=<span class="keyword">null</span>){
                carry +=p2.val;
                p2=p2.next;
            }

            p3.next=<span class="keyword">new</span> ListNode(carry%<span class="number">10</span>);
            p3=p3.next;
            <span class="comment">//进位处理</span>
            carry /=<span class="number">10</span>;
        }
        <span class="comment">//最后末尾产生进位</span>
        <span class="keyword">if</span>(carry==<span class="number">1</span>)
            p3.next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);
        <span class="keyword">return</span> newHead.next;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Two Sum]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/twosum/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/数据结构与算法/LeetCode/twosum/</id>
    <published>2014-05-27T09:15:45.000Z</published>
    <updated>2014-05-27T09:20:22.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given an array <span class="keyword">of</span> integers, find two numbers such <span class="keyword">that</span> they add up <span class="keyword">to</span> a specific target <span class="type">number</span>.

The function twoSum should <span class="constant">return</span> indices <span class="keyword">of</span> <span class="keyword">the</span> two numbers such <span class="keyword">that</span> they add up <span class="keyword">to</span> <span class="keyword">the</span> target, <span class="keyword">where</span> index1 must be <span class="keyword">less than</span> index2. Please note <span class="keyword">that</span> your returned answers (both index1 <span class="keyword">and</span> index2) are <span class="keyword">not</span> zero-based.

You may assume <span class="keyword">that</span> each input would have exactly one solution.

Input: numbers={<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>}, target=<span class="number">9</span>
Output: index1=<span class="number">1</span>, index2=<span class="number">2</span>
</code></pre><p>思路：hashmap 存另外一个数及其index</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">twoSum</span>(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) {
        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();
        <span class="keyword">int</span> [] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++){
            <span class="keyword">if</span>(map.containsKey(numbers[i])){
                <span class="keyword">int</span> index=map.<span class="keyword">get</span>(numbers[i]);
                result[<span class="number">0</span>]=index+<span class="number">1</span>;
                result[<span class="number">1</span>]=i+<span class="number">1</span>;
                <span class="keyword">break</span>;
            }<span class="keyword">else</span>{
                map.put(target-numbers[i],i);
            }
        }
        <span class="keyword">return</span> result;
    }
    <span class="comment">//超时写法</span>
    <span class="comment">//    public int[]twoSum(int[]numbers,int target){</span>
    <span class="comment">//        int[]ret=new int[2];</span>
    <span class="comment">//        for(int i=0;i&lt;numbers.length;i++){</span>
    <span class="comment">//            for(int j=i+1;j&lt;numbers.length;j++){</span>
    <span class="comment">//                if(numbers[i]+numbers[j]==target){</span>
    <span class="comment">//                    ret[0]=i+1;</span>
    <span class="comment">//                    ret[1]=j+1;</span>
    <span class="comment">//                }        </span>
    <span class="comment">//            }</span>
    <span class="comment">//        }</span>
    <span class="comment">//        return ret;</span>
    <span class="comment">//    }</span>
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Reorder List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/reorderlist/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/27/数据结构与算法/LeetCode/reorderlist/</id>
    <published>2014-05-27T06:18:26.000Z</published>
    <updated>2014-05-27T06:23:39.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a singly linked <span class="type">list</span> L: L0→L1→…→Ln-<span class="number">1</span>→Ln,
reorder <span class="keyword">it</span> <span class="keyword">to</span>: L0→Ln→L1→Ln-<span class="number">1</span>→L2→Ln-<span class="number">2</span>→…

You must do this <span class="keyword">in</span>-place <span class="keyword">without</span> altering <span class="keyword">the</span> nodes' values.

For example,
Given {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}, reorder <span class="keyword">it</span> <span class="keyword">to</span> {<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>}.
</code></pre><p>思路：第一把整个链表划分成2个等长的子链表，如果原链表长度为奇数，那么第一个子链表的长度多1；第二翻转第二个子链表；第三将两个子链表合并。</p>
<h4 id="解法">解法</h4>
<pre><code>class ListNode {
      <span class="keyword">int</span> val;
      ListNode next;
      ListNode(<span class="keyword">int</span> x) {
         val = x;
          next = <span class="keyword">null</span>;
      }
}

<span class="keyword">public</span> <span class="keyword">class</span> Reorderlist {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span>(ListNode head) {
        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)
            <span class="keyword">return</span>;
        ListNode slowNode=head,fastNode=head;
        <span class="keyword">while</span>(fastNode.next!=<span class="keyword">null</span>){
            fastNode=fastNode.next;
            <span class="keyword">if</span>(fastNode.next!=<span class="keyword">null</span>)
                fastNode=fastNode.next;
            <span class="keyword">else</span>
                <span class="keyword">break</span>;
            slowNode=slowNode.next;
        }
        <span class="comment">//快慢指针确定链表中点</span>
        ListNode head1=head,head2=slowNode.next;
        slowNode.next=<span class="keyword">null</span>;
        <span class="comment">//对后半部分就行进行逆序</span>
        ListNode cur=head2,post=cur.next;
        cur.next=<span class="keyword">null</span>;
        <span class="keyword">while</span>(post!=<span class="keyword">null</span>){
            ListNode temp=post.next;
            post.next=cur;
            cur=post;
            post=temp;
        }
        head2 =cur;
        <span class="comment">//合并链表</span>
        ListNode p=head1,q=head2;
        <span class="keyword">while</span>(q!=<span class="keyword">null</span>){
            ListNode temp1=p.next;
            ListNode temp2=q.next;
            p.next=q;
            q.next=temp1;
            p=temp1;
            q=temp2;
        }
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Pow(x, n)]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/power_x_n/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/数据结构与算法/LeetCode/power_x_n/</id>
    <published>2014-05-25T11:13:08.000Z</published>
    <updated>2014-05-25T11:46:44.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Implement <span class="built_in">pow</span>(x, n).
</code></pre><p>思路：最简单的方法是循环，循环n-1遍，每次乘以x。时间复杂度：O(N)。很显然，最后超时了。并且如果用递归的话，函数好写简洁，但是碰见大数，栈空间不够用会导致运行时错误（stack overflow）。<br>二分法解决问题：x^n = x^n/2 <em> x^n/2 </em> x^n%2  n考虑奇数偶数 时间复杂度：O(logN)<br><img src="/img/数据结构与算法/2.png" alt=" "></p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span>(<span class="keyword">double</span> x, <span class="keyword">int</span> n) {
        <span class="keyword">if</span> (n == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">1.0</span>;
        <span class="keyword">double</span> half = pow(x, n/<span class="number">2</span>);
        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)
            <span class="keyword">return</span> half * half;
        <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)
            <span class="keyword">return</span> half * half * x;
        <span class="keyword">else</span> 
            <span class="keyword">return</span> half * half / x;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Single Number I and  II]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/singlenumber/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/数据结构与算法/LeetCode/singlenumber/</id>
    <published>2014-05-25T11:12:39.000Z</published>
    <updated>2014-05-25T11:31:08.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>I:
Given <span class="operator">an</span> array <span class="operator">of</span> integers, every <span class="keyword">element</span> appears twice except <span class="keyword">for</span> <span class="constant">one</span>. Find that single <span class="constant">one</span>.
II:
Given <span class="operator">an</span> array <span class="operator">of</span> integers, every <span class="keyword">element</span> appears <span class="constant">three</span> times except <span class="keyword">for</span> <span class="constant">one</span>. Find that single <span class="constant">one</span>.

Note:
Your algorithm should have <span class="operator">a</span> linear runtime complexity. Could you implement <span class="keyword">it</span> <span class="keyword">without</span> <span class="keyword">using</span> extra memory?
</code></pre><p>思路：hashmap去存数组及对应的次数即可。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="keyword">int</span>[] A) {
        <span class="keyword">if</span>(A.length==<span class="number">0</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }
        HashMap&lt;Integer,Integer&gt; hash= <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();
        <span class="keyword">for</span>(<span class="keyword">int</span> a:A){
            <span class="keyword">if</span>(hash.containsKey(a)){
                hash.put(a,hash.<span class="keyword">get</span>(a)+<span class="number">1</span>);
            }
            <span class="keyword">else</span>{
                hash.put(a,<span class="number">1</span>);
            }
        }
        <span class="keyword">for</span>(<span class="keyword">int</span> key:hash.keySet()){
            <span class="keyword">if</span>(hash.<span class="keyword">get</span>(key)==<span class="number">1</span>)
                <span class="keyword">return</span> key;
        }
        <span class="keyword">return</span> <span class="number">0</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Copy List with Random Pointer]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/copylistwithrandompointer/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/25/数据结构与算法/LeetCode/copylistwithrandompointer/</id>
    <published>2014-05-25T11:10:30.000Z</published>
    <updated>2014-05-25T11:47:03.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>A linked <span class="type">list</span> <span class="keyword">is</span> <span class="keyword">given</span> such <span class="keyword">that</span> each node <span class="keyword">contains</span> an additional random pointer which could point <span class="keyword">to</span> any node <span class="keyword">in</span> <span class="keyword">the</span> <span class="type">list</span> <span class="keyword">or</span> null.

Return a deep <span class="keyword">copy</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="type">list</span>.
</code></pre><p>思路：因为每个链表都有随机指针，遍历一遍肯定是不行的，遍历2遍，第一遍去记下next，第二遍去记下random，但是时间复杂度o(n^2),参考下面帖子想法不错，<br><a href="http://blog.csdn.net/zhaojinjia/article/details/9313275" target="_blank">http://blog.csdn.net/zhaojinjia/article/details/9313275</a>  <a href="http://blog.csdn.net/ljphhj/article/details/21832129" target="_blank">http://blog.csdn.net/ljphhj/article/details/21832129</a> <a href="http://blog.csdn.net/linhuanmars/article/details/22463599" target="_blank">http://blog.csdn.net/linhuanmars/article/details/22463599</a></p>
<p>第一步对每个节点进行扫描，复制每个节点，将新节点接在旧节点后面；第二步扫描每个旧节点，把旧结点的随机指针赋给新节点的随机指针；第三步扫描所有节点，把链表拆成两个，第一个还原原链表，而第二个就是我们要求的复制链表。因为现在链表是旧新更替，只要把每隔两个结点分别相连，对链表进行分割即可。这个方法总共进行三次线性扫描，所以时间复杂度是O(n)。而这里并不需要额外空间，所以空间复杂度是O(1)。</p>
<h4 id="解法">解法</h4>
<pre><code>class RandomListNode {
        <span class="keyword">int</span> label;
        RandomListNode next, random;
        RandomListNode(<span class="keyword">int</span> x) { <span class="keyword">this</span>.label = x; }
     };
<span class="keyword">public</span> <span class="keyword">class</span> copyListWithRandom {
    <span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span>(RandomListNode head) {
        <span class="keyword">if</span>(head ==<span class="keyword">null</span>){
            <span class="keyword">return</span> head;
        }
        RandomListNode nowNode=head;
        <span class="keyword">while</span>(nowNode !=<span class="keyword">null</span>){
            RandomListNode copyNode=<span class="keyword">new</span> RandomListNode(nowNode.label);
            copyNode.next=nowNode.next;
            nowNode.next=copyNode;
            nowNode =nowNode.next.next;
        }
        <span class="comment">//把随机节点接好</span>
        nowNode=head;
        <span class="keyword">while</span>(nowNode !=<span class="keyword">null</span>){
            <span class="keyword">if</span>(nowNode.random!=<span class="keyword">null</span>){
                nowNode.next.random=nowNode.random.next;
            }
            nowNode=nowNode.next.next;
        }
        <span class="comment">//分成两个链表，第一个链表还原，第二链表就是我们想要的</span>
        RandomListNode newHead =head.next;
        nowNode=head;
        <span class="keyword">while</span>(nowNode!=<span class="keyword">null</span>){
            <span class="comment">//还原第一个链表</span>
            RandomListNode newNode =nowNode.next;
            nowNode.next=newNode.next;
            <span class="keyword">if</span>(newNode.next!=<span class="keyword">null</span>)
                newNode.next=newNode.next.next;
            nowNode=nowNode.next;
        }
        <span class="keyword">return</span> newHead;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:String to Integer(atoi)]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/stringtointeger/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/stringtointeger/</id>
    <published>2014-05-23T12:27:57.000Z</published>
    <updated>2014-05-23T13:07:58.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>String <span class="built_in">to</span> Integer (atoi) 
Implement atoi <span class="built_in">to</span> <span class="built_in">convert</span> <span class="operator">a</span> <span class="keyword">string</span> <span class="built_in">to</span> <span class="operator">an</span> <span class="keyword">integer</span>.
</code></pre><p>思路：输入的情况比较多，空串，一串空格，空，正负数，数组越界</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringtoInteger</span> {</span>
     <span class="keyword">public</span> <span class="keyword">int</span> atoi(String <span class="keyword">str</span>) {
            <span class="comment">//空串</span>
            <span class="keyword">if</span>(<span class="keyword">str</span>==<span class="keyword">null</span>){
                <span class="keyword">return</span> <span class="number">0</span>;
            }
            <span class="comment">//一堆空格</span>
            <span class="keyword">str</span>=<span class="keyword">str</span>.trim();
            <span class="keyword">if</span>(<span class="keyword">str</span>.length()==<span class="number">0</span>){
                <span class="keyword">return</span> <span class="number">0</span>;
            }
            <span class="comment">//正负数</span>
            <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;
            <span class="keyword">int</span> i=<span class="number">0</span>;
            <span class="keyword">if</span>(<span class="keyword">str</span>.charAt(<span class="number">0</span>)==<span class="string">'-'</span>){
                flag=<span class="keyword">false</span>;
                i++;
            }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">str</span>.charAt(<span class="number">0</span>)==<span class="string">'+'</span>){
                i++;
            }
            <span class="comment">//这里一定要用比INT大的数据类型，用INT，数组刚刚越界时（自动转型），过不去</span>
            <span class="keyword">long</span>  result =<span class="number">0</span>;
            <span class="keyword">while</span>(<span class="keyword">str</span>.length()&gt;i&amp;&amp;<span class="keyword">str</span>.charAt(i)&gt;=<span class="string">'0'</span>&amp;&amp;<span class="keyword">str</span>.charAt(i)&lt;=<span class="string">'9'</span>){
                result=result*<span class="number">10</span>+<span class="keyword">str</span>.charAt(i)-<span class="string">'0'</span>;
                i++;
            }
            <span class="keyword">if</span>(!flag){
                result=-result;
            }
            <span class="keyword">if</span> (result &gt; Integer.MAX_VALUE)
                <span class="keyword">return</span> Integer.MAX_VALUE;

            <span class="keyword">if</span> (result &lt; Integer.MIN_VALUE)
                <span class="keyword">return</span> Integer.MIN_VALUE;
            <span class="keyword">return</span> (<span class="keyword">int</span>) result;
        }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Reverse Integer]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/reverinteger/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/reverinteger/</id>
    <published>2014-05-23T12:27:35.000Z</published>
    <updated>2014-05-23T13:05:17.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Reverse Integer 
Reverse digits <span class="operator">of</span> <span class="operator">an</span> <span class="keyword">integer</span>.

Example1: x = <span class="number">123</span>, <span class="constant">return</span> <span class="number">321</span>
Example2: x = -<span class="number">123</span>, <span class="constant">return</span> -<span class="number">321</span>
</code></pre><p>思路：整数各位取余</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span>(<span class="keyword">int</span> x) {
    <span class="keyword">int</span> nReverse = <span class="number">0</span>;
            <span class="keyword">while</span> (x != <span class="number">0</span>) {
                nReverse = nReverse * <span class="number">10</span> + x % <span class="number">10</span>;
                x = x / <span class="number">10</span>;
            }
            <span class="keyword">return</span> nReverse;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Linked List Cycle II]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/linkedlistcycle2/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/linkedlistcycle2/</id>
    <published>2014-05-23T12:26:02.000Z</published>
    <updated>2014-05-23T13:09:17.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Linked List Cycle II 
Given <span class="operator">a</span> linked list, <span class="constant">return</span> <span class="operator">the</span> node where <span class="operator">the</span> cycle <span class="operator">begins</span>. If there is no cycle, <span class="constant">return</span> <span class="constant">null</span>.

Follow up:
Can you solve <span class="keyword">it</span> <span class="keyword">without</span> <span class="keyword">using</span> extra <span class="constant">space</span>?
</code></pre><p>思路：此题除判断回路外还需要判断闭环的位置。依旧设置快慢指针p1,p2.假设链表长度为n，环开始的节点Y为到头节点X有a步，p1和p2在距离环开始的节点b步的Z地方相遇（按顺时针），假设相遇节点Z到环开始的节点c步（按顺时针），那么p1走的路程为a+b，p2走的路程为a+b+c+b，显然p2走的路程为p1的2倍，于是2(a+b)=a+2b+c，于是我们推出a=c。</p>
<p>知道这个结论后面的解答就很简单了，p1和p2相遇后，把p1指向头节点，然后p1,p2都一次走一步，走了c步后p1 p2相遇，该节点Y就是环开始的节点。<br><img src="/img/数据结构与算法/2.jpg" alt=""></p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">class</span> ListNode {
      <span class="built_in">int</span> val;
      ListNode <span class="keyword">next</span>;
      ListNode(<span class="built_in">int</span> x) {
         val = x;
          <span class="keyword">next</span> = <span class="literal">null</span>;
      }
}
<span class="keyword">public</span> <span class="keyword">class</span> detectCycle222 {
    <span class="keyword">public</span> ListNode detectCycle(ListNode head) {
        ListNode slow=head,fast=head;
        <span class="keyword">while</span>(<span class="literal">true</span>){
            <span class="keyword">if</span>(fast ==<span class="literal">null</span>||fast.<span class="keyword">next</span>==<span class="literal">null</span>){
                return <span class="literal">null</span>;
            }
            slow =slow.<span class="keyword">next</span>;
            fast =fast.<span class="keyword">next</span>.<span class="keyword">next</span>;
            <span class="keyword">if</span>(slow ==fast){
                break;
            }
        }
        slow=head;
        <span class="keyword">while</span>(slow!=fast){
            slow=slow.<span class="keyword">next</span>;
            fast=fast.<span class="keyword">next</span>;
        }
        return slow;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Linked List Cycle]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/linkedlistcycle/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/linkedlistcycle/</id>
    <published>2014-05-23T12:25:51.000Z</published>
    <updated>2014-05-23T13:04:27.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Linked List Cycle
Given <span class="operator">a</span> linked list, determine <span class="keyword">if</span> <span class="keyword">it</span> has <span class="operator">a</span> cycle <span class="operator">in</span> <span class="keyword">it</span>.

Follow up:
Can you solve <span class="keyword">it</span> <span class="keyword">without</span> <span class="keyword">using</span> extra <span class="constant">space</span>?
</code></pre><p>思路：设计两个快慢指针，慢节点每次移动一个节点，快节点每次移动两个节点，当快慢指针相等时，则存在闭环</p>
<h4 id="解法">解法</h4>
<pre><code>class ListNode {
      <span class="keyword">int</span> val;
      ListNode next;
      ListNode(<span class="keyword">int</span> x) {
         val = x;
          next = <span class="keyword">null</span>;
      }
}

<span class="keyword">public</span> <span class="keyword">class</span> Reorderlist {
    <span class="keyword">public</span> boolean <span class="title">hasCycle</span>(ListNode head){
        ListNode slow=head,fast=head;
        <span class="keyword">while</span>(<span class="keyword">true</span>){
            <span class="keyword">if</span>(fast ==<span class="keyword">null</span>||fast.next==<span class="keyword">null</span>){
                <span class="keyword">return</span> <span class="keyword">false</span>;
            }
            slow =slow.next;
            fast =fast.next.next;
            <span class="keyword">if</span>(slow ==fast){
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:LRU Cache]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/lrucache/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/23/数据结构与算法/LeetCode/lrucache/</id>
    <published>2014-05-23T12:24:58.000Z</published>
    <updated>2014-05-23T13:03:41.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>LRU Cache
Design <span class="operator">and</span> implement <span class="operator">a</span> data structure <span class="keyword">for</span> Least Recently Used (LRU) cache. It should support <span class="operator">the</span> following operations: <span class="built_in">get</span> <span class="operator">and</span> <span class="built_in">set</span>.

<span class="built_in">get</span>(key) - Get <span class="operator">the</span> <span class="built_in">value</span> (will always be positive) <span class="operator">of</span> <span class="operator">the</span> key <span class="keyword">if</span> <span class="operator">the</span> key exists <span class="operator">in</span> <span class="operator">the</span> cache, otherwise <span class="constant">return</span> -<span class="number">1.</span>
<span class="built_in">set</span>(key, <span class="built_in">value</span>) - Set <span class="operator">or</span> insert <span class="operator">the</span> <span class="built_in">value</span> <span class="keyword">if</span> <span class="operator">the</span> key is <span class="operator">not</span> already present. When <span class="operator">the</span> cache reached its capacity, 
                  <span class="keyword">it</span> should invalidate <span class="operator">the</span> least recently used <span class="keyword">item</span> <span class="keyword">before</span> inserting <span class="operator">a</span> <span class="built_in">new</span> <span class="keyword">item</span>.
</code></pre><p>思路：双向链表+hashmap 没有超出容量之前，新节点放在头部，有重复的话，把该节点移到头结点，超出容量的话，移除尾节点<br><img src="/img/数据结构与算法/1.png" alt="双向链表"></p>
<h4 id="解法">解法</h4>
<pre><code>import java.util.HashMap;

<span class="comment">//双链表＋HashMap</span>
class Node{
    Node prev;
    Node next;
    <span class="keyword">int</span> <span class="keyword">value</span>;
    <span class="keyword">int</span> key;
    Node(<span class="keyword">int</span> key,<span class="keyword">int</span> <span class="keyword">value</span>){
        <span class="keyword">this</span>.<span class="keyword">value</span>=<span class="keyword">value</span>;
        <span class="keyword">this</span>.key=key;
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> LRUCache {
    <span class="keyword">private</span> <span class="keyword">int</span>  capacity;
    <span class="keyword">private</span> <span class="keyword">int</span> len;
    <span class="keyword">private</span> Node head;
    <span class="keyword">private</span> Node end;
    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map =<span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();
    <span class="keyword">public</span> <span class="title">LRUCache</span>(<span class="keyword">int</span> capacity) {
        <span class="keyword">this</span>.capacity=capacity;
        len=<span class="number">0</span>;
    }
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span>(<span class="keyword">int</span> key) {
        <span class="keyword">if</span>(map.containsKey(key)){
            Node last=map.<span class="keyword">get</span>(key);
            removeNode(last);
            setHead(last);
            <span class="keyword">return</span> last.<span class="keyword">value</span>;
        }<span class="keyword">else</span>{
            <span class="keyword">return</span> -<span class="number">1</span>;
        }
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span>(Node node){
        Node cur=node;
        Node pre=cur.prev;
        Node post = cur.next;
        <span class="keyword">if</span>(pre !=<span class="keyword">null</span>){
            pre.next=post;
        }<span class="keyword">else</span>{
            <span class="comment">//前驱节点为空</span>
            head =post;
        }
        <span class="keyword">if</span>(post !=<span class="keyword">null</span>){
            post.prev=pre;
        }<span class="keyword">else</span>{
            <span class="comment">//后驱节点为空</span>
            end =pre;
        }
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHead</span>(Node node){
        node.next=head;
        node.prev=<span class="keyword">null</span>;
        <span class="keyword">if</span>(head!=<span class="keyword">null</span>){
            head.prev=node;
        }
        head=node;
        <span class="keyword">if</span>(end==<span class="keyword">null</span>){
            end=node;
        }
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> <span class="keyword">value</span>) {
        <span class="keyword">if</span>(map.containsKey(key)){
            Node oldNode=map.<span class="keyword">get</span>(key);
            oldNode.<span class="keyword">value</span>=<span class="keyword">value</span>;
            removeNode(oldNode);
            setHead(oldNode);
        }<span class="keyword">else</span>{
            Node newNode =<span class="keyword">new</span> Node(key, <span class="keyword">value</span>);
            <span class="keyword">if</span>(len&lt;capacity){
                <span class="comment">//把LRU里面的新节点放在头部</span>
                setHead(newNode);
                map.put(key, newNode);
                len++;
            }<span class="keyword">else</span>{
                <span class="comment">//超出容量，则移除尾节点</span>
                map.remove(end.key);
                end=end.prev;
                <span class="keyword">if</span>(end!=<span class="keyword">null</span>){
                    end.next=<span class="keyword">null</span>;
                }
                setHead(newNode);
                map.put(key, newNode);
            }
        }
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基础的数据结构总结]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/basicadt/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/数据结构与算法/basicadt/</id>
    <published>2014-05-22T06:22:03.000Z</published>
    <updated>2014-05-22T07:19:05.000Z</updated>
    <content type="html"><![CDATA[<h4 id="数组">数组</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> test {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        <span class="keyword">int</span> <span class="keyword">value</span>[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {  
             <span class="keyword">value</span>[i] = i;  
        }  

       traverse(<span class="keyword">value</span>);  
       insert(<span class="keyword">value</span>,<span class="number">666</span>,<span class="number">5</span>);  
       delete(<span class="keyword">value</span>,<span class="number">3</span>);
       traverse(<span class="keyword">value</span>);  
   }
    <span class="comment">//插入</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] <span class="title">insert</span>(<span class="keyword">int</span>[]old,<span class="keyword">int</span> <span class="keyword">value</span>,<span class="keyword">int</span> index){
        <span class="keyword">for</span>(<span class="keyword">int</span> k=old.length-<span class="number">1</span>;k&gt;index;k--){
            old[k]=old[k-<span class="number">1</span>];
        }
        old[index]=<span class="keyword">value</span>;
        <span class="keyword">return</span> old;
    }
    <span class="comment">//遍历</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverse</span>(<span class="keyword">int</span> data[]){
        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;data.length;j++)
            System.<span class="keyword">out</span>.print(data[j]+<span class="string">" "</span>);
        System.<span class="keyword">out</span>.println(<span class="string">" "</span>);
    }
    <span class="comment">//删除</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] <span class="title">delete</span>(<span class="keyword">int</span>[]old,<span class="keyword">int</span> index){
        <span class="keyword">for</span>(<span class="keyword">int</span> h=index;h&lt;old.length -<span class="number">1</span>;h++){
            old[h] = old[h+<span class="number">1</span>];
        }
        old[old.length-<span class="number">1</span>]=<span class="number">0</span>;
        <span class="keyword">return</span> old;
    }
}
</code></pre><h4 id="String">String</h4>
<pre><code>    这些方法应该熟记
    toCharArray() //get char <span class="keyword">array</span> <span class="keyword">of</span> a <span class="typename">String</span>
    Arrays.sort()  //sort an <span class="keyword">array</span>
    Arrays.toString(char[] a) //convert <span class="keyword">to</span> <span class="typename">string</span>
    charAt(int x) //get a char at the specific index
    length() //<span class="typename">string</span> length
    length //<span class="keyword">array</span> size 
    substring(int beginIndex) 
    substring(int beginIndex, int endIndex)
    <span class="typename">Integer</span>.valueOf()//<span class="typename">string</span> <span class="keyword">to</span> <span class="typename">integer</span>
    <span class="typename">String</span>.valueOf()/<span class="typename">integer</span> <span class="keyword">to</span> <span class="typename">string</span>
</code></pre><h4 id="链表">链表</h4>
<pre><code><span class="keyword">class</span> Node {
    <span class="built_in">int</span> val;
    Node <span class="keyword">next</span>;

    Node(<span class="built_in">int</span> x) {
        val = x;
        <span class="keyword">next</span> = <span class="literal">null</span>;
    }
}
</code></pre><h4 id="栈">栈</h4>
<pre><code>class Stack{
    Node top; 

    <span class="comment">//取栈顶</span>
    <span class="keyword">public</span> Node <span class="title">peek</span>(){
        <span class="keyword">if</span>(top != <span class="keyword">null</span>){
            <span class="keyword">return</span> top;
        }

        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    <span class="comment">//出栈</span>
    <span class="keyword">public</span> Node <span class="title">pop</span>(){
        <span class="keyword">if</span>(top == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }<span class="keyword">else</span>{
            Node temp = <span class="keyword">new</span> Node(top.val);
            top = top.next;
            <span class="keyword">return</span> temp;    
        }
    }

    <span class="comment">//入栈</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(Node n){
        <span class="keyword">if</span>(n != <span class="keyword">null</span>){
            n.next = top;
            top = n;
        }
    }
}
</code></pre><h4 id="队列">队列</h4>
<pre><code>class Queue{
    Node first, last;

    <span class="comment">//入队</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span>(Node n){
        <span class="keyword">if</span>(first == <span class="keyword">null</span>){
            first = n;
            last = first;
        }<span class="keyword">else</span>{
            last.next = n;
            last = n;
        }
    }

    <span class="comment">//出队</span>
    <span class="keyword">public</span> Node <span class="title">dequeue</span>(){
        <span class="keyword">if</span>(first == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }<span class="keyword">else</span>{
            Node temp = <span class="keyword">new</span> Node(first.val);
            first = first.next;
            <span class="keyword">return</span> temp;
        }    
    }
}
</code></pre><h4 id="树（二叉树）">树（二叉树）</h4>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">T</span>&gt; {</span>
    <span class="javadoc">/**
     * 结点类。  
     */</span>
    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> {</span>
        int value; <span class="comment">// 该节点存储的值。</span>
        Node leftChild; <span class="comment">// 指向左子节点的引用。</span>
        Node rightChild; <span class="comment">// 指向右子节点的引用。</span>
        Node(int value) {
            <span class="keyword">this</span>.value = value;
            leftChild = <span class="keyword">null</span>;
            rightChild = <span class="keyword">null</span>;
        }
    }
    <span class="keyword">private</span> Node root; <span class="comment">// 根节点。</span>
    <span class="javadoc">/**
     * 无参构造方法。
     */</span>
    BinaryTree() {
        root = <span class="keyword">null</span>;
    }
    <span class="javadoc">/**
     * 使用一个数组来构造二叉树。
     */</span>
    BinaryTree(int[] arr) {
        <span class="keyword">for</span> (int i : arr) {
            insert(i);
        }
    }
    <span class="keyword">private</span> void insert(int value) {
        root = insert(root, value);
    }
    <span class="javadoc">/**
     * 将数值插入到二叉树中，比当前结点小或等于当前结点的插在当前结点的左侧，
     * 比当前结点大的数插在当前结点的右侧，每次从根结点开始递归比较。。
     */</span>
    <span class="keyword">private</span> Node insert(Node node, int value) {
        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {
            node = <span class="keyword">new</span> Node(value);
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> (value &lt;= node.value) {
                node.leftChild = insert(node.leftChild, value);
            } <span class="keyword">else</span> {
                node.rightChild = insert(node.rightChild, value);
            }
        }
        <span class="keyword">return</span> node;
    }
    <span class="javadoc">/**
     * 访问节点：将节点的值取出来并打印。
     */</span>
    <span class="keyword">private</span> void visit(Node node) {
        <span class="javadoc">/**
         * 当节点为空时返回。
         */</span>
        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {
            <span class="keyword">return</span>;
        }
        int value = node.value;
        System.out.println(value);
    }
    <span class="javadoc">/**
     * 从指定节点作为根节点开始递归对树进行先序遍历。
     */</span>
    <span class="keyword">private</span> void preOrderTravels(Node node) {
        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {
            <span class="keyword">return</span>;
        } <span class="keyword">else</span> {   
            <span class="comment">//这里调整visit顺序 即可实现先序后序中序            </span>
            visit(node);                       
            preOrderTravels(node.leftChild);
            preOrderTravels(node.rightChild);
        }
    }
    <span class="javadoc">/**
     * 从根节点开始对整个树进行先序遍历。
     * 这里是递归做法，非递归做法，需要用到栈
     */</span>
    public void preOrderTravels() {
        preOrderTravels(root);
    }
}
</code></pre><h4 id="图">图</h4>
<pre><code>class GraphNode{ 
    <span class="keyword">int</span> val;
    GraphNode next;
    GraphNode[] neighbors;
    boolean visited;

    GraphNode(<span class="keyword">int</span> x) {
        val = x;
    }

    GraphNode(<span class="keyword">int</span> x, GraphNode[] n){
        val = x;
        neighbors = n;
    }

    <span class="keyword">public</span> String <span class="title">toString</span>(){
        <span class="keyword">return</span> <span class="string">"value: "</span>+ <span class="keyword">this</span>.val; 
    }
}

<span class="comment">//使用队列辅助广度搜索</span>
class Queue{
    GraphNode first, last;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span>(GraphNode n){
        <span class="keyword">if</span>(first == <span class="keyword">null</span>){
            first = n;
            last = first;
        }<span class="keyword">else</span>{
            last.next = n;
            last = n;
        }
    }

<span class="keyword">public</span> GraphNode <span class="title">dequeue</span>(){
        <span class="keyword">if</span>(first == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }<span class="keyword">else</span>{
            GraphNode temp = <span class="keyword">new</span> GraphNode(first.val, first.neighbors);
            first = first.next;
            <span class="keyword">return</span> temp;
        }    
    }
}
<span class="keyword">public</span> <span class="keyword">class</span> test {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]){
        GraphNode n1 = <span class="keyword">new</span> GraphNode(<span class="number">1</span>); 
        GraphNode n2 = <span class="keyword">new</span> GraphNode(<span class="number">2</span>); 
        GraphNode n3 = <span class="keyword">new</span> GraphNode(<span class="number">3</span>); 
        GraphNode n4 = <span class="keyword">new</span> GraphNode(<span class="number">4</span>); 
        GraphNode n5 = <span class="keyword">new</span> GraphNode(<span class="number">5</span>); 

        n1.neighbors = <span class="keyword">new</span> GraphNode[]{n2,n3,n5};
        n2.neighbors = <span class="keyword">new</span> GraphNode[]{n1,n4};
        n3.neighbors = <span class="keyword">new</span> GraphNode[]{n1,n4,n5};
        n4.neighbors = <span class="keyword">new</span> GraphNode[]{n2,n3,n5};
        n5.neighbors = <span class="keyword">new</span> GraphNode[]{n1,n3,n4};

    <span class="comment">//  breathFirstSearch(n1, 4);</span>
        deepFirstSearch(n1, <span class="number">4</span>);
    }
    <span class="comment">//深度搜索，递归，非递归得使用到栈</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deepFirstSearch</span>(GraphNode root,<span class="keyword">int</span> x){
    <span class="comment">//    if(root.val==x)</span>
    <span class="comment">//        System.out.println("find in root");</span>
        root.visited=<span class="keyword">true</span>;
        <span class="keyword">for</span>(GraphNode n :root.neighbors ){
            <span class="keyword">if</span>(!n.visited){
                System.<span class="keyword">out</span>.print(n+<span class="string">" "</span>);
                n.visited =<span class="keyword">true</span>;
                <span class="keyword">if</span>(n.val == x){
                    System.<span class="keyword">out</span>.print(<span class="string">"Find "</span>+n);
                }
                deepFirstSearch(n, x);
            }
        }
    }
    <span class="comment">//广度搜索</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">breathFirstSearch</span>(GraphNode root,<span class="keyword">int</span> x){
        <span class="comment">//如果搜索的值正好是根节点的值</span>
        <span class="keyword">if</span>(root.val == x)
            System.<span class="keyword">out</span>.println(<span class="string">"find in root"</span>);
        Queue queue =<span class="keyword">new</span> Queue();
        root.visited=<span class="keyword">true</span>;
        queue.enqueue(root);
        <span class="keyword">while</span>(queue.first !=<span class="keyword">null</span>){
            <span class="comment">//将节点出队</span>
            GraphNode c =queue.dequeue();
            <span class="comment">//遍历邻居节点</span>
            <span class="keyword">for</span>(GraphNode n:c.neighbors){
                <span class="comment">//访问没访问过的节点</span>
                <span class="keyword">if</span>(!n.visited){
                    System.<span class="keyword">out</span>.print(n+ <span class="string">" "</span>);
                    n.visited =<span class="keyword">true</span>;
                    <span class="keyword">if</span>(n.val == x){
                        System.<span class="keyword">out</span>.print(<span class="string">"Find "</span>+n);
                    }
                    <span class="comment">//将访问过的节点从新入队</span>
                    queue.enqueue(n);
                }
            }
        }
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Insertion Sort List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/insertsortlist/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/05/22/数据结构与算法/LeetCode/insertsortlist/</id>
    <published>2014-05-22T05:48:59.000Z</published>
    <updated>2014-05-22T06:20:21.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Sort <span class="operator">a</span> linked list <span class="keyword">using</span> insertion <span class="built_in">sort</span>.
</code></pre><h6 id="插入排序大致思路">插入排序大致思路</h6>
<ul>
<li>设数组为a[0…n-1]。</li>
<li>初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1</li>
<li>将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。</li>
<li>i++并重复第二步直到i==n-1。排序完成。 </li>
</ul>
<h4 id="解法">解法</h4>
<pre><code>该题是在链表中使用插入排序，其思路都是一样的
<span class="keyword">class</span> ListNode {
     int <span class="keyword">val</span>;
     ListNode next;
     ListNode(int x) {
         <span class="keyword">val</span> = x;
         next = <span class="keyword">null</span>;
    }
 }
<span class="keyword">public</span> <span class="keyword">class</span> insertSortList {
    <span class="keyword">public</span> ListNode insertionSortList(ListNode head){
        <span class="keyword">if</span>(head ==<span class="keyword">null</span> ||head.next==<span class="keyword">null</span>)
            <span class="keyword">return</span> head;
        ListNode cur =head.next;
        <span class="keyword">while</span>(cur !=<span class="keyword">null</span>){
            ListNode tmp=head;
            <span class="comment">//用tmp节点代表有序区的最后一个节点</span>
            <span class="keyword">while</span>(tmp.<span class="keyword">val</span>&lt;cur.<span class="keyword">val</span> &amp;&amp; tmp!=cur)
                tmp=tmp.next;
            <span class="keyword">if</span>(tmp !=cur){
                <span class="keyword">while</span>(tmp !=cur){
                    int tmpvalue=tmp.<span class="keyword">val</span>;
                    tmp.<span class="keyword">val</span>=cur.<span class="keyword">val</span>;
                    cur.<span class="keyword">val</span>=tmpvalue;
                    tmp=tmp.next;
                }
            }
            cur =cur.next;
        }
        <span class="keyword">return</span> head;
    }

}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
