<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[DaMinger's blog]]></title>
  <subtitle><![CDATA[信春哥，系统稳，闭眼上线不回滚]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://github.com/DaMinger/DaMinger.github.io.git/"/>
  <updated>2014-06-09T12:46:50.277Z</updated>
  <id>https://github.com/DaMinger/DaMinger.github.io.git/</id>
  
  <author>
    <name><![CDATA[DaMinger]]></name>
    <email><![CDATA[564400632@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[剑指offer:编写一个方法，将字符串的空格全部替换为“%20”]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer_02/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/09/数据结构与算法/剑指offer/剑指offer_02/</id>
    <published>2014-06-09T12:36:07.000Z</published>
    <updated>2014-06-09T12:44:35.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>编写一个方法，将字符串的空格全部替换为“<span class="variable">%20</span>”。
假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。
（注：用JAVA实现的话，请使用字符数组实现，以便直接在数组上操作）
</code></pre><p>思路：从尾部扫描，第一次扫描先数出字符串中有多少空格，算出最终的字符串有多长，第二次扫描，遇到空格则将%20复制到下一个位置，如不是空格，就复制原先的字符</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span>  <span class="keyword">void</span> replaceSpace(<span class="keyword">char</span>[]<span class="keyword">str</span>，<span class="keyword">int</span> length){
        <span class="keyword">if</span>(<span class="keyword">str</span>==<span class="keyword">null</span>||<span class="keyword">str</span>.length==<span class="number">0</span>)
            <span class="keyword">return</span>;
        <span class="keyword">int</span> spaceCount=<span class="number">0</span>,i,newlength;
        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++){
            <span class="keyword">if</span>(<span class="keyword">str</span>[i]==<span class="string">' '</span>){
                spaceCount++;
            }
        }
        newlength=length+spaceCount*<span class="number">2</span>;
        <span class="comment">//java不会再最后自动加\0，c语言，c++才会</span>
        <span class="keyword">str</span>[newlength]=<span class="string">'\0'</span>;
        <span class="keyword">for</span>(i=length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--){
            <span class="keyword">if</span>(<span class="keyword">str</span>[i]==<span class="string">' '</span>){
                <span class="keyword">str</span>[newlength-<span class="number">1</span>]=<span class="string">'0'</span>;
                <span class="keyword">str</span>[newlength-<span class="number">2</span>]=<span class="string">'2'</span>;
                <span class="keyword">str</span>[newlength-<span class="number">3</span>]=<span class="string">'%'</span>;
                newlength=newlength-<span class="number">3</span>;
            }<span class="keyword">else</span>{
                <span class="keyword">str</span>[newlength-<span class="number">1</span>]=<span class="keyword">str</span>[i];
                newlength=newlength-<span class="number">1</span>;
            }
        }
    }
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[剑指offer:在一个二维数组中判断给定整数是否存在，要求在O(n)内实现]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer_01/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/08/数据结构与算法/剑指offer/剑指offer_01/</id>
    <published>2014-06-08T02:12:52.000Z</published>
    <updated>2014-06-08T02:35:05.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>在一个二维数组中，每一行元素从左到右递增，从上到下递增，现输入一个整数，
判断数组中是否存在该整数，要求时间复杂度为<span class="keyword">O</span>(n)
</code></pre><p>思路：可以数组分为三个部分，数组右上角，左边，下面，数组如下</p>
<pre><code>
    1  2  8  9
    2  4  9  12
    4  7  10 13
    6  8  11 15
</code></pre>

<p>查找元需为7，数组右上角元素为9，因为7&lt;9,则在9左边的三列中寻找7元素，将col减1</p>
<pre><code>
    1  2  8
    2  4  9
    4  7  10
    6  8  11
</code></pre>

<p>再取数组右上角元素8，7&lt;8,则在8左边的两列中寻找7元素，将col减1</p>
<pre><code>    
    1  2
    2  4
    4  7
    6  8
</code></pre>

<p>再取数组右上角元素2，7&gt;2,则在2下边三行中寻找元素7</p>
<pre><code>    
    2  4 
    4  7
    6  8
</code></pre>

<p>再取数组的右上角元素4，7&gt;4，则在4下边2行中寻找</p>
<pre><code>        
    4  7
    6  8
</code></pre>    

<p>再取数组的右上角元素7，7==4,返回，查找成功</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getPos</span>(<span class="keyword">int</span> [][]a, <span class="keyword">int</span> key)
    {
        <span class="keyword">int</span> col = a[<span class="number">0</span>].length - <span class="number">1</span>;
        <span class="keyword">int</span> row = <span class="number">0</span>;
        <span class="keyword">while</span>(a[row][col] != key)
        {
            <span class="keyword">if</span>(a[row][col] &gt; key)
            {
                --col;
            }
            <span class="keyword">else</span>
            {
                ++row;
            }
        }
        <span class="keyword">if</span>(a[row][col] == key)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span> 
            <span class="keyword">return</span> <span class="keyword">false</span>;
    }
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Word Ladder I]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/word_ladder_i/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/数据结构与算法/LeetCode/word_ladder_i/</id>
    <published>2014-06-06T05:20:53.000Z</published>
    <updated>2014-06-06T05:27:49.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given two <span class="property">words</span> (start <span class="keyword">and</span> <span class="keyword">end</span>), <span class="keyword">and</span> a dictionary, find <span class="keyword">the</span> <span class="property">length</span> <span class="keyword">of</span> shortest transformation sequence <span class="keyword">from</span> start <span class="keyword">to</span> <span class="keyword">end</span>, such <span class="keyword">that</span>:

Only one letter can be changed <span class="keyword">at</span> a <span class="property">time</span>
Each intermediate <span class="property">word</span> must exist <span class="keyword">in</span> <span class="keyword">the</span> dictionary
For example,

Given:
start = <span class="string">"hit"</span>
<span class="keyword">end</span> = <span class="string">"cog"</span>
dict = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]
As one shortest transformation <span class="keyword">is</span> <span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span>,
<span class="command">return</span> <span class="keyword">its</span> <span class="property">length</span> <span class="number">5.</span>
</code></pre><p>思路：把它看成一颗树，用两个队列，一个储存节点，一个储存距离，BFS即可</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span>(String start, String end, HashSet&lt;String&gt; dict) {

        <span class="keyword">if</span> (dict.size() == <span class="number">0</span>)  
            <span class="keyword">return</span> <span class="number">0</span>; 

        LinkedList&lt;String&gt; wordQueue = <span class="keyword">new</span> LinkedList&lt;String&gt;();
        LinkedList&lt;Integer&gt; distanceQueue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();

        wordQueue.add(start);
        distanceQueue.add(<span class="number">1</span>);


        <span class="keyword">while</span>(!wordQueue.isEmpty()){
            String currWord = wordQueue.pop();
            Integer currDistance = distanceQueue.pop();

            <span class="keyword">if</span>(currWord.equals(end)){
                <span class="keyword">return</span> currDistance;
            }

            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;currWord.length(); i++){
                <span class="keyword">char</span>[] currCharArr = currWord.toCharArray();
                <span class="keyword">for</span>(<span class="keyword">char</span> c=<span class="string">'a'</span>; c&lt;=<span class="string">'z'</span>; c++){
                    currCharArr[i] = c;

                    String newWord = <span class="keyword">new</span> String(currCharArr);
                    <span class="keyword">if</span>(dict.contains(newWord)){
                        wordQueue.add(newWord);
                        distanceQueue.add(currDistance+<span class="number">1</span>);
                        dict.remove(newWord);
                    }
                }
            }
        }

        <span class="keyword">return</span> <span class="number">0</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Word Break I]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/word_break_i/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/数据结构与算法/LeetCode/word_break_i/</id>
    <published>2014-06-06T05:15:12.000Z</published>
    <updated>2014-06-06T05:25:51.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> <span class="keyword">string</span> s <span class="operator">and</span> <span class="operator">a</span> dictionary <span class="operator">of</span> <span class="keyword">words</span> dict, determine <span class="keyword">if</span> s can be segmented <span class="keyword">into</span> <span class="operator">a</span> <span class="constant">space</span>-separated sequence <span class="operator">of</span> <span class="constant">one</span> <span class="operator">or</span> more dictionary <span class="keyword">words</span>.

For example, given
s = <span class="string">"leetcode"</span>,
dict = [<span class="string">"leet"</span>, <span class="string">"code"</span>].

Return <span class="constant">true</span> because <span class="string">"leetcode"</span> can be segmented <span class="keyword">as</span> <span class="string">"leet code"</span>.
</code></pre><p>思路：动态规划，定义array t[]，当t[i]==true， 0-(i-1) 能被字典分段</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span>
    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span>(String s, Set&lt;String&gt; dict) {
        <span class="keyword">boolean</span>[] t = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];
        t[<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">//set first to be true</span>

        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++){
            <span class="comment">//should continue from match position</span>
            <span class="keyword">if</span>(!t[i]) 
                <span class="keyword">continue</span>;

            <span class="keyword">for</span>(String a: dict){
                <span class="keyword">int</span> len = a.length();
                <span class="keyword">int</span> end = i + len;
                <span class="keyword">if</span>(end &gt; s.length())
                    <span class="keyword">continue</span>;

                <span class="keyword">if</span>(t[end]) <span class="keyword">continue</span>;

                <span class="keyword">if</span>(s.substring(i, end).equals(a)){
                    t[end] = <span class="keyword">true</span>;
                }
            }
        }

        <span class="keyword">return</span> t[s.length()];
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Validate Binary Search Tree]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/validate_binary_search_tree/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/数据结构与算法/LeetCode/validate_binary_search_tree/</id>
    <published>2014-06-06T05:11:05.000Z</published>
    <updated>2014-06-06T05:13:41.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a binary tree, determine <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> a valid binary search tree (BST).

Assume a BST <span class="keyword">is</span> defined <span class="keyword">as</span> follows:

The left subtree <span class="keyword">of</span> a node <span class="keyword">contains</span> only nodes <span class="keyword">with</span> keys <span class="keyword">less than</span> <span class="keyword">the</span> node's key.
The right subtree <span class="keyword">of</span> a node <span class="keyword">contains</span> only nodes <span class="keyword">with</span> keys <span class="keyword">greater than</span> <span class="keyword">the</span> node's key.
Both <span class="keyword">the</span> left <span class="keyword">and</span> right subtrees must also be binary search trees.
confused what <span class="string">"{1,#,2,3}"</span> means? &gt; <span class="command">read</span> more <span class="function_start"><span class="keyword">on</span></span> how binary tree <span class="keyword">is</span> serialized <span class="function_start"><span class="keyword">on</span></span> OJ.
</code></pre><p>思路：递归</p>
<h4 id="解法">解法</h4>
<pre><code><span class="comment">//  Definition for binary tree</span>
class TreeNode {
    <span class="keyword">int</span> val;
    TreeNode left;
    TreeNode right;

    TreeNode(<span class="keyword">int</span> x) {
        val = x;
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span>(TreeNode root) {
        <span class="keyword">return</span> validate(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validate</span>(TreeNode root, <span class="keyword">int</span> min, <span class="keyword">int</span> max) {
        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }

        <span class="comment">// not in range</span>
        <span class="keyword">if</span> (root.val &lt;= min || root.val &gt;= max) {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }

        <span class="comment">// left subtree must be &lt; root.val &amp;&amp; right subtree must be &gt; root.val</span>
        <span class="keyword">return</span> validate(root.left, min, root.val) &amp;&amp; validate(root.right, root.val, max);
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Triangle]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/triangle/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/数据结构与算法/LeetCode/triangle/</id>
    <published>2014-06-06T05:03:10.000Z</published>
    <updated>2014-06-06T05:32:08.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a triangle, find <span class="keyword">the</span> minimum path sum <span class="keyword">from</span> top <span class="keyword">to</span> bottom. Each step you may move <span class="keyword">to</span> adjacent numbers <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> row <span class="keyword">below</span>.

For example, <span class="keyword">given</span> <span class="keyword">the</span> following triangle
[
     [<span class="number">2</span>],
    [<span class="number">3</span>,<span class="number">4</span>],
   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],
  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]
]
The minimum path sum <span class="keyword">from</span> top <span class="keyword">to</span> bottom <span class="keyword">is</span> <span class="number">11</span> (i.e., <span class="number">2</span> + <span class="number">3</span> + <span class="number">5</span> + <span class="number">1</span> = <span class="number">11</span>).

Note:
Bonus point <span class="keyword">if</span> you are able <span class="keyword">to</span> do this using only O(n) extra <span class="constant">space</span>, <span class="keyword">where</span> n <span class="keyword">is</span> <span class="keyword">the</span> total <span class="type">number</span> <span class="keyword">of</span> rows <span class="keyword">in</span> <span class="keyword">the</span> triangle.
</code></pre><p>思路：经典动态规划问题，可以定义成dp[node]表示从当前node到bottom的最小路径和，对于最下面一层，因为它们是最底层，故它们到bottom的最小路径和就是它们自身；再往上一层，最小路径就是该节点加上该节点肩上的两个点的最小值。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span>(List&lt;List&lt;Integer&gt;&gt; triangle) {
        <span class="keyword">if</span>(triangle==<span class="keyword">null</span>||triangle.size()==<span class="number">0</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }
        <span class="keyword">int</span> row=triangle.size();
        <span class="keyword">int</span> []num=<span class="keyword">new</span> <span class="keyword">int</span>[row];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=row-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--){
            <span class="keyword">int</span> col=triangle.<span class="keyword">get</span>(i).size();
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++){
                <span class="comment">//最底层赋值</span>
                <span class="keyword">if</span>(i==row-<span class="number">1</span>){
                    num[j]=triangle.<span class="keyword">get</span>(i).<span class="keyword">get</span>(j);
                    <span class="keyword">continue</span>;
                }
                num[j]=Math.min(num[j],num[j+<span class="number">1</span>])+ triangle.<span class="keyword">get</span>(i).<span class="keyword">get</span>(j);
            }
        }
        <span class="keyword">return</span> num[<span class="number">0</span>];
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Same Tree]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/same_tree/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/数据结构与算法/LeetCode/same_tree/</id>
    <published>2014-06-06T05:00:13.000Z</published>
    <updated>2014-06-06T05:02:17.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given two binary trees, <span class="command">write</span> a function <span class="keyword">to</span> check <span class="keyword">if</span> they are <span class="keyword">equal</span> <span class="keyword">or</span> <span class="keyword">not</span>.

Two binary trees are considered <span class="keyword">equal</span> <span class="keyword">if</span> they are structurally identical <span class="keyword">and</span> <span class="keyword">the</span> nodes have <span class="keyword">the</span> same value.
</code></pre><p>思路：递归比较</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> boolean <span class="title">isSameTree</span>(TreeNode p, TreeNode q) {
        <span class="keyword">if</span>(p==<span class="keyword">null</span>&amp;&amp;q==<span class="keyword">null</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="keyword">null</span>||q==<span class="keyword">null</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(p.val==q.val)
            <span class="keyword">return</span> isSameTree(p.left,q.left)&amp;&amp;isSameTree(q.right, p.right);
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Swap Nodes in Pairs]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/swap_nodes_in_pairs/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/数据结构与算法/LeetCode/swap_nodes_in_pairs/</id>
    <published>2014-06-06T04:55:54.000Z</published>
    <updated>2014-06-06T04:59:10.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a linked <span class="type">list</span>, swap <span class="keyword">every</span> two adjacent nodes <span class="keyword">and</span> <span class="constant">return</span> <span class="keyword">its</span> head.

For example,
Given <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>, you should <span class="constant">return</span> <span class="keyword">the</span> <span class="type">list</span> <span class="keyword">as</span> <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3.</span>

Your algorithm should use only <span class="type">constant</span> <span class="constant">space</span>. You may <span class="keyword">not</span> modify <span class="keyword">the</span> values <span class="keyword">in</span> <span class="keyword">the</span> <span class="type">list</span>, only nodes itself can be changed.
</code></pre><p>思路：递归遍历链表，每两个改变指针指向</p>
<h4 id="解法">解法</h4>
<pre><code><span class="javadoc">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span>
    <span class="keyword">public</span> ListNode <span class="title">swapPairs</span>(ListNode head) {
        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;
        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;
        ListNode first = head;
        ListNode second = head.next;
        ListNode third = second.next;
        second.next = first;
        first.next = swapPairs(third);
        <span class="keyword">return</span> second;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Search Insert Position]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/search_insert_position/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/06/数据结构与算法/LeetCode/search_insert_position/</id>
    <published>2014-06-06T04:49:56.000Z</published>
    <updated>2014-06-06T04:54:17.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a sorted array <span class="keyword">and</span> a target value, <span class="constant">return</span> <span class="keyword">the</span> index <span class="keyword">if</span> <span class="keyword">the</span> target <span class="keyword">is</span> found. If <span class="keyword">not</span>, <span class="constant">return</span> <span class="keyword">the</span> index <span class="keyword">where</span> <span class="keyword">it</span> would be <span class="keyword">if</span> <span class="keyword">it</span> were inserted <span class="keyword">in</span> order.

You may assume no duplicates <span class="keyword">in</span> <span class="keyword">the</span> array.

Here are few examples.
[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">5</span> → <span class="number">2</span>
[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">2</span> → <span class="number">1</span>
[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">7</span> → <span class="number">4</span>
[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">0</span> → <span class="number">0</span>
</code></pre><p>思路：方法一是遍历去找，方法二是二分法</p>
<h4 id="解法">解法</h4>
<pre><code><span class="comment">//方法一</span>
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span>(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target) {

        <span class="keyword">if</span>(A==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;

        <span class="keyword">if</span>(target &lt;= A[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;

        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.length-<span class="number">1</span>; i++){
            <span class="keyword">if</span>(target &gt; A[i] &amp;&amp; target &lt;= A[i+<span class="number">1</span>]){
                <span class="keyword">return</span> i+<span class="number">1</span>;
            }
        }

        <span class="keyword">return</span> A.length;
    }
}
<span class="comment">//方法二</span>
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span>(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target) {
        <span class="keyword">if</span>(A==<span class="keyword">null</span>||A.length==<span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;

        <span class="keyword">return</span> searchInsert(A,target,<span class="number">0</span>,A.length-<span class="number">1</span>);
    }

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span>(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end){
        <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;

        <span class="keyword">if</span>(target==A[mid]) 
            <span class="keyword">return</span> mid;
        <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;A[mid]) 
            <span class="keyword">return</span> start&lt;mid?searchInsert(A,target,start,mid-<span class="number">1</span>):start;
        <span class="keyword">else</span> 
            <span class="keyword">return</span> end&gt;mid?searchInsert(A,target,mid+<span class="number">1</span>,end):(end+<span class="number">1</span>);
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Search for a Range]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/search_for_a_range/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/search_for_a_range/</id>
    <published>2014-06-05T02:13:08.000Z</published>
    <updated>2014-06-05T02:21:34.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a sorted array <span class="keyword">of</span> integers, find <span class="keyword">the</span> starting <span class="keyword">and</span> ending position <span class="keyword">of</span> a <span class="keyword">given</span> target value.

Your algorithm's runtime complexity must be <span class="keyword">in</span> <span class="keyword">the</span> order <span class="keyword">of</span> O(<span class="command">log</span> n).

If <span class="keyword">the</span> target <span class="keyword">is</span> <span class="keyword">not</span> found <span class="keyword">in</span> <span class="keyword">the</span> array, <span class="constant">return</span> [-<span class="number">1</span>, -<span class="number">1</span>].

For example,
Given [<span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>] <span class="keyword">and</span> target value <span class="number">8</span>,
<span class="command">return</span> [<span class="number">3</span>, <span class="number">4</span>].
</code></pre><p>思路：就是先用二分查找找到其中一个target，然后再往左右找到target的边缘。找边缘的方法跟二分查找仍然是一样的，只是切半的条件变成相等，或者不等（往左边找则是小于，往右边找则是大于）。这样下来总共进行了三次二分查找，所以算法的时间复杂度仍是O(logn)，空间复杂度是O(1)。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">searchRange</span>(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target) {
    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];
    res[<span class="number">0</span>] = -<span class="number">1</span>;
    res[<span class="number">1</span>] = -<span class="number">1</span>;
    <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)
    {
        <span class="keyword">return</span> res;
    }
    <span class="keyword">int</span> l=<span class="number">0</span>;
    <span class="keyword">int</span> r=A.length-<span class="number">1</span>;
    <span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;
    <span class="keyword">while</span>(l&lt;=r)
    {
        m=(l+r)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[m]==target)
        {
            res[<span class="number">0</span>]=m;
            res[<span class="number">1</span>]=m;
            <span class="keyword">break</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(A[m]&gt;target)
        {
            r = m-<span class="number">1</span>;
        }
        <span class="keyword">else</span>
        {
            l = m+<span class="number">1</span>;
        }
    }
    <span class="keyword">if</span>(A[m]!=target)
        <span class="keyword">return</span> res;
    <span class="keyword">int</span> newL = m;
    <span class="keyword">int</span> newR = A.length-<span class="number">1</span>;
    <span class="keyword">while</span>(newL&lt;=newR)
    {
        <span class="keyword">int</span> newM=(newL+newR)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[newM]==target)
        {
            newL = newM+<span class="number">1</span>;
        }
        <span class="keyword">else</span>
        {
            newR = newM-<span class="number">1</span>;
        }            
    }
    res[<span class="number">1</span>]=newR;
    newL = <span class="number">0</span>;
    newR = m;
    <span class="keyword">while</span>(newL&lt;=newR)
    {
        <span class="keyword">int</span> newM=(newL+newR)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[newM]==target)
        {
            newR = newM-<span class="number">1</span>;
        }
        <span class="keyword">else</span>
        {
            newL = newM+<span class="number">1</span>;
        }            
    }
    res[<span class="number">0</span>]=newL;        
    <span class="keyword">return</span> res;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Search a 2D Matrix]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/search_a_2d_matrix/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/search_a_2d_matrix/</id>
    <published>2014-06-05T02:08:06.000Z</published>
    <updated>2014-06-05T02:11:45.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Write an efficient algorithm <span class="keyword">that</span> searches <span class="keyword">for</span> a value <span class="keyword">in</span> an m x n matrix. This matrix has <span class="keyword">the</span> following properties:

Integers <span class="keyword">in</span> each row are sorted <span class="keyword">from</span> left <span class="keyword">to</span> right.
The <span class="keyword">first</span> <span class="type">integer</span> <span class="keyword">of</span> each row <span class="keyword">is</span> <span class="keyword">greater than</span> <span class="keyword">the</span> <span class="keyword">last</span> <span class="type">integer</span> <span class="keyword">of</span> <span class="keyword">the</span> previous row.
For example,

Consider <span class="keyword">the</span> following matrix:

[
  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],
  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],
  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]
]
Given target = <span class="number">3</span>, <span class="constant">return</span> <span class="constant">true</span>.
</code></pre><p>思路：二分查找</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
   <span class="keyword">public</span> boolean <span class="title">searchMatrix</span>(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target) {
    <span class="keyword">int</span> row = matrix.length;
    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;
    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[row * col];
    <span class="keyword">int</span> count = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) {
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) {
        temp[count++] = matrix[i][j];
      }
    }
    <span class="keyword">int</span> low = <span class="number">0</span>;
    <span class="keyword">int</span> high = row * col-<span class="number">1</span>;
    <span class="keyword">int</span> mid = -<span class="number">1</span>;
    <span class="keyword">while</span> (low &lt;= high) {
      mid = (low + high) / <span class="number">2</span>;
      <span class="keyword">if</span> (temp[mid] == target) {
        <span class="keyword">return</span> <span class="keyword">true</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (temp[mid] &gt; target) {
        high = mid - <span class="number">1</span>;
      } <span class="keyword">else</span> {
        low = mid + <span class="number">1</span>;
      }
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
  }
}
<span class="comment">//参考网上的，空间复杂度比上一种降低</span>
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
   <span class="keyword">public</span> boolean <span class="title">searchMatrix</span>(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target) {
    <span class="keyword">int</span> row = matrix.length;
    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;
    <span class="keyword">int</span> low = <span class="number">0</span>;
    <span class="keyword">int</span> high = row * col - <span class="number">1</span>;
    <span class="keyword">int</span> mid = -<span class="number">1</span>;
    <span class="keyword">while</span> (low &lt;= high) {
      mid = (low + high) / <span class="number">2</span>;
      <span class="keyword">if</span> (matrix[mid/col][mid%col] == target) {
        <span class="keyword">return</span> <span class="keyword">true</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid/col][mid%col] &gt; target) {
        high = mid - <span class="number">1</span>;
      } <span class="keyword">else</span> {
        low = mid + <span class="number">1</span>;
      }
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
   }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Remove Duplicates from Sorted List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/remove_duplicates_from_sorted_list/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/remove_duplicates_from_sorted_list/</id>
    <published>2014-06-05T02:04:18.000Z</published>
    <updated>2014-06-05T02:06:35.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a sorted linked <span class="built_in">list</span>, delete <span class="literal">all</span> duplicates such that each element appear only once<span class="built_in">.</span>

For example,
Given <span class="number">1</span><span class="subst">-&gt;</span><span class="number">1</span><span class="subst">-&gt;</span><span class="number">2</span>, <span class="keyword">return</span> <span class="number">1</span><span class="subst">-&gt;</span><span class="number">2.</span>
Given <span class="number">1</span><span class="subst">-&gt;</span><span class="number">1</span><span class="subst">-&gt;</span><span class="number">2</span><span class="subst">-&gt;</span><span class="number">3</span><span class="subst">-&gt;</span><span class="number">3</span>, <span class="keyword">return</span> <span class="number">1</span><span class="subst">-&gt;</span><span class="number">2</span><span class="subst">-&gt;</span><span class="number">3.</span>
</code></pre><h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span>(ListNode head) {
        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)
            <span class="keyword">return</span> head;

        ListNode p = head;

        <span class="keyword">while</span>( p!= <span class="keyword">null</span> &amp;&amp; p.next != <span class="keyword">null</span>){
            <span class="keyword">if</span>(p.val == p.next.val){
                p.next = p.next.next;
            }<span class="keyword">else</span>{
                p = p.next; 
            }
        }

        <span class="keyword">return</span> head;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Remove Duplicates from Sorted Array II]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/remove_duplicates_from_sorted_array_ii/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/remove_duplicates_from_sorted_array_ii/</id>
    <published>2014-06-05T02:01:29.000Z</published>
    <updated>2014-06-05T02:03:49.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Follow up <span class="keyword">for</span> <span class="string">"Remove Duplicates"</span>:
What <span class="keyword">if</span> duplicates are allowed at most twice?

<span class="keyword">For</span> example,
Given sorted <span class="keyword">array</span> A = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>],

Your <span class="keyword">function</span> should <span class="keyword">return</span> length = <span class="number">5</span>, <span class="keyword">and</span> A <span class="keyword">is</span> now [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>].
</code></pre><p>思路：俩指针</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span>(<span class="keyword">int</span>[] A) {
        <span class="keyword">if</span> (A.length &lt;= <span class="number">2</span>)
            <span class="keyword">return</span> A.length;

        <span class="keyword">int</span> prev = <span class="number">1</span>; <span class="comment">// point to previous</span>
        <span class="keyword">int</span> curr = <span class="number">2</span>; <span class="comment">// point to current</span>

        <span class="keyword">while</span> (curr &lt; A.length) {
            <span class="keyword">if</span> (A[curr] == A[prev] &amp;&amp; A[curr] == A[prev - <span class="number">1</span>]) {
                curr++;
            } <span class="keyword">else</span> {
                prev++;
                A[prev] = A[curr];
                curr++;
            }
        }

        <span class="keyword">return</span> prev + <span class="number">1</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Remove Duplicates from Sorted Array]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/remove_duplicates_from_sorted_array/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/remove_duplicates_from_sorted_array/</id>
    <published>2014-06-05T01:52:17.000Z</published>
    <updated>2014-06-05T01:59:29.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> sorted array, remove <span class="operator">the</span> duplicates <span class="operator">in</span> place such that <span class="keyword">each</span> <span class="keyword">element</span> appear only once <span class="operator">and</span> <span class="constant">return</span> <span class="operator">the</span> <span class="built_in">new</span> <span class="built_in">length</span>.

Do <span class="operator">not</span> allocate extra <span class="constant">space</span> <span class="keyword">for</span> another array, you must <span class="built_in">do</span> this <span class="operator">in</span> place <span class="operator">with</span> <span class="built_in">constant</span> memory.

For example,
Given input array A = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],

Your <span class="function"><span class="keyword">function</span> <span class="title">should</span> <span class="title">return</span> <span class="title">length</span> = <span class="title">2</span>, <span class="title">and</span> <span class="title">A</span> <span class="title">is</span> <span class="title">now</span> [<span class="title">1</span>,<span class="title">2</span>].</span>
</code></pre><h4 id="解法">解法</h4>
<pre><code><span class="comment">//这种写法有BUG，能返回数组各不相同的元素的个数，但A数组可能不对</span>
<span class="comment">//{1, 2, 2, 3, 3}-&gt;{1, 2, 3, 3, 3}  正确的数组应该是{1, 2, 3}</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicatesNaive</span>(<span class="keyword">int</span>[] A) {
    <span class="keyword">if</span> (A.length &lt; <span class="number">2</span>)
        <span class="keyword">return</span> A.length;

    <span class="keyword">int</span> j = <span class="number">0</span>;
    <span class="keyword">int</span> i = <span class="number">1</span>;

    <span class="keyword">while</span> (i &lt; A.length) {
        <span class="keyword">if</span> (A[i] == A[j]) {
            i++;
        } <span class="keyword">else</span> {
            j++;
            A[j] = A[i];
            i++;
        }
    }

    <span class="keyword">return</span> j + <span class="number">1</span>;
}
<span class="comment">//解法2</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] <span class="title">removeDuplicates</span>(<span class="keyword">int</span>[] A) {
    <span class="keyword">if</span> (A.length &lt; <span class="number">2</span>)
        <span class="keyword">return</span> A;

    <span class="keyword">int</span> j = <span class="number">0</span>;
    <span class="keyword">int</span> i = <span class="number">1</span>;

    <span class="keyword">while</span> (i &lt; A.length) {
        <span class="keyword">if</span> (A[i] == A[j]) {
            i++;
        } <span class="keyword">else</span> {
            j++;
            A[j] = A[i];
            i++;
        }
    }

    <span class="keyword">int</span>[] B = Arrays.copyOf(A, j + <span class="number">1</span>);

    <span class="keyword">return</span> B;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Reverse Nodes in k-Group]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/reverse_nodes_in_k-group/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/reverse_nodes_in_k-group/</id>
    <published>2014-06-05T01:46:26.000Z</published>
    <updated>2014-06-05T01:50:07.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a linked <span class="type">list</span>, <span class="property">reverse</span> <span class="keyword">the</span> nodes <span class="keyword">of</span> a linked <span class="type">list</span> k <span class="keyword">at</span> a <span class="property">time</span> <span class="keyword">and</span> <span class="constant">return</span> <span class="keyword">its</span> modified <span class="type">list</span>.

If <span class="keyword">the</span> <span class="type">number</span> <span class="keyword">of</span> nodes <span class="keyword">is</span> <span class="keyword">not</span> a multiple <span class="keyword">of</span> k <span class="keyword">then</span> left-out nodes <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">end</span> should remain <span class="keyword">as</span> <span class="keyword">it</span> <span class="keyword">is</span>.

You may <span class="keyword">not</span> alter <span class="keyword">the</span> values <span class="keyword">in</span> <span class="keyword">the</span> nodes, only nodes itself may be changed.

Only <span class="type">constant</span> memory <span class="keyword">is</span> allowed.

For example,
Given this linked <span class="type">list</span>: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>

For k = <span class="number">2</span>, you should <span class="constant">return</span>: <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>

For k = <span class="number">3</span>, you should <span class="constant">return</span>: <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>
</code></pre><p>思路: 链表反转的变形，注意分组条件即可</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> ListNode reverseKGroup(ListNode head, <span class="built_in">int</span> k) {
    <span class="keyword">if</span>(head == <span class="literal">null</span>)
    {
        return <span class="literal">null</span>;
    }
    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
    dummy.<span class="keyword">next</span> = head;
    <span class="built_in">int</span> count = <span class="number">0</span>;
    ListNode pre = dummy;
    ListNode cur = head;
    <span class="keyword">while</span>(cur != <span class="literal">null</span>)
    {
        count ++;
        ListNode <span class="keyword">next</span> = cur.<span class="keyword">next</span>;
        <span class="keyword">if</span>(count == k)
        {
            pre = reverse(pre, <span class="keyword">next</span>);
            count = <span class="number">0</span>;   
        }
        cur = <span class="keyword">next</span>;
    }
    return dummy.<span class="keyword">next</span>;
}
<span class="keyword">private</span> ListNode reverse(ListNode pre, ListNode <span class="keyword">end</span>)
{
    <span class="keyword">if</span>(pre==<span class="literal">null</span> || pre.<span class="keyword">next</span>==<span class="literal">null</span>)
        return pre;
    ListNode head = pre.<span class="keyword">next</span>;
    ListNode cur = pre.<span class="keyword">next</span>.<span class="keyword">next</span>;
    <span class="keyword">while</span>(cur!=<span class="keyword">end</span>)
    {
        ListNode <span class="keyword">next</span> = cur.<span class="keyword">next</span>;
        cur.<span class="keyword">next</span> = pre.<span class="keyword">next</span>;
        pre.<span class="keyword">next</span> = cur;
        cur = <span class="keyword">next</span>;
    }
    head.<span class="keyword">next</span> = <span class="keyword">end</span>;
    return head;
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Regular Expression Matching]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/regular_expression_matching/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/regular_expression_matching/</id>
    <published>2014-06-05T01:39:54.000Z</published>
    <updated>2014-06-05T01:45:10.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Implement regular expression matching <span class="operator">with</span> support <span class="keyword">for</span> <span class="string">'.'</span> <span class="operator">and</span> <span class="string">'*'</span>.

<span class="string">'.'</span> Matches <span class="keyword">any</span> single <span class="keyword">character</span>.
<span class="string">'*'</span> Matches <span class="constant">zero</span> <span class="operator">or</span> more <span class="operator">of</span> <span class="operator">the</span> preceding <span class="keyword">element</span>.

The matching should cover <span class="operator">the</span> entire input <span class="keyword">string</span> (<span class="operator">not</span> partial).

The <span class="function"><span class="keyword">function</span> <span class="title">prototype</span> <span class="title">should</span> <span class="title">be</span>:</span>
bool isMatch(const <span class="keyword">char</span> *s, const <span class="keyword">char</span> *p)

Some examples:
isMatch(<span class="string">"aa"</span>,<span class="string">"a"</span>) → <span class="constant">false</span>
isMatch(<span class="string">"aa"</span>,<span class="string">"aa"</span>) → <span class="constant">true</span>
isMatch(<span class="string">"aaa"</span>,<span class="string">"aa"</span>) → <span class="constant">false</span>
isMatch(<span class="string">"aa"</span>, <span class="string">"a*"</span>) → <span class="constant">true</span>
isMatch(<span class="string">"aa"</span>, <span class="string">".*"</span>) → <span class="constant">true</span>
isMatch(<span class="string">"ab"</span>, <span class="string">".*"</span>) → <span class="constant">true</span>
isMatch(<span class="string">"aab"</span>, <span class="string">"c*a*b"</span>) → <span class="constant">true</span>
</code></pre><p>思路：注意s为1的情况，递归验证即可</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> boolean <span class="title">isMatch</span>(String s, String p) {

        <span class="keyword">if</span>(p.length() == <span class="number">0</span>)
            <span class="keyword">return</span> s.length() == <span class="number">0</span>;

        <span class="comment">//p's length 1 is special case    </span>
        <span class="keyword">if</span>(p.length() == <span class="number">1</span> || p.charAt(<span class="number">1</span>) != <span class="string">'*'</span>){
            <span class="keyword">if</span>(s.length() &lt; <span class="number">1</span> || (p.charAt(<span class="number">0</span>) != <span class="string">'.'</span> &amp;&amp; s.charAt(<span class="number">0</span>) != p.charAt(<span class="number">0</span>)))
                <span class="keyword">return</span> <span class="keyword">false</span>;
            <span class="keyword">return</span> isMatch(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));    

        }<span class="keyword">else</span>{
            <span class="keyword">int</span> len = s.length();

            <span class="keyword">int</span> i = -<span class="number">1</span>; 
            <span class="keyword">while</span>(i&lt;len &amp;&amp; (i &lt; <span class="number">0</span> || p.charAt(<span class="number">0</span>) == <span class="string">'.'</span> || p.charAt(<span class="number">0</span>) == s.charAt(i))){
                <span class="keyword">if</span>(isMatch(s.substring(i+<span class="number">1</span>), p.substring(<span class="number">2</span>)))
                    <span class="keyword">return</span> <span class="keyword">true</span>;
                i++;
            }
            <span class="keyword">return</span> <span class="keyword">false</span>;
        } 
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Path Sum]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/pathsum/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/pathsum/</id>
    <published>2014-06-05T01:33:39.000Z</published>
    <updated>2014-06-05T01:41:25.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> binary tree <span class="operator">and</span> <span class="operator">a</span> <span class="built_in">sum</span>, determine <span class="keyword">if</span> <span class="operator">the</span> tree has <span class="operator">a</span> root-<span class="built_in">to</span>-leaf path such that adding up all <span class="operator">the</span> values along <span class="operator">the</span> path equals <span class="operator">the</span> given <span class="built_in">sum</span>.

For example:
Given <span class="operator">the</span> below binary tree <span class="operator">and</span> <span class="built_in">sum</span> = <span class="number">22</span>,
              <span class="number">5</span>
             / \
            <span class="number">4</span>   <span class="number">8</span>
           /   / \
          <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span>
         /  \      \
        <span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span>
<span class="constant">return</span> <span class="constant">true</span>, <span class="keyword">as</span> there exist <span class="operator">a</span> root-<span class="built_in">to</span>-leaf path <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">11</span>-&gt;<span class="number">2</span> which <span class="built_in">sum</span> is <span class="number">22.</span>
</code></pre><p>思路：把所有节点放进队列里面，把节点的值放入另外一个队列里面，当它是叶子节点时，计算总和（BFS问题）</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> boolean hasPathSum(TreeNode root, <span class="built_in">int</span> sum) {
        <span class="keyword">if</span>(root == <span class="literal">null</span>) return <span class="literal">false</span>;

        LinkedList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();
        LinkedList&lt;Integer&gt; values = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();

        nodes.add(root);
        values.add(root.val);

        <span class="keyword">while</span>(!nodes.<span class="built_in">isEmpty</span>()){
            TreeNode curr = nodes.poll();
            <span class="built_in">int</span> sumValue = values.poll();

            <span class="keyword">if</span>(curr.<span class="built_in">left</span> == <span class="literal">null</span> &amp;&amp; curr.<span class="built_in">right</span> == <span class="literal">null</span> &amp;&amp; sumValue==sum){
                return <span class="literal">true</span>;
            }

            <span class="keyword">if</span>(curr.<span class="built_in">left</span> != <span class="literal">null</span>){
                nodes.add(curr.<span class="built_in">left</span>);
                values.add(sumValue+curr.<span class="built_in">left</span>.val);
            }

            <span class="keyword">if</span>(curr.<span class="built_in">right</span> != <span class="literal">null</span>){
                nodes.add(curr.<span class="built_in">right</span>);
                values.add(sumValue+curr.<span class="built_in">right</span>.val);
            }
        }

        return <span class="literal">false</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:Partition List]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/partition_list/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/partition_list/</id>
    <published>2014-06-05T01:28:44.000Z</published>
    <updated>2014-06-05T01:41:14.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given <span class="operator">a</span> linked list <span class="operator">and</span> <span class="operator">a</span> <span class="built_in">value</span> x, partition <span class="keyword">it</span> such that all nodes less than x come <span class="keyword">before</span> nodes greater than <span class="operator">or</span> equal <span class="built_in">to</span> x.

You should preserve <span class="operator">the</span> original <span class="built_in">relative</span> order <span class="operator">of</span> <span class="operator">the</span> nodes <span class="operator">in</span> <span class="keyword">each</span> <span class="operator">of</span> <span class="operator">the</span> <span class="constant">two</span> partitions.

For example,
Given <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span> <span class="operator">and</span> x = <span class="number">3</span>,
<span class="constant">return</span> <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5.</span>
</code></pre><p>思路：分两段拼接。</p>
<h4 id="解法">解法</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> ListNode <span class="title">partition</span>(ListNode head, <span class="keyword">int</span> x) {
        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;

        ListNode fakeHead1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
        ListNode fakeHead2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
        fakeHead1.next = head;

        ListNode p = head;
        ListNode prev = fakeHead1;
        ListNode p2 = fakeHead2;

        <span class="keyword">while</span>(p != <span class="keyword">null</span>){
            <span class="keyword">if</span>(p.val &lt; x){
                p = p.next;
                prev = prev.next;
            }<span class="keyword">else</span>{

                p2.next = p;
                prev.next = p.next;

                p = prev.next;
                p2 = p2.next;
            } 
        }

        <span class="comment">// close the list</span>
        p2.next = <span class="keyword">null</span>;

        prev.next = fakeHead2.next;

        <span class="keyword">return</span> fakeHead1.next;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode:NQueen I II]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/nqueen_i_ii/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/05/数据结构与算法/LeetCode/nqueen_i_ii/</id>
    <published>2014-06-05T01:18:13.000Z</published>
    <updated>2014-06-05T01:27:25.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>N-Queens
The n-queens puzzle <span class="keyword">is</span> the problem <span class="keyword">of</span> placing n queens <span class="keyword">on</span> an n×n chessboard such that no two queens attack each other.
Given an <span class="typename">integer</span> n, <span class="keyword">return</span> <span class="keyword">all</span> distinct solutions <span class="keyword">to</span> the n-queens puzzle.
Each solution contains a distinct board <span class="keyword">configuration</span> <span class="keyword">of</span> the n-queens' placement, where <span class="attribute">'Q</span>' <span class="keyword">and</span> '.' both indicate a queen 
<span class="keyword">and</span> an empty space respectively.
<span class="keyword">For</span> example,There exist two distinct solutions <span class="keyword">to</span> the <span class="number">4</span>-queens puzzle:
[
 [<span class="string">".Q.."</span>,  // Solution <span class="number">1</span>
  <span class="string">"...Q"</span>,
  <span class="string">"Q..."</span>,
  <span class="string">"..Q."</span>],

 [<span class="string">"..Q."</span>,  // Solution <span class="number">2</span>
  <span class="string">"Q..."</span>,
  <span class="string">"...Q"</span>,
  <span class="string">".Q.."</span>]
]
N-Queens II 
Follow up <span class="keyword">for</span> N-Queens problem.
Now, instead outputting board configurations, <span class="keyword">return</span> the total number <span class="keyword">of</span> distinct solutions.
</code></pre><p>思路: 传统的dfs递归,验证放置Queen的地方是否合法,输出Board结果</p>
<h4 id="解法">解法</h4>
<pre><code>NQueen I 
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> ArrayList&lt;String[]&gt; <span class="title">solveNQueens</span>(<span class="keyword">int</span> n) {
        ArrayList&lt;String[]&gt; res = <span class="keyword">new</span> ArrayList&lt;String[]&gt;();
        <span class="keyword">int</span>[] loc = <span class="keyword">new</span> <span class="keyword">int</span>[n];
        dfs(res,loc,<span class="number">0</span>,n);
        <span class="keyword">return</span> res;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span>(ArrayList&lt;String[]&gt; res, <span class="keyword">int</span>[] loc, <span class="keyword">int</span> cur, <span class="keyword">int</span> n){
        <span class="keyword">if</span>(cur==n) 
            printboard(res,loc,n);
        <span class="keyword">else</span>{
            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){
                loc[cur] = i;
                <span class="keyword">if</span>(isValid(loc,cur))
                    dfs(res,loc,cur+<span class="number">1</span>,n);
            }
        }
    }
    <span class="keyword">public</span> boolean <span class="title">isValid</span>(<span class="keyword">int</span>[] loc, <span class="keyword">int</span> cur){
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur;i++){
            <span class="keyword">if</span>(loc[i]==loc[cur]||Math.abs(loc[i]-loc[cur])==(cur-i))
                <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printboard</span>(ArrayList&lt;String[]&gt; res, <span class="keyword">int</span>[] loc, <span class="keyword">int</span> n){
        String[] ans = <span class="keyword">new</span> String[n];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){
            String row = <span class="keyword">new</span> String();
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){
                <span class="keyword">if</span>(j==loc[i]) row += <span class="string">"Q"</span>;
                <span class="keyword">else</span> row += <span class="string">"."</span>;
            }
            ans[i] = row;
        }
        res.add(ans);
    }
}
dfs的循环是指这一行里，从第一列到最后一列放置的所有可能，如果放置的地点通过isValid验证，
通过cur+<span class="number">1</span>进入下一行进行递归， 如果没通过验证，试下一个位置，如果所有位置都不Valid，跳回上一层

NQueen II
<span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">int</span> res; 
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span>(<span class="keyword">int</span> n) {
        res = <span class="number">0</span>;
        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> res;
        <span class="keyword">int</span>[] loc = <span class="keyword">new</span> <span class="keyword">int</span>[n];
        dfs(loc,<span class="number">0</span>,n);
        <span class="keyword">return</span> res;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span>(<span class="keyword">int</span>[] loc, <span class="keyword">int</span> cur, <span class="keyword">int</span> n){
        <span class="keyword">if</span> (cur==n) {
            res+=<span class="number">1</span>;
            <span class="keyword">return</span>;
        }
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){
            loc[cur] = i;
            <span class="keyword">if</span>(isValid(loc,cur))
                dfs(loc,cur+<span class="number">1</span>,n);
        }
    }
    <span class="keyword">public</span> boolean <span class="title">isValid</span>(<span class="keyword">int</span>[] loc, <span class="keyword">int</span> cur){
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur;i++){
            <span class="keyword">if</span>(loc[i]==loc[cur]||Math.abs(loc[i]-loc[cur])==(cur-i))
                <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
}
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode：Minimum Depth of Binary Tree]]></title>
    <link href="https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/minimum_depth_of_binary_tree/"/>
    <id>https://github.com/DaMinger/DaMinger.github.io.git/2014/06/04/数据结构与算法/LeetCode/minimum_depth_of_binary_tree/</id>
    <published>2014-06-04T05:33:53.000Z</published>
    <updated>2014-06-04T05:39:21.000Z</updated>
    <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<pre><code>Given a binary tree, find <span class="keyword">its</span> minimum depth.

The minimum depth <span class="keyword">is</span> <span class="keyword">the</span> <span class="type">number</span> <span class="keyword">of</span> nodes along <span class="keyword">the</span> shortest path <span class="keyword">from</span> <span class="keyword">the</span> root node down <span class="keyword">to</span> <span class="keyword">the</span> nearest leaf node.
</code></pre><p>思路：需要辅助队列，遍历到左子树或者右子树为空的时候，返回count</p>
<h4 id="解法">解法</h4>
<pre><code><span class="javadoc">/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span>
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span>(TreeNode root) {
        <span class="keyword">if</span>(root == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }

        LinkedList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();
        LinkedList&lt;Integer&gt; counts = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();

        nodes.add(root);
        counts.add(<span class="number">1</span>);

        <span class="keyword">while</span>(!nodes.isEmpty()){
            TreeNode curr = nodes.remove();
            <span class="keyword">int</span> count = counts.remove();

            <span class="keyword">if</span>(curr.left != <span class="keyword">null</span>){
                nodes.add(curr.left);
                counts.add(count+<span class="number">1</span>);
            }

            <span class="keyword">if</span>(curr.right != <span class="keyword">null</span>){
                nodes.add(curr.right);
                counts.add(count+<span class="number">1</span>);
            }

            <span class="keyword">if</span>(curr.left == <span class="keyword">null</span> &amp;&amp; curr.right == <span class="keyword">null</span>){
                <span class="keyword">return</span> count;
            }
        }

        <span class="keyword">return</span> <span class="number">0</span>;
    }
</code></pre>]]></content>
    
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://github.com/DaMinger/DaMinger.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
